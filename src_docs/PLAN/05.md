# Part 05: Build System & Feature Flags

## Overview

This document details TYPF v2.0's build system architecture, featuring a sophisticated feature flag system that enables selective compilation, minimal dependency builds, and optimized binary sizes for specific use cases.

## 5.1 Feature Flag Architecture

### Core Feature Categories

```toml
# Cargo.toml (root workspace)

[workspace]
members = [
    # Core
    "typf",
    "typf-core",
    "typf-input",
    "typf-unicode",
    "typf-fontdb",
    "typf-export",

    # Shaping backends
    "backends/typf-shape-none",
    "backends/typf-shape-hb",
    "backends/typf-shape-icu-hb",
    "backends/typf-shape-mac",
    "backends/typf-shape-win",

    # Rendering backends
    "backends/typf-render-json",
    "backends/typf-render-orge",
    "backends/typf-render-skia",
    "backends/typf-render-zeno",
    "backends/typf-render-mac",
    "backends/typf-render-win",

    # Bindings
    "bindings/typf-py",
    "bindings/typf-c",

    # CLI
    "typf-cli",
]

[workspace.package]
version = "2.0.0"
authors = ["TYPF Contributors"]
edition = "2021"
rust-version = "1.75"
license = "EVALUATION LICENSE"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
strip = true

[profile.release-with-debug]
inherits = "release"
strip = false
debug = true

[profile.bench]
inherits = "release"
lto = false
```

### Main Package Features

```toml
# typf/Cargo.toml

[package]
name = "typf"
version.workspace = true
edition.workspace = true

[features]
default = ["auto-backend", "common-formats"]

# Backend Selection
auto-backend = ["shaping-auto", "render-auto"]
minimal = ["shaping-none", "render-orge", "format-pnm"]
full = ["all-shaping", "all-render", "all-formats"]

# Shaping Backends
shaping-auto = []
shaping-none = ["dep:typf-shape-none"]
shaping-hb = ["dep:typf-shape-hb", "dep:harfbuzz-sys"]
shaping-icu-hb = ["shaping-hb", "dep:typf-shape-icu-hb", "dep:icu"]
shaping-mac = ["dep:typf-shape-mac", "dep:core-text", "dep:core-foundation"]
shaping-win = ["dep:typf-shape-win", "dep:windows"]
all-shaping = ["shaping-none", "shaping-hb", "shaping-icu-hb"]

# Platform-specific shaping
[target.'cfg(target_os = "macos")'.features]
shaping-auto = ["shaping-mac"]
all-shaping = ["shaping-none", "shaping-hb", "shaping-icu-hb", "shaping-mac"]

[target.'cfg(target_os = "windows")'.features]
shaping-auto = ["shaping-win"]
all-shaping = ["shaping-none", "shaping-hb", "shaping-icu-hb", "shaping-win"]

[target.'cfg(not(any(target_os = "macos", target_os = "windows")))'.features]
shaping-auto = ["shaping-icu-hb"]

# Rendering Backends
render-auto = []
render-json = ["dep:typf-render-json", "dep:serde_json"]
render-orge = ["dep:typf-render-orge"]
render-skia = ["dep:typf-render-skia", "dep:tiny-skia"]
render-skia-svg = ["render-skia"]
render-zeno = ["dep:typf-render-zeno", "dep:zeno"]
render-zeno-svg = ["render-zeno"]
render-mac = ["dep:typf-render-mac", "dep:core-graphics"]
render-win = ["dep:typf-render-win", "dep:windows"]
all-render = ["render-json", "render-orge", "render-skia", "render-zeno"]

# Platform-specific rendering
[target.'cfg(target_os = "macos")'.features]
render-auto = ["render-mac"]
all-render = ["render-json", "render-orge", "render-skia", "render-zeno", "render-mac"]

[target.'cfg(target_os = "windows")'.features]
render-auto = ["render-win"]
all-render = ["render-json", "render-orge", "render-skia", "render-zeno", "render-win"]

[target.'cfg(not(any(target_os = "macos", target_os = "windows")))'.features]
render-auto = ["render-orge"]

# Output Formats
format-png = ["dep:png"]
format-jpg = ["dep:jpeg-encoder"]
format-pnm = []  # Built-in, no deps
format-svg = []  # Built-in, text generation
format-pdf = ["dep:printpdf"]
format-webp = ["dep:webp"]
common-formats = ["format-png", "format-svg", "format-pnm"]
all-formats = ["common-formats", "format-jpg", "format-pdf", "format-webp"]

# Performance Features
parallel = ["dep:rayon", "typf-core/parallel"]
simd = ["typf-core/simd"]
cache-aggressive = ["typf-core/cache-aggressive"]
mmap = ["dep:memmap2", "typf-fontdb/mmap"]

# Developer Features
debug-visualize = ["dep:resvg", "dep:usvg"]
profiling = ["dep:puffin", "dep:tracy-client"]
benchmarking = ["dep:criterion"]

[dependencies]
typf-core = { path = "../typf-core" }
typf-input = { path = "../typf-input" }
typf-unicode = { path = "../typf-unicode" }
typf-fontdb = { path = "../typf-fontdb" }
typf-export = { path = "../typf-export" }

# Optional backend dependencies
typf-shape-none = { path = "../backends/typf-shape-none", optional = true }
typf-shape-hb = { path = "../backends/typf-shape-hb", optional = true }
typf-shape-icu-hb = { path = "../backends/typf-shape-icu-hb", optional = true }
typf-shape-mac = { path = "../backends/typf-shape-mac", optional = true }
typf-shape-win = { path = "../backends/typf-shape-win", optional = true }

typf-render-json = { path = "../backends/typf-render-json", optional = true }
typf-render-orge = { path = "../backends/typf-render-orge", optional = true }
typf-render-skia = { path = "../backends/typf-render-skia", optional = true }
typf-render-zeno = { path = "../backends/typf-render-zeno", optional = true }
typf-render-mac = { path = "../backends/typf-render-mac", optional = true }
typf-render-win = { path = "../backends/typf-render-win", optional = true }

# Core dependencies
read-fonts = "0.36"
skrifa = "0.39"

# Optional dependencies
harfbuzz-sys = { version = "0.5", optional = true }
icu = { version = "1.5", optional = true }
tiny-skia = { version = "0.11", optional = true }
zeno = { version = "0.2", optional = true }
png = { version = "0.17", optional = true }
jpeg-encoder = { version = "0.6", optional = true }
printpdf = { version = "0.7", optional = true }
webp = { version = "0.3", optional = true }
rayon = { version = "1.10", optional = true }
memmap2 = { version = "0.9", optional = true }
serde_json = { version = "1.0", optional = true }

# Platform-specific
[target.'cfg(target_os = "macos")'.dependencies]
core-text = { version = "20.0", optional = true }
core-foundation = { version = "0.10", optional = true }
core-graphics = { version = "0.24", optional = true }

[target.'cfg(target_os = "windows")'.dependencies]
windows = { version = "0.58", features = ["Win32_Graphics_DirectWrite", "Win32_Graphics_Direct2D"], optional = true }

# Dev dependencies
[dev-dependencies]
criterion = { version = "0.5", optional = true }
puffin = { version = "0.19", optional = true }
tracy-client = { version = "0.17", optional = true }
resvg = { version = "0.44", optional = true }
usvg = { version = "0.44", optional = true }
```

## 5.2 Conditional Compilation Patterns

### Backend Registration

```rust
// typf-core/src/backend_registry.rs

use cfg_if::cfg_if;

pub struct BackendRegistry {
    shapers: HashMap<ShapingBackend, Arc<dyn Shaper>>,
    renderers: HashMap<RenderBackend, Arc<dyn Renderer>>,
}

impl BackendRegistry {
    pub fn new() -> Result<Self, RegistryError> {
        let mut registry = Self {
            shapers: HashMap::new(),
            renderers: HashMap::new(),
        };

        // Register shaping backends based on features
        cfg_if! {
            if #[cfg(feature = "shaping-none")] {
                registry.register_shaper(
                    ShapingBackend::None,
                    Arc::new(typf_shape_none::NoneShaper::new())
                );
            }
        }

        cfg_if! {
            if #[cfg(feature = "shaping-hb")] {
                registry.register_shaper(
                    ShapingBackend::HarfBuzz,
                    Arc::new(typf_shape_hb::HarfBuzzShaper::new()?)
                );
            }
        }

        cfg_if! {
            if #[cfg(feature = "shaping-icu-hb")] {
                registry.register_shaper(
                    ShapingBackend::IcuHarfBuzz,
                    Arc::new(typf_shape_icu_hb::IcuHarfBuzzShaper::new()?)
                );
            }
        }

        cfg_if! {
            if #[cfg(all(target_os = "macos", feature = "shaping-mac"))] {
                registry.register_shaper(
                    ShapingBackend::Mac,
                    Arc::new(typf_shape_mac::CoreTextShaper::new()?)
                );
            }
        }

        cfg_if! {
            if #[cfg(all(target_os = "windows", feature = "shaping-win"))] {
                registry.register_shaper(
                    ShapingBackend::Win,
                    Arc::new(typf_shape_win::DirectWriteShaper::new()?)
                );
            }
        }

        // Auto backend resolution
        cfg_if! {
            if #[cfg(feature = "shaping-auto")] {
                let auto_shaper = Self::resolve_auto_shaper(&registry)?;
                registry.register_shaper(ShapingBackend::Auto, auto_shaper);
            }
        }

        // Register rendering backends
        cfg_if! {
            if #[cfg(feature = "render-json")] {
                registry.register_renderer(
                    RenderBackend::Json,
                    Arc::new(typf_render_json::JsonRenderer::new())
                );
            }
        }

        cfg_if! {
            if #[cfg(feature = "render-orge")] {
                registry.register_renderer(
                    RenderBackend::Orge,
                    Arc::new(typf_render_orge::OrgeRenderer::new()?)
                );
            }
        }

        cfg_if! {
            if #[cfg(feature = "render-skia")] {
                registry.register_renderer(
                    RenderBackend::Skia,
                    Arc::new(typf_render_skia::SkiaRenderer::new(false))
                );

                #[cfg(feature = "render-skia-svg")]
                registry.register_renderer(
                    RenderBackend::SkiaSvg,
                    Arc::new(typf_render_skia::SkiaRenderer::new(true))
                );
            }
        }

        cfg_if! {
            if #[cfg(feature = "render-zeno")] {
                registry.register_renderer(
                    RenderBackend::Zeno,
                    Arc::new(typf_render_zeno::ZenoRenderer::new(false))
                );

                #[cfg(feature = "render-zeno-svg")]
                registry.register_renderer(
                    RenderBackend::ZenoSvg,
                    Arc::new(typf_render_zeno::ZenoRenderer::new(true))
                );
            }
        }

        Ok(registry)
    }

    #[cfg(feature = "shaping-auto")]
    fn resolve_auto_shaper(registry: &BackendRegistry) -> Result<Arc<dyn Shaper>, RegistryError> {
        cfg_if! {
            if #[cfg(all(target_os = "macos", feature = "shaping-mac"))] {
                registry.shapers.get(&ShapingBackend::Mac).cloned()
            } else if #[cfg(all(target_os = "windows", feature = "shaping-win"))] {
                registry.shapers.get(&ShapingBackend::Win).cloned()
            } else if #[cfg(feature = "shaping-icu-hb")] {
                registry.shapers.get(&ShapingBackend::IcuHarfBuzz).cloned()
            } else if #[cfg(feature = "shaping-hb")] {
                registry.shapers.get(&ShapingBackend::HarfBuzz).cloned()
            } else if #[cfg(feature = "shaping-none")] {
                registry.shapers.get(&ShapingBackend::None).cloned()
            } else {
                None
            }
        }.ok_or(RegistryError::NoBackendAvailable)
    }
}
```

### Feature Detection at Runtime

```rust
// typf-core/src/features.rs

pub struct FeatureDetector;

impl FeatureDetector {
    pub fn available_shaping_backends() -> Vec<ShapingBackend> {
        let mut backends = Vec::new();

        #[cfg(feature = "shaping-none")]
        backends.push(ShapingBackend::None);

        #[cfg(feature = "shaping-hb")]
        backends.push(ShapingBackend::HarfBuzz);

        #[cfg(feature = "shaping-icu-hb")]
        backends.push(ShapingBackend::IcuHarfBuzz);

        #[cfg(all(target_os = "macos", feature = "shaping-mac"))]
        backends.push(ShapingBackend::Mac);

        #[cfg(all(target_os = "windows", feature = "shaping-win"))]
        backends.push(ShapingBackend::Win);

        backends
    }

    pub fn available_render_backends() -> Vec<RenderBackend> {
        let mut backends = Vec::new();

        #[cfg(feature = "render-json")]
        backends.push(RenderBackend::Json);

        #[cfg(feature = "render-orge")]
        backends.push(RenderBackend::Orge);

        #[cfg(feature = "render-skia")]
        backends.push(RenderBackend::Skia);

        #[cfg(feature = "render-skia-svg")]
        backends.push(RenderBackend::SkiaSvg);

        #[cfg(feature = "render-zeno")]
        backends.push(RenderBackend::Zeno);

        #[cfg(feature = "render-zeno-svg")]
        backends.push(RenderBackend::ZenoSvg);

        backends
    }

    pub fn available_formats() -> Vec<OutputFormat> {
        let mut formats = Vec::new();

        formats.push(OutputFormat::Json); // Always available with json renderer

        #[cfg(feature = "format-pnm")]
        formats.extend([OutputFormat::Pbm, OutputFormat::Pgm, OutputFormat::Ppm]);

        #[cfg(feature = "format-png")]
        formats.push(OutputFormat::Png);

        #[cfg(feature = "format-jpg")]
        formats.push(OutputFormat::Jpeg);

        #[cfg(feature = "format-svg")]
        formats.push(OutputFormat::Svg);

        #[cfg(feature = "format-pdf")]
        formats.push(OutputFormat::Pdf);

        #[cfg(feature = "format-webp")]
        formats.push(OutputFormat::WebP);

        formats
    }

    pub fn is_backend_combination_valid(shaping: ShapingBackend, render: RenderBackend) -> bool {
        // Check for invalid combinations
        match (shaping, render) {
            // Mac shaping requires font handle that only works with Mac/Json/bitmap renderers
            (ShapingBackend::Mac, RenderBackend::Win) => false,
            // Win shaping requires font handle that only works with Win/Json/bitmap renderers
            (ShapingBackend::Win, RenderBackend::Mac) => false,
            // None shaping doesn't work well with native renderers
            (ShapingBackend::None, RenderBackend::Mac | RenderBackend::Win) => false,
            _ => true,
        }
    }
}
```

## 5.3 Minimal Build Configurations

### Ultra-Minimal Build

```toml
# examples/minimal-build/Cargo.toml

[package]
name = "typf-minimal"
version = "1.0.0"
edition = "2021"

[dependencies]
typf = { path = "../../typf", default-features = false, features = ["minimal"] }

# Results in:
# - No ICU dependency
# - No HarfBuzz dependency
# - No platform dependencies
# - No image format libraries
# - Total size: ~500KB
```

```rust
// examples/minimal-build/src/main.rs

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let typf = Typf::builder()
        .shaping_backend(ShapingBackend::None)
        .render_backend(RenderBackend::Orge)
        .build()?;

    let result = typf.render_with_options(
        "Hello, World!",
        RenderOptions::builder()
            .font("path/to/font.ttf")
            .size(16.0)
            .format(OutputFormat::Pnm)
            .build()
    )?;

    // Save as PNM (no external dependencies)
    std::fs::write("output.ppm", result.as_bytes())?;
    Ok(())
}
```

### Platform-Optimized Build

```toml
# examples/platform-optimized/Cargo.toml

[package]
name = "typf-platform"
version = "1.0.0"
edition = "2021"

[dependencies]
# Auto-selects best platform backend
typf = { path = "../../typf", features = ["auto-backend", "format-png", "format-svg"] }
```

### Full-Featured Build

```toml
# examples/full-featured/Cargo.toml

[package]
name = "typf-full"
version = "1.0.0"
edition = "2021"

[dependencies]
typf = { path = "../../typf", features = ["full", "parallel", "simd", "cache-aggressive"] }
```

## 5.4 Build Scripts and Configuration

### Workspace Build Script

```rust
// build.rs (workspace root)

use std::env;
use std::path::PathBuf;

fn main() {
    // Detect platform capabilities
    detect_simd_support();
    detect_system_libraries();
    configure_optimization_flags();
    generate_feature_report();
}

fn detect_simd_support() {
    #[cfg(target_arch = "x86_64")]
    {
        if is_x86_feature_detected!("avx2") {
            println!("cargo:rustc-cfg=typf_simd_avx2");
        }
        if is_x86_feature_detected!("sse4.1") {
            println!("cargo:rustc-cfg=typf_simd_sse41");
        }
    }

    #[cfg(target_arch = "aarch64")]
    {
        println!("cargo:rustc-cfg=typf_simd_neon");
    }
}

fn detect_system_libraries() {
    // Check for system HarfBuzz
    if pkg_config::probe_library("harfbuzz").is_ok() {
        println!("cargo:rustc-cfg=system_harfbuzz");
    }

    // Check for system ICU
    if pkg_config::probe_library("icu-uc").is_ok() &&
       pkg_config::probe_library("icu-i18n").is_ok() {
        println!("cargo:rustc-cfg=system_icu");
    }
}

fn configure_optimization_flags() {
    let profile = env::var("PROFILE").unwrap();

    if profile == "release" {
        // Enable link-time optimization
        println!("cargo:rustc-link-arg=-flto=thin");

        // Enable specific CPU optimizations if requested
        if let Ok(cpu) = env::var("TYPF_TARGET_CPU") {
            println!("cargo:rustc-link-arg=-march={}", cpu);
        }
    }
}

fn generate_feature_report() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let report_path = out_dir.join("feature_report.rs");

    let mut report = String::new();
    report.push_str("/// Auto-generated feature report\n");
    report.push_str("pub const ENABLED_FEATURES: &[&str] = &[\n");

    for (key, _) in env::vars() {
        if key.starts_with("CARGO_FEATURE_") {
            let feature = key.strip_prefix("CARGO_FEATURE_").unwrap();
            let feature = feature.to_lowercase().replace('_', "-");
            report.push_str(&format!("    \"{}\",\n", feature));
        }
    }

    report.push_str("];\n");

    std::fs::write(report_path, report).unwrap();
}
```

### Backend-Specific Build Scripts

```rust
// backends/typf-shape-hb/build.rs

fn main() {
    // Try to use system HarfBuzz if available
    #[cfg(feature = "system-harfbuzz")]
    {
        if pkg_config::probe_library("harfbuzz").is_ok() {
            return;
        }
    }

    // Otherwise build HarfBuzz from source
    build_harfbuzz_from_source();
}

fn build_harfbuzz_from_source() {
    let mut cfg = cc::Build::new();

    cfg.cpp(true)
        .include("harfbuzz/src")
        .define("HAVE_FREETYPE", "1")
        .define("HB_NO_MT", None) // Single-threaded for simplicity
        .file("harfbuzz/src/harfbuzz.cc");

    // Platform-specific configuration
    #[cfg(target_os = "macos")]
    cfg.define("HAVE_CORETEXT", "1");

    #[cfg(target_os = "windows")]
    cfg.define("HAVE_DIRECTWRITE", "1");

    cfg.compile("harfbuzz");

    println!("cargo:rustc-link-lib=static=harfbuzz");
}
```

## 5.5 Cross-Compilation Support

### Cross-Compilation Configuration

```toml
# .cargo/config.toml

[target.aarch64-unknown-linux-gnu]
linker = "aarch64-linux-gnu-gcc"

[target.x86_64-pc-windows-gnu]
linker = "x86_64-w64-mingw32-gcc"
ar = "x86_64-w64-mingw32-ar"

[target.wasm32-unknown-unknown]
runner = "wasm-bindgen-test-runner"

[target.wasm32-wasi]
runner = "wasmtime"

# Platform-specific environment variables
[env]
TYPF_CROSS_COMPILE = "1"
```

### WebAssembly Build

```toml
# typf-wasm/Cargo.toml

[package]
name = "typf-wasm"
version = "2.0.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
typf = { path = "../typf", default-features = false, features = [
    "shaping-hb",      # HarfBuzz works in WASM
    "render-orge",     # Pure Rust renderer
    "format-png",      # PNG encoding works
    "format-svg",      # SVG generation works
]}
wasm-bindgen = "0.2"
web-sys = "0.3"

[target.'cfg(target_arch = "wasm32")'.dependencies]
getrandom = { version = "0.2", features = ["js"] }
```

### Docker Build Environments

```dockerfile
# docker/Dockerfile.minimal

FROM rust:1.75-alpine AS builder
RUN apk add --no-cache musl-dev
WORKDIR /build
COPY . .
RUN cargo build --release --features minimal
RUN strip target/release/typf

FROM scratch
COPY --from=builder /build/target/release/typf /
ENTRYPOINT ["/typf"]
```

```dockerfile
# docker/Dockerfile.full

FROM rust:1.75 AS builder
RUN apt-get update && apt-get install -y \
    libharfbuzz-dev \
    libicu-dev \
    libfreetype6-dev \
    pkg-config
WORKDIR /build
COPY . .
RUN cargo build --release --features full
RUN strip target/release/typf

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y \
    libharfbuzz0b \
    libicu72 \
    libfreetype6 \
    && rm -rf /var/lib/apt/lists/*
COPY --from=builder /build/target/release/typf /usr/local/bin/
ENTRYPOINT ["typf"]
```

## 5.6 CI/CD Build Matrix

### GitHub Actions Configuration

```yaml
# .github/workflows/ci.yml

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  RUST_BACKTRACE: 1
  CARGO_TERM_COLOR: always

jobs:
  check-minimal:
    name: Check Minimal Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Check minimal build
        run: cargo check --no-default-features --features minimal
      - name: Check binary size
        run: |
          cargo build --release --no-default-features --features minimal
          size=$(stat -c%s target/release/typf)
          if [ $size -gt 1048576 ]; then
            echo "Binary too large: $size bytes (limit: 1MB)"
            exit 1
          fi

  test-matrix:
    name: Test ${{ matrix.os }} / ${{ matrix.features }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        features:
          - minimal
          - auto-backend,common-formats
          - shaping-hb,render-orge,format-png
          - shaping-icu-hb,render-skia,all-formats
          - full
        exclude:
          # Mac-specific backend only on macOS
          - os: ubuntu-latest
            features: shaping-mac,render-mac
          - os: windows-latest
            features: shaping-mac,render-mac
          # Windows-specific backend only on Windows
          - os: ubuntu-latest
            features: shaping-win,render-win
          - os: macos-latest
            features: shaping-win,render-win

    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable

      - name: Install system dependencies (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libharfbuzz-dev libicu-dev

      - name: Install system dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install harfbuzz icu4c

      - name: Build
        run: cargo build --no-default-features --features "${{ matrix.features }}"

      - name: Test
        run: cargo test --no-default-features --features "${{ matrix.features }}"

  cross-compile:
    name: Cross Compile ${{ matrix.target }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target:
          - aarch64-unknown-linux-gnu
          - armv7-unknown-linux-gnueabihf
          - x86_64-pc-windows-gnu
          - wasm32-unknown-unknown
          - wasm32-wasi

    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cross
        run: cargo install cross --git https://github.com/cross-rs/cross

      - name: Build
        run: cross build --target ${{ matrix.target }} --features minimal

  benchmark:
    name: Benchmark
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Run benchmarks
        run: cargo bench --features "benchmarking full"
      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: benchmarks
          path: target/criterion
```

## 5.7 Build Size Optimization

### Size Comparison Table

| Configuration | Features | Dependencies | Binary Size | Use Case |
|--------------|----------|--------------|-------------|----------|
| Minimal | `shaping-none`, `render-orge`, `format-pnm` | None | ~500KB | Embedded systems |
| Basic | `shaping-hb`, `render-orge`, `format-png` | HarfBuzz, PNG | ~2MB | CLI tools |
| Platform | `auto-backend`, `common-formats` | Platform-specific | ~3MB | Desktop apps |
| Full | `all-shaping`, `all-render`, `all-formats` | All | ~10MB | Professional tools |
| WASM | `shaping-hb`, `render-orge`, `format-png` | WASM-compatible | ~1MB | Web apps |

### Size Optimization Techniques

```rust
// typf-core/src/optimize.rs

/// Compile-time optimizations based on features
#[cfg(feature = "optimize-size")]
pub mod size_optimizations {
    // Use smaller data structures
    pub type GlyphId = u16; // Instead of u32
    pub type Coord = i16;   // Instead of f32 for some cases

    // Disable caching in size-optimized builds
    pub struct NoOpCache;
    impl Cache for NoOpCache {
        fn get(&self, _key: &CacheKey) -> Option<CachedItem> { None }
        fn insert(&self, _key: CacheKey, _value: CachedItem) {}
    }
}

#[cfg(not(feature = "optimize-size"))]
pub mod size_optimizations {
    pub type GlyphId = u32;
    pub type Coord = f32;
    pub use crate::cache::LruCache as Cache;
}
```

## 5.8 Feature Documentation

### Auto-Generated Feature Documentation

```rust
// build.rs

fn generate_feature_docs() {
    let features = vec![
        ("minimal", "Minimal build with no external dependencies"),
        ("full", "Full build with all backends and formats"),
        ("shaping-hb", "HarfBuzz shaping backend"),
        ("shaping-icu-hb", "ICU + HarfBuzz shaping backend"),
        ("shaping-mac", "CoreText shaping backend (macOS only)"),
        ("shaping-win", "DirectWrite shaping backend (Windows only)"),
        ("render-orge", "Custom Orge rasterizer"),
        ("render-skia", "TinySkia renderer"),
        ("format-png", "PNG output support"),
        ("format-svg", "SVG output support"),
    ];

    let mut doc = String::new();
    doc.push_str("# Available Features\n\n");

    for (feature, description) in features {
        doc.push_str(&format!("- `{}`: {}\n", feature, description));
    }

    std::fs::write("FEATURES.md", doc).unwrap();
}
```

## Next Steps

With the build system and feature flags defined, Part 06 will detail performance optimizations including SIMD usage, caching strategies, and benchmarking infrastructure.
