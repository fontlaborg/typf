# Part 07: CLI & Python Bindings

## Overview

This document details TYPF v2.0's command-line interface and Python bindings, providing both a powerful Rust CLI application and seamless Python integration with Fire-based CLI generation.

## 7.1 Rust CLI Architecture

### Main CLI Application

```rust
// typf-cli/src/main.rs

use clap::{Parser, Subcommand, Args};
use typf::prelude::*;

#[derive(Parser)]
#[command(name = "typf")]
#[command(version, about = "High-performance text shaping and rendering")]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    /// Verbose output
    #[arg(short, long, global = true)]
    verbose: bool,

    /// Output format for non-file outputs
    #[arg(long, global = true)]
    output_format: Option<OutputFormat>,

    /// Number of threads (0 = auto)
    #[arg(short = 'j', long, global = true, default_value = "0")]
    threads: usize,

    /// Enable performance profiling
    #[arg(long, global = true)]
    profile: bool,
}

#[derive(Subcommand)]
enum Commands {
    /// Render text to an image or vector file
    Render(RenderArgs),

    /// Shape text and output shaping information
    Shape(ShapeArgs),

    /// Analyze font files
    Font(FontArgs),

    /// List available backends and features
    Info(InfoArgs),

    /// Batch process multiple texts
    Batch(BatchArgs),

    /// Run benchmark suite
    Bench(BenchArgs),

    /// Interactive REPL mode
    Repl(ReplArgs),
}

#[derive(Args)]
struct RenderArgs {
    /// Text to render (or @file to read from file)
    text: String,

    /// Output file path
    #[arg(short, long)]
    output: PathBuf,

    /// Font specification (path or system name)
    #[arg(short, long)]
    font: String,

    /// Font size in points
    #[arg(short, long, default_value = "16.0")]
    size: f32,

    /// Shaping backend
    #[arg(long, default_value = "auto")]
    shaping_backend: ShapingBackend,

    /// Rendering backend
    #[arg(long, default_value = "auto")]
    render_backend: RenderBackend,

    /// Foreground color (hex or name)
    #[arg(long, default_value = "black")]
    color: String,

    /// Background color (hex or name, "none" for transparent)
    #[arg(long, default_value = "none")]
    background: String,

    /// Language tag (BCP 47)
    #[arg(long)]
    language: Option<String>,

    /// OpenType features (comma-separated)
    #[arg(long, value_delimiter = ',')]
    features: Vec<String>,

    /// Font variations (comma-separated key=value)
    #[arg(long, value_delimiter = ',')]
    variations: Vec<String>,

    /// Letter spacing in em units
    #[arg(long)]
    letter_spacing: Option<f32>,

    /// Enable subpixel rendering
    #[arg(long)]
    subpixel: bool,

    /// Hinting mode (none, slight, full)
    #[arg(long, default_value = "slight")]
    hinting: HintingMode,

    /// DPI for rasterization
    #[arg(long, default_value = "96")]
    dpi: u32,
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    // Initialize logging
    env_logger::Builder::new()
        .filter_level(if cli.verbose {
            log::LevelFilter::Debug
        } else {
            log::LevelFilter::Info
        })
        .init();

    // Initialize profiling if requested
    if cli.profile {
        Profiler::start_frame();
    }

    // Set thread pool size
    if cli.threads > 0 {
        rayon::ThreadPoolBuilder::new()
            .num_threads(cli.threads)
            .build_global()?;
    }

    // Execute command
    let result = match cli.command {
        Commands::Render(args) => render_command(args),
        Commands::Shape(args) => shape_command(args),
        Commands::Font(args) => font_command(args),
        Commands::Info(args) => info_command(args),
        Commands::Batch(args) => batch_command(args),
        Commands::Bench(args) => bench_command(args),
        Commands::Repl(args) => repl_command(args),
    };

    if cli.profile {
        Profiler::end_frame();
        print_profile_report();
    }

    result
}

fn render_command(args: RenderArgs) -> Result<()> {
    // Parse text input
    let text = if args.text.starts_with('@') {
        std::fs::read_to_string(&args.text[1..])?
    } else {
        args.text
    };

    // Create TYPF instance
    let typf = Typf::builder()
        .shaping_backend(args.shaping_backend)
        .render_backend(args.render_backend)
        .build()?;

    // Parse colors
    let foreground = parse_color(&args.color)?;
    let background = if args.background == "none" {
        None
    } else {
        Some(parse_color(&args.background)?)
    };

    // Parse features and variations
    let features = parse_features(&args.features)?;
    let variations = parse_variations(&args.variations)?;

    // Detect output format from extension
    let format = args.output.extension()
        .and_then(|ext| ext.to_str())
        .and_then(|ext| OutputFormat::from_extension(ext))
        .ok_or_else(|| anyhow!("Cannot determine output format from extension"))?;

    // Render
    let result = typf.render_with_options(
        &text,
        RenderOptions::builder()
            .font(args.font)
            .size(args.size)
            .foreground(foreground)
            .background(background)
            .language(args.language)
            .features(features)
            .variations(variations)
            .letter_spacing(args.letter_spacing)
            .hinting(args.hinting)
            .subpixel(if args.subpixel {
                SubpixelMode::Rgb
            } else {
                SubpixelMode::None
            })
            .dpi(args.dpi)
            .format(format)
            .build()
    )?;

    // Save output
    match result {
        RenderOutput::Bitmap(data) => {
            std::fs::write(&args.output, data.as_bytes())?;
            println!("Rendered {} to {:?}", text.chars().count(), args.output);
        }
        RenderOutput::Vector(data) => {
            std::fs::write(&args.output, data.as_str())?;
            println!("Rendered {} to {:?}", text.chars().count(), args.output);
        }
        RenderOutput::Json(data) => {
            std::fs::write(&args.output, data.as_str())?;
            println!("Shaped {} to {:?}", text.chars().count(), args.output);
        }
    }

    Ok(())
}
```

### Interactive REPL Mode

```rust
// typf-cli/src/repl.rs

use rustyline::Editor;
use rustyline::error::ReadlineError;

pub fn repl_command(_args: ReplArgs) -> Result<()> {
    let mut rl = Editor::<()>::new()?;
    let mut typf = Typf::new()?;
    let mut context = ReplContext::default();

    println!("TYPF Interactive Shell v{}", env!("CARGO_PKG_VERSION"));
    println!("Type 'help' for commands, 'exit' to quit\n");

    loop {
        let prompt = format!("typf:{}> ", context.current_font_name());

        match rl.readline(&prompt) {
            Ok(line) => {
                rl.add_history_entry(&line);

                if let Err(e) = process_repl_command(&line, &mut typf, &mut context) {
                    eprintln!("Error: {}", e);
                }
            }
            Err(ReadlineError::Interrupted) => {
                println!("^C");
                continue;
            }
            Err(ReadlineError::Eof) => {
                println!("exit");
                break;
            }
            Err(err) => {
                eprintln!("Error: {:?}", err);
                break;
            }
        }
    }

    Ok(())
}

fn process_repl_command(
    line: &str,
    typf: &mut Typf,
    context: &mut ReplContext
) -> Result<()> {
    let parts: Vec<&str> = line.split_whitespace().collect();
    if parts.is_empty() {
        return Ok(());
    }

    match parts[0] {
        "help" | "?" => print_repl_help(),
        "exit" | "quit" | "q" => std::process::exit(0),

        "font" => {
            if parts.len() > 1 {
                context.set_font(parts[1])?;
                println!("Font set to: {}", parts[1]);
            } else {
                println!("Current font: {}", context.current_font_name());
            }
        }

        "size" => {
            if parts.len() > 1 {
                let size: f32 = parts[1].parse()?;
                context.size = size;
                println!("Size set to: {}", size);
            } else {
                println!("Current size: {}", context.size);
            }
        }

        "shape" => {
            let text = parts[1..].join(" ");
            let result = typf.shape_with_options(
                &text,
                context.to_shaping_options()
            )?;
            print_shaping_result(&result);
        }

        "render" => {
            let text = parts[1..].join(" ");
            let output = if let Some(idx) = parts.iter().position(|&s| s == ">") {
                parts[idx + 1].to_string()
            } else {
                format!("output_{}.png", context.render_count)
            };

            let result = typf.render_with_options(
                &text,
                context.to_render_options()
            )?;

            std::fs::write(&output, result.as_bytes())?;
            println!("Rendered to: {}", output);
            context.render_count += 1;
        }

        "measure" => {
            let text = parts[1..].join(" ");
            let metrics = typf.measure(&text, context.to_render_options())?;
            println!("Width: {:.2}px", metrics.width);
            println!("Height: {:.2}px", metrics.height);
            println!("Advance: {:.2}px", metrics.advance);
        }

        "backends" => {
            println!("Shaping backends: {:?}", FeatureDetector::available_shaping_backends());
            println!("Render backends: {:?}", FeatureDetector::available_render_backends());
        }

        _ => {
            // Try to interpret as text to shape
            let result = typf.shape(line)?;
            print_shaping_result(&result);
        }
    }

    Ok(())
}
```

### Batch Processing

```rust
// typf-cli/src/batch.rs

use serde::{Deserialize, Serialize};
use indicatif::{ProgressBar, ProgressStyle};

#[derive(Deserialize)]
struct BatchConfig {
    defaults: BatchDefaults,
    items: Vec<BatchItem>,
}

#[derive(Deserialize)]
struct BatchDefaults {
    font: String,
    size: f32,
    #[serde(default)]
    output_dir: PathBuf,
    #[serde(default)]
    format: OutputFormat,
}

#[derive(Deserialize)]
struct BatchItem {
    text: String,
    #[serde(flatten)]
    overrides: Option<BatchOverrides>,
}

pub fn batch_command(args: BatchArgs) -> Result<()> {
    let config_str = std::fs::read_to_string(&args.config)?;
    let config: BatchConfig = match args.config.extension().and_then(|e| e.to_str()) {
        Some("json") => serde_json::from_str(&config_str)?,
        Some("toml") => toml::from_str(&config_str)?,
        Some("yaml") | Some("yml") => serde_yaml::from_str(&config_str)?,
        _ => anyhow::bail!("Unsupported config format"),
    };

    let typf = Typf::new()?;
    let pb = ProgressBar::new(config.items.len() as u64);
    pb.set_style(
        ProgressStyle::default_bar()
            .template("{spinner:.green} [{bar:40.cyan/blue}] {pos}/{len} ({eta})")?
            .progress_chars("#>-")
    );

    // Process items in parallel if enabled
    let results: Vec<_> = if args.parallel {
        config.items
            .par_iter()
            .progress_with(pb)
            .map(|item| process_batch_item(&typf, &config.defaults, item))
            .collect()
    } else {
        config.items
            .iter()
            .progress_with(pb)
            .map(|item| process_batch_item(&typf, &config.defaults, item))
            .collect()
    };

    // Report results
    let successful = results.iter().filter(|r| r.is_ok()).count();
    let failed = results.len() - successful;

    println!("\nBatch processing complete:");
    println!("  Successful: {}", successful);
    println!("  Failed: {}", failed);

    if failed > 0 && args.verbose {
        println!("\nErrors:");
        for (item, result) in config.items.iter().zip(results.iter()) {
            if let Err(e) = result {
                println!("  {}: {}", item.text, e);
            }
        }
    }

    Ok(())
}
```

## 7.2 Python Bindings with PyO3

### Core Bindings Module

```rust
// bindings/typf-py/src/lib.rs

use pyo3::prelude::*;
use pyo3::types::{PyBytes, PyDict, PyList};
use typf::prelude::*;

/// Python bindings for TYPF
#[pymodule]
fn typf_rs(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_class::<PyTypf>()?;
    m.add_class::<PyRenderOptions>()?;
    m.add_class::<PyShapingResult>()?;
    m.add_class::<PyFont>()?;
    m.add_function(wrap_pyfunction!(render_text, m)?)?;
    m.add_function(wrap_pyfunction!(shape_text, m)?)?;
    m.add_function(wrap_pyfunction!(list_system_fonts, m)?)?;
    m.add("__version__", env!("CARGO_PKG_VERSION"))?;
    Ok(())
}

/// Main TYPF class for Python
#[pyclass]
struct PyTypf {
    inner: Arc<Typf>,
}

#[pymethods]
impl PyTypf {
    #[new]
    #[pyo3(signature = (shaping_backend="auto", render_backend="auto", **kwargs))]
    fn new(
        shaping_backend: &str,
        render_backend: &str,
        kwargs: Option<&PyDict>,
    ) -> PyResult<Self> {
        let mut builder = Typf::builder();

        // Parse backends
        builder = builder
            .shaping_backend(parse_shaping_backend(shaping_backend)?)
            .render_backend(parse_render_backend(render_backend)?);

        // Parse additional options from kwargs
        if let Some(kwargs) = kwargs {
            if let Some(cache_size) = kwargs.get_item("cache_size") {
                let size: usize = cache_size.extract()?;
                builder = builder.cache_size(size);
            }
        }

        let typf = builder.build()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;

        Ok(Self {
            inner: Arc::new(typf),
        })
    }

    /// Render text to an image
    #[pyo3(signature = (text, **kwargs))]
    fn render(&self, text: &str, kwargs: Option<&PyDict>) -> PyResult<PyObject> {
        let options = parse_render_options(kwargs)?;

        let result = self.inner
            .render_with_options(text, options)
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;

        Python::with_gil(|py| {
            match result {
                RenderOutput::Bitmap(data) => {
                    Ok(PyBytes::new(py, data.as_bytes()).into())
                }
                RenderOutput::Vector(data) => {
                    Ok(PyString::new(py, data.as_str()).into())
                }
                RenderOutput::Json(data) => {
                    let json_str = data.as_str();
                    let json_module = py.import("json")?;
                    json_module.call_method1("loads", (json_str,))
                }
            }
        })
    }

    /// Shape text and return shaping information
    #[pyo3(signature = (text, **kwargs))]
    fn shape(&self, text: &str, kwargs: Option<&PyDict>) -> PyResult<PyShapingResult> {
        let options = parse_shaping_options(kwargs)?;

        let result = self.inner
            .shape_with_options(text, options)
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;

        Ok(PyShapingResult { inner: result })
    }

    /// Measure text dimensions
    #[pyo3(signature = (text, **kwargs))]
    fn measure(&self, text: &str, kwargs: Option<&PyDict>) -> PyResult<PyObject> {
        let options = parse_render_options(kwargs)?;

        let metrics = self.inner
            .measure(text, options)
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;

        Python::with_gil(|py| {
            let dict = PyDict::new(py);
            dict.set_item("width", metrics.width)?;
            dict.set_item("height", metrics.height)?;
            dict.set_item("advance", metrics.advance)?;
            dict.set_item("ascent", metrics.ascent)?;
            dict.set_item("descent", metrics.descent)?;
            Ok(dict.into())
        })
    }

    /// List available backends
    fn available_backends(&self) -> PyResult<PyObject> {
        Python::with_gil(|py| {
            let dict = PyDict::new(py);

            let shaping_backends: Vec<String> = FeatureDetector::available_shaping_backends()
                .into_iter()
                .map(|b| format!("{:?}", b))
                .collect();

            let render_backends: Vec<String> = FeatureDetector::available_render_backends()
                .into_iter()
                .map(|b| format!("{:?}", b))
                .collect();

            dict.set_item("shaping", shaping_backends)?;
            dict.set_item("render", render_backends)?;

            Ok(dict.into())
        })
    }
}

/// Shaping result wrapper
#[pyclass]
struct PyShapingResult {
    inner: ShapingResult,
}

#[pymethods]
impl PyShapingResult {
    #[getter]
    fn glyphs(&self) -> PyResult<Vec<PyObject>> {
        Python::with_gil(|py| {
            self.inner.glyphs
                .iter()
                .map(|g| {
                    let dict = PyDict::new(py);
                    dict.set_item("id", g.glyph_id)?;
                    dict.set_item("cluster", g.cluster)?;
                    dict.set_item("x", g.x_offset)?;
                    dict.set_item("y", g.y_offset)?;
                    dict.set_item("advance", g.x_advance)?;
                    Ok(dict.into())
                })
                .collect()
        })
    }

    #[getter]
    fn advance(&self) -> f32 {
        self.inner.advance_width
    }

    #[getter]
    fn bounds(&self) -> PyResult<PyObject> {
        Python::with_gil(|py| {
            let dict = PyDict::new(py);
            dict.set_item("x_min", self.inner.bounding_box.x_min)?;
            dict.set_item("y_min", self.inner.bounding_box.y_min)?;
            dict.set_item("x_max", self.inner.bounding_box.x_max)?;
            dict.set_item("y_max", self.inner.bounding_box.y_max)?;
            Ok(dict.into())
        })
    }

    fn to_json(&self) -> PyResult<String> {
        serde_json::to_string(&self.inner)
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }
}

/// Convenience functions
#[pyfunction]
#[pyo3(signature = (text, font, size=16.0, **kwargs))]
fn render_text(
    text: &str,
    font: &str,
    size: f32,
    kwargs: Option<&PyDict>,
) -> PyResult<PyObject> {
    let typf = Typf::new()
        .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;

    let mut options = RenderOptions::builder()
        .font(font)
        .size(size);

    // Parse additional options
    if let Some(kwargs) = kwargs {
        if let Some(color) = kwargs.get_item("color") {
            let color_str: String = color.extract()?;
            options = options.foreground(parse_color(&color_str)?);
        }
        if let Some(format) = kwargs.get_item("format") {
            let format_str: String = format.extract()?;
            options = options.format(parse_output_format(&format_str)?);
        }
    }

    let result = typf.render_with_options(text, options.build())
        .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;

    Python::with_gil(|py| {
        match result {
            RenderOutput::Bitmap(data) => Ok(PyBytes::new(py, data.as_bytes()).into()),
            RenderOutput::Vector(data) => Ok(PyString::new(py, data.as_str()).into()),
            RenderOutput::Json(data) => Ok(PyString::new(py, data.as_str()).into()),
        }
    })
}
```

### Python Package Structure

```python
# bindings/typf-py/python/typf/__init__.py

"""TYPF - High-performance text shaping and rendering for Python"""

from typing import Optional, Dict, List, Any, Union
from pathlib import Path
import numpy as np
from PIL import Image
import io

# Import Rust bindings
from .typf_rs import (
    PyTypf as _Typf,
    render_text as _render_text,
    shape_text as _shape_text,
    list_system_fonts as _list_system_fonts,
    __version__,
)

__all__ = [
    'Typf',
    'render_text',
    'shape_text',
    'render_to_image',
    'list_system_fonts',
    '__version__',
]


class Typf:
    """High-performance text shaping and rendering engine."""

    def __init__(
        self,
        shaping_backend: str = "auto",
        render_backend: str = "auto",
        cache_size: int = 1024,
    ):
        """Initialize TYPF engine.

        Args:
            shaping_backend: Shaping backend ('auto', 'hb', 'icu-hb', 'mac', 'win', 'none')
            render_backend: Render backend ('auto', 'orge', 'skia', 'zeno', 'mac', 'win')
            cache_size: Size of glyph cache
        """
        self._engine = _Typf(
            shaping_backend=shaping_backend,
            render_backend=render_backend,
            cache_size=cache_size,
        )

    def render(
        self,
        text: str,
        font: Union[str, Path],
        size: float = 16.0,
        color: str = "black",
        background: Optional[str] = None,
        format: str = "png",
        **kwargs
    ) -> bytes:
        """Render text to an image.

        Args:
            text: Text to render
            font: Font path or system font name
            size: Font size in points
            color: Foreground color (hex or name)
            background: Background color (hex or name, None for transparent)
            format: Output format ('png', 'svg', 'jpg', etc.)
            **kwargs: Additional rendering options

        Returns:
            Rendered image as bytes
        """
        return self._engine.render(
            text,
            font=str(font),
            size=size,
            color=color,
            background=background,
            format=format,
            **kwargs
        )

    def render_to_image(
        self,
        text: str,
        font: Union[str, Path],
        size: float = 16.0,
        **kwargs
    ) -> Image.Image:
        """Render text to a PIL Image.

        Args:
            text: Text to render
            font: Font path or system font name
            size: Font size in points
            **kwargs: Additional rendering options

        Returns:
            PIL Image object
        """
        png_data = self.render(text, font, size, format="png", **kwargs)
        return Image.open(io.BytesIO(png_data))

    def render_to_array(
        self,
        text: str,
        font: Union[str, Path],
        size: float = 16.0,
        **kwargs
    ) -> np.ndarray:
        """Render text to a numpy array.

        Args:
            text: Text to render
            font: Font path or system font name
            size: Font size in points
            **kwargs: Additional rendering options

        Returns:
            RGBA numpy array
        """
        img = self.render_to_image(text, font, size, **kwargs)
        return np.array(img)

    def shape(
        self,
        text: str,
        font: Union[str, Path],
        size: float = 16.0,
        language: Optional[str] = None,
        features: Optional[Dict[str, int]] = None,
        **kwargs
    ) -> Dict[str, Any]:
        """Shape text and return shaping information.

        Args:
            text: Text to shape
            font: Font path or system font name
            size: Font size in points
            language: Language tag (BCP 47)
            features: OpenType features
            **kwargs: Additional shaping options

        Returns:
            Shaping result dictionary
        """
        result = self._engine.shape(
            text,
            font=str(font),
            size=size,
            language=language,
            features=features,
            **kwargs
        )
        return {
            'glyphs': result.glyphs,
            'advance': result.advance,
            'bounds': result.bounds,
        }

    def measure(
        self,
        text: str,
        font: Union[str, Path],
        size: float = 16.0,
        **kwargs
    ) -> Dict[str, float]:
        """Measure text dimensions.

        Args:
            text: Text to measure
            font: Font path or system font name
            size: Font size in points
            **kwargs: Additional options

        Returns:
            Dictionary with width, height, advance, ascent, descent
        """
        return self._engine.measure(text, font=str(font), size=size, **kwargs)

    def available_backends(self) -> Dict[str, List[str]]:
        """Get list of available backends."""
        return self._engine.available_backends()


# Convenience functions
def render_text(
    text: str,
    font: Union[str, Path],
    size: float = 16.0,
    output: Optional[Union[str, Path]] = None,
    **kwargs
) -> Union[bytes, None]:
    """Quick function to render text.

    Args:
        text: Text to render
        font: Font path or system font name
        size: Font size in points
        output: Output file path (if None, returns bytes)
        **kwargs: Additional rendering options

    Returns:
        Rendered image bytes, or None if saved to file
    """
    data = _render_text(text, str(font), size, **kwargs)

    if output:
        Path(output).write_bytes(data)
        return None
    return data


def render_to_image(
    text: str,
    font: Union[str, Path],
    size: float = 16.0,
    **kwargs
) -> Image.Image:
    """Quick function to render text to PIL Image."""
    data = render_text(text, font, size, **kwargs)
    return Image.open(io.BytesIO(data))


def shape_text(
    text: str,
    font: Union[str, Path],
    size: float = 16.0,
    **kwargs
) -> Dict[str, Any]:
    """Quick function to shape text."""
    return _shape_text(text, str(font), size, **kwargs)


def list_system_fonts() -> List[str]:
    """List available system fonts."""
    return _list_system_fonts()
```

## 7.3 Python Fire CLI

### Fire-based CLI Application

```python
# bindings/typf-py/python/typf/cli.py

"""TYPF command-line interface using Fire."""

import fire
from pathlib import Path
from typing import Optional, List, Dict, Any
import json
import sys
from rich.console import Console
from rich.table import Table
from rich.progress import track
import typf

console = Console()


class TypfCLI:
    """TYPF - High-performance text shaping and rendering."""

    def __init__(
        self,
        shaping_backend: str = "auto",
        render_backend: str = "auto",
        verbose: bool = False,
    ):
        """Initialize TYPF CLI.

        Args:
            shaping_backend: Shaping backend to use
            render_backend: Rendering backend to use
            verbose: Enable verbose output
        """
        self.engine = typf.Typf(
            shaping_backend=shaping_backend,
            render_backend=render_backend,
        )
        self.verbose = verbose

    def render(
        self,
        text: str,
        output: str,
        font: str = "system",
        size: float = 16.0,
        color: str = "black",
        background: Optional[str] = None,
        format: Optional[str] = None,
        language: Optional[str] = None,
        features: Optional[str] = None,
        variations: Optional[str] = None,
        dpi: int = 96,
    ):
        """Render text to an image file.

        Args:
            text: Text to render (or @file to read from file)
            output: Output file path
            font: Font path or system name
            size: Font size in points
            color: Text color (hex or name)
            background: Background color (None for transparent)
            format: Output format (auto-detect from extension)
            language: Language tag (BCP 47)
            features: OpenType features (comma-separated)
            variations: Font variations (comma-separated key=value)
            dpi: DPI for rasterization
        """
        # Handle @file syntax
        if text.startswith('@'):
            text = Path(text[1:]).read_text()

        # Auto-detect format from extension
        if format is None:
            ext = Path(output).suffix.lower()[1:]
            format = ext if ext else 'png'

        # Parse features and variations
        if features:
            features = self._parse_features(features)
        if variations:
            variations = self._parse_variations(variations)

        if self.verbose:
            console.print(f"[green]Rendering text...[/green]")
            console.print(f"  Text: {text[:50]}..." if len(text) > 50 else f"  Text: {text}")
            console.print(f"  Font: {font}")
            console.print(f"  Size: {size}pt")
            console.print(f"  Format: {format}")

        # Render
        data = self.engine.render(
            text,
            font=font,
            size=size,
            color=color,
            background=background,
            format=format,
            language=language,
            features=features,
            variations=variations,
            dpi=dpi,
        )

        # Save output
        Path(output).write_bytes(data)

        if self.verbose:
            console.print(f"[green]✓[/green] Rendered to {output}")

    def shape(
        self,
        text: str,
        font: str = "system",
        size: float = 16.0,
        language: Optional[str] = None,
        features: Optional[str] = None,
        output: Optional[str] = None,
        json_output: bool = False,
    ):
        """Shape text and display or save shaping information.

        Args:
            text: Text to shape
            font: Font path or system name
            size: Font size in points
            language: Language tag (BCP 47)
            features: OpenType features (comma-separated)
            output: Output file for JSON (None for stdout)
            json_output: Output as JSON instead of table
        """
        if features:
            features = self._parse_features(features)

        result = self.engine.shape(
            text,
            font=font,
            size=size,
            language=language,
            features=features,
        )

        if json_output or output:
            json_str = json.dumps(result, indent=2)
            if output:
                Path(output).write_text(json_str)
                if self.verbose:
                    console.print(f"[green]✓[/green] Saved shaping to {output}")
            else:
                print(json_str)
        else:
            # Display as table
            table = Table(title="Shaping Result")
            table.add_column("Glyph ID", style="cyan")
            table.add_column("Cluster", style="magenta")
            table.add_column("X", style="green")
            table.add_column("Y", style="green")
            table.add_column("Advance", style="yellow")

            for glyph in result['glyphs']:
                table.add_row(
                    str(glyph['id']),
                    str(glyph['cluster']),
                    f"{glyph['x']:.2f}",
                    f"{glyph['y']:.2f}",
                    f"{glyph['advance']:.2f}",
                )

            console.print(table)
            console.print(f"Total advance: {result['advance']:.2f}")

    def batch(
        self,
        config_file: str,
        output_dir: Optional[str] = None,
        parallel: bool = False,
    ):
        """Process multiple texts from a configuration file.

        Args:
            config_file: JSON/YAML configuration file
            output_dir: Output directory (default: current)
            parallel: Process items in parallel
        """
        config_path = Path(config_file)
        if not config_path.exists():
            console.print(f"[red]Error: Config file not found: {config_file}[/red]")
            return

        # Load configuration
        if config_path.suffix in ['.json']:
            config = json.loads(config_path.read_text())
        elif config_path.suffix in ['.yaml', '.yml']:
            import yaml
            config = yaml.safe_load(config_path.read_text())
        else:
            console.print(f"[red]Error: Unsupported config format[/red]")
            return

        output_dir = Path(output_dir) if output_dir else Path.cwd()
        output_dir.mkdir(exist_ok=True)

        defaults = config.get('defaults', {})
        items = config.get('items', [])

        console.print(f"[green]Processing {len(items)} items...[/green]")

        # Process items
        for i, item in enumerate(track(items, description="Processing...")):
            text = item['text']
            output_name = item.get('output', f"output_{i:04d}.png")
            output_path = output_dir / output_name

            # Merge defaults with item-specific options
            options = {**defaults, **item.get('options', {})}

            try:
                data = self.engine.render(text, **options)
                output_path.write_bytes(data)
            except Exception as e:
                console.print(f"[red]Error processing item {i}: {e}[/red]")

        console.print(f"[green]✓[/green] Batch processing complete")

    def info(self):
        """Display information about available backends and features."""
        backends = self.engine.available_backends()

        console.print("[bold]TYPF Information[/bold]\n")
        console.print(f"Version: {typf.__version__}")
        console.print(f"\n[bold]Available Backends:[/bold]")
        console.print(f"  Shaping: {', '.join(backends['shaping'])}")
        console.print(f"  Render: {', '.join(backends['render'])}")

        console.print(f"\n[bold]System Fonts:[/bold]")
        fonts = typf.list_system_fonts()[:10]  # Show first 10
        for font in fonts:
            console.print(f"  • {font}")
        if len(typf.list_system_fonts()) > 10:
            console.print(f"  ... and {len(typf.list_system_fonts()) - 10} more")

    def fonts(self, pattern: Optional[str] = None):
        """List available system fonts.

        Args:
            pattern: Filter pattern (case-insensitive)
        """
        fonts = typf.list_system_fonts()

        if pattern:
            pattern = pattern.lower()
            fonts = [f for f in fonts if pattern in f.lower()]

        console.print(f"[bold]Found {len(fonts)} fonts:[/bold]\n")
        for font in fonts:
            console.print(f"  {font}")

    def measure(
        self,
        text: str,
        font: str = "system",
        size: float = 16.0,
    ):
        """Measure text dimensions.

        Args:
            text: Text to measure
            font: Font path or system name
            size: Font size in points
        """
        metrics = self.engine.measure(text, font=font, size=size)

        table = Table(title="Text Metrics")
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="yellow")

        for key, value in metrics.items():
            table.add_row(key.capitalize(), f"{value:.2f}")

        console.print(table)

    def _parse_features(self, features: str) -> Dict[str, int]:
        """Parse OpenType features from string."""
        result = {}
        for feature in features.split(','):
            if '=' in feature:
                key, value = feature.split('=', 1)
                result[key.strip()] = int(value.strip())
            else:
                result[feature.strip()] = 1
        return result

    def _parse_variations(self, variations: str) -> Dict[str, float]:
        """Parse font variations from string."""
        result = {}
        for var in variations.split(','):
            if '=' in var:
                key, value = var.split('=', 1)
                result[key.strip()] = float(value.strip())
        return result


def main():
    """Entry point for Fire CLI."""
    fire.Fire(TypfCLI)


if __name__ == "__main__":
    main()
```

## 7.4 Python Package Configuration

### Setup Configuration

```python
# bindings/typf-py/setup.py

from setuptools import setup, find_packages
from setuptools_rust import Binding, RustExtension

setup(
    name="typf",
    version="2.0.0",
    author="TYPF Contributors",
    description="High-performance text shaping and rendering for Python",
    long_description=open("README.md").read(),
    long_description_content_type="text/markdown",
    url="https://github.com/typf/typf",
    packages=find_packages(where="python"),
    package_dir={"": "python"},
    rust_extensions=[
        RustExtension(
            "typf.typf_rs",
            binding=Binding.PyO3,
            features=["python"],
            debug=False,
        )
    ],
    python_requires=">=3.8",
    install_requires=[
        "fire>=0.5.0",
        "rich>=13.0.0",
        "numpy>=1.20.0",
        "Pillow>=9.0.0",
    ],
    extras_require={
        "dev": [
            "pytest>=7.0.0",
            "black>=23.0.0",
            "mypy>=1.0.0",
            "ruff>=0.1.0",
        ],
        "yaml": ["PyYAML>=6.0.0"],
    },
    entry_points={
        "console_scripts": [
            "typf=typf.cli:main",
        ],
    },
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Programming Language :: Rust",
        "Topic :: Text Processing :: Fonts",
        "Topic :: Multimedia :: Graphics",
    ],
    zip_safe=False,
)
```

### Cargo Configuration for Python

```toml
# bindings/typf-py/Cargo.toml

[package]
name = "typf-py"
version = "2.0.0"
edition = "2021"

[lib]
name = "typf_rs"
crate-type = ["cdylib"]

[dependencies]
typf = { path = "../../typf", features = ["python-bindings"] }
pyo3 = { version = "0.21", features = ["extension-module", "abi3-py38"] }
numpy = "0.21"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[features]
default = ["auto-backend"]
auto-backend = ["typf/auto-backend"]
full = ["typf/full"]
minimal = ["typf/minimal"]

# Python-specific optimizations
python = ["pyo3/auto-initialize"]

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
strip = true
```

## 7.5 Cross-Platform Python Wheels

### Build Configuration

```yaml
# .github/workflows/python-wheels.yml

name: Python Wheels

on:
  push:
    tags:
      - 'v*'

jobs:
  build-wheels:
    name: Build wheels on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ['3.8', '3.9', '3.10', '3.11', '3.12']

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install maturin

      - name: Build wheels
        run: |
          cd bindings/typf-py
          maturin build --release --features full

      - name: Upload wheels
        uses: actions/upload-artifact@v4
        with:
          name: wheels-${{ matrix.os }}-${{ matrix.python-version }}
          path: target/wheels/*.whl

  build-sdist:
    name: Build source distribution
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build sdist
        run: |
          cd bindings/typf-py
          python setup.py sdist

      - name: Upload sdist
        uses: actions/upload-artifact@v4
        with:
          name: sdist
          path: dist/*.tar.gz

  publish:
    name: Publish to PyPI
    needs: [build-wheels, build-sdist]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - uses: actions/download-artifact@v4
        with:
          pattern: wheels-*
          merge-multiple: true
          path: dist/

      - uses: actions/download-artifact@v4
        with:
          name: sdist
          path: dist/

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}
```

## 7.6 Usage Examples

### Python Examples

```python
# examples/python/basic.py

import typf
from pathlib import Path

# Simple text rendering
typf.render_text(
    "Hello, World!",
    font="Arial",
    size=48,
    output="hello.png"
)

# Advanced rendering with TYPF class
engine = typf.Typf(shaping_backend="icu-hb", render_backend="skia")

# Render with custom options
result = engine.render(
    "مرحبا بالعالم",  # Arabic text
    font="NotoSansArabic-Regular.ttf",
    size=32,
    color="#FF6B6B",
    background="#F0F0F0",
    language="ar",
    features={"liga": 1, "kern": 1},
    format="svg"
)

Path("arabic.svg").write_bytes(result)

# Shape text and get glyph information
shaped = engine.shape(
    "Office",
    font="Calibri",
    size=16,
    features={"liga": 1}  # Enable ligatures
)

for glyph in shaped['glyphs']:
    print(f"Glyph {glyph['id']} at position ({glyph['x']}, {glyph['y']})")

# Batch processing
import json

config = {
    "defaults": {
        "font": "Helvetica",
        "size": 24,
        "format": "png"
    },
    "items": [
        {"text": "First line", "output": "line1.png"},
        {"text": "Second line", "output": "line2.png", "options": {"size": 32}},
        {"text": "Third line", "output": "line3.png", "options": {"color": "blue"}},
    ]
}

Path("batch.json").write_text(json.dumps(config))

# Use CLI from Python
import subprocess
subprocess.run(["typf", "batch", "batch.json", "--output-dir", "output"])
```

### CLI Examples

```bash
# Basic rendering
typf render "Hello, World!" output.png --font Arial --size 48

# Shape text and output JSON
typf shape "Office" --font Calibri --features liga,kern --json-output

# Batch processing from config
typf batch config.yaml --output-dir results --parallel

# List available fonts
typf fonts --pattern "Noto"

# Get system info
typf info

# Interactive mode
typf repl

# Render with all options
typf render "Complex Text" output.svg \
    --font "NotoSans-Regular.ttf" \
    --size 32 \
    --color "#333333" \
    --background "white" \
    --language "en-US" \
    --features "liga,kern,calt" \
    --variations "wght=700,wdth=125" \
    --shaping-backend icu-hb \
    --render-backend skia \
    --dpi 144

# Python Fire CLI
python -m typf render "Hello" output.png --size=48 --color=blue

# Measure text
python -m typf measure "Sample Text" --font="Times New Roman" --size=16
```

## Next Steps

With the CLI and Python bindings complete, Part 08 will detail the comprehensive testing and quality assurance strategy.