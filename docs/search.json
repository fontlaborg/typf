{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"01-introduction/","level":1,"title":"Introduction","text":"<p>Your text breaks. Arabic renders backwards, Hindi characters collide, Thai glyphs disappear.</p> <p>TypF fixes this.</p>","path":["Getting Started","Introduction"],"tags":["Introduction","Overview"]},{"location":"01-introduction/#what-typf-does","level":2,"title":"What TypF does","text":"<p>Takes broken text and makes it right. Processes Unicode strings through six stages:</p> <pre><code>Input → Unicode → Fonts → Shape → Render → Export\n</code></pre> <p>Mix and match backends: - Shapers: HarfBuzz, CoreText, DirectWrite, or None - Renderers: Skia, Orge, Zeno, CoreGraphics, or JSON - Exports: PNG, SVG, PNM, or structured data</p>","path":["Getting Started","Introduction"],"tags":["Introduction","Overview"]},{"location":"01-introduction/#why-you-need-it","level":2,"title":"Why you need it","text":"<p>HarfBuzz shapes text but can't render it. Skia renders everything but weighs 10MB. Platform APIs lock you to one OS.</p> <p>TypF gives you the right tool for the job. Use only what you need.</p>","path":["Getting Started","Introduction"],"tags":["Introduction","Overview"]},{"location":"01-introduction/#performance","level":2,"title":"Performance","text":"<ul> <li>&lt;1ms rendering for most text</li> <li>&gt;10 GB/s throughput with SIMD</li> <li>&lt;500KB minimal builds</li> <li>Zero-copy font loading</li> </ul>","path":["Getting Started","Introduction"],"tags":["Introduction","Overview"]},{"location":"01-introduction/#where-it-works","level":2,"title":"Where it works","text":"<ul> <li>Desktop apps: Text editors, design tools</li> <li>Servers: Generate images, process documents</li> <li>Embedded: Resource-constrained devices</li> <li>Web: Browser rendering via WebAssembly</li> </ul>","path":["Getting Started","Introduction"],"tags":["Introduction","Overview"]},{"location":"01-introduction/#next","level":2,"title":"Next","text":"<p>Quick Start - Get TypF running in 5 minutes</p>","path":["Getting Started","Introduction"],"tags":["Introduction","Overview"]},{"location":"02-quick-start/","level":1,"title":"Quick Start","text":"<p>Get TypF running in five minutes.</p>","path":["Getting Started","Quick Start"],"tags":["Quick Start","Installation","Getting Started"]},{"location":"02-quick-start/#install","level":2,"title":"Install","text":"<pre><code>git clone https://github.com/fontlaborg/typf.git\ncd typf\n./build.sh\n</code></pre> <p>That's it. The build script installs everything you need.</p>","path":["Getting Started","Quick Start"],"tags":["Quick Start","Installation","Getting Started"]},{"location":"02-quick-start/#your-first-render","level":2,"title":"Your First Render","text":"<p>Rust CLI: <pre><code>typf render \"Hello, 世界!\" -f /System/Library/Fonts/Arial.ttf -o hello.png\n</code></pre></p> <p>Python CLI: <pre><code>typfpy render \"Hello, 世界!\" -f /System/Library/Fonts/Arial.ttf -o hello.png\n</code></pre></p> <p>Python API: <pre><code>import typf\nresult = typf.render_text(\"Hello, 世界!\", \"/System/Library/Fonts/Arial.ttf\")\nresult.save(\"hello.png\")\n</code></pre></p>","path":["Getting Started","Quick Start"],"tags":["Quick Start","Installation","Getting Started"]},{"location":"02-quick-start/#choose-your-backends","level":2,"title":"Choose Your Backends","text":"<pre><code># See what's available\ntypf info\n\n# Use specific backends\ntypf render \"Sample\" -f font.ttf --shaper harfbuzz --renderer skia -o out.png\n</code></pre>","path":["Getting Started","Quick Start"],"tags":["Quick Start","Installation","Getting Started"]},{"location":"02-quick-start/#what-just-happened","level":2,"title":"What Just Happened","text":"<ol> <li>Input: Your text entered the pipeline</li> <li>Unicode: Script detection and bidi analysis</li> <li>Font: Font loaded and matched to your text</li> <li>Shaping: HarfBuzz positioned each glyph</li> <li>Rendering: Skia drew the pixels</li> <li>Export: PNG file written to disk</li> </ol>","path":["Getting Started","Quick Start"],"tags":["Quick Start","Installation","Getting Started"]},{"location":"02-quick-start/#next-steps","level":2,"title":"Next Steps","text":"<pre><code># Try the examples\npython examples/simple_render.py\ncargo run --example basic\n\n# Test everything works\n./typf-tester/typfme.py\n</code></pre> <p>Read Architecture Overview to understand how it works.</p>","path":["Getting Started","Quick Start"],"tags":["Quick Start","Installation","Getting Started"]},{"location":"03-architecture-overview/","level":1,"title":"Architecture Overview","text":"<p>TypF turns text into pixels through six stages.</p>","path":["Getting Started","Architecture Overview"],"tags":["Architecture","Design","Pipeline"]},{"location":"03-architecture-overview/#the-pipeline","level":2,"title":"The Pipeline","text":"<pre><code>graph LR\n    A[Text] --&gt; B[Unicode]\n    B --&gt; C[Font]\n    C --&gt; D[Shape]\n    D --&gt; E[Render]\n    E --&gt; F[Export]</code></pre> <p>Each stage does one job:</p> <ol> <li>Input: Parses your text and settings</li> <li>Unicode: Detects scripts, handles bidi, segments text</li> <li>Font: Finds and loads the right font for your text</li> <li>Shape: Positions characters as glyphs</li> <li>Render: Draws pixels from glyphs</li> <li>Export: Writes files in the format you need</li> </ol>","path":["Getting Started","Architecture Overview"],"tags":["Architecture","Design","Pipeline"]},{"location":"03-architecture-overview/#backends","level":2,"title":"Backends","text":"<p>TypF plugs different engines into each stage:</p> <p>Shaping Backends: - HarfBuzz (cross-platform) - CoreText (macOS) - DirectWrite (Windows) - ICU-HB (advanced scripts) - None (testing)</p> <p>Rendering Backends: - Skia (vectors) - CoreGraphics (macOS) - Direct2D (Windows) - Orge (pure Rust) - Zeno (GPU) - JSON (data export)</p> <p>All backends implement the same traits, so you can swap them without changing your code.</p>","path":["Getting Started","Architecture Overview"],"tags":["Architecture","Design","Pipeline"]},{"location":"03-architecture-overview/#memory-strategy","level":2,"title":"Memory Strategy","text":"<p>Fonts are memory-mapped and intentionally leaked to avoid copying. Glyphs cache in an LRU hierarchy. Arc handles sharing between threads safely.</p>","path":["Getting Started","Architecture Overview"],"tags":["Architecture","Design","Pipeline"]},{"location":"03-architecture-overview/#performance","level":2,"title":"Performance","text":"<p>SIMD accelerates pixel operations. Text chunks process in parallel. Cache coherence prevents redundant work.</p>","path":["Getting Started","Architecture Overview"],"tags":["Architecture","Design","Pipeline"]},{"location":"03-architecture-overview/#configuration","level":2,"title":"Configuration","text":"<p>Feature flags control what compiles. Runtime settings choose backends. You build only what you need.</p>","path":["Getting Started","Architecture Overview"],"tags":["Architecture","Design","Pipeline"]},{"location":"03-architecture-overview/#error-handling","level":2,"title":"Error Handling","text":"<p>Clear error types tell you exactly what failed. No silent fallbacks - if a backend isn't compiled, you get an explicit error message.</p>","path":["Getting Started","Architecture Overview"],"tags":["Architecture","Design","Pipeline"]},{"location":"03-architecture-overview/#testing","level":2,"title":"Testing","text":"<p>Unit tests verify components. Integration tests check the full pipeline. Property tests catch edge cases. Fuzz tests find crashes.</p>","path":["Getting Started","Architecture Overview"],"tags":["Architecture","Design","Pipeline"]},{"location":"03-architecture-overview/#why-this-works","level":2,"title":"Why This Works","text":"<p>Six stages separate concerns. Backends plug into a common interface. Rust's type system prevents invalid states. Cache hierarchy eliminates redundant work.</p> <p>Next: Six-Stage Pipeline dives deeper into each stage.</p>","path":["Getting Started","Architecture Overview"],"tags":["Architecture","Design","Pipeline"]},{"location":"04-installation/","level":1,"title":"Installation","text":"<p>Install TypF and start rendering text.</p>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#quick-install","level":2,"title":"Quick Install","text":"<pre><code># Clone and build everything\ngit clone https://github.com/fontlaborg/typf.git\ncd typf\n./build.sh\n\n# Or install components separately\ncargo install --path crates/typf-cli\ncd bindings/python &amp;&amp; pip install -e .\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#requirements","level":2,"title":"Requirements","text":"<ul> <li>OS: Windows 10+, macOS 10.15+, Ubuntu 20.04+</li> <li>CPU: x86_64 or ARM64</li> <li>RAM: 4GB minimum, 8GB recommended</li> <li>Rust: 1.70+</li> <li>Python: 3.12+</li> </ul>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#install-dependencies","level":2,"title":"Install Dependencies","text":"","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#linux-ubuntudebian","level":3,"title":"Linux (Ubuntu/Debian)","text":"<pre><code>sudo apt-get update\nsudo apt-get install -y \\\n    build-essential \\\n    pkg-config \\\n    libfontconfig1-dev \\\n    libharfbuzz-dev \\\n    libfreetype6-dev \\\n    libpng-dev\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#linux-fedoracentos","level":3,"title":"Linux (Fedora/CentOS)","text":"<pre><code>sudo dnf install -y \\\n    gcc \\\n    pkg-config \\\n    fontconfig-devel \\\n    harfbuzz-devel \\\n    freetype-devel \\\n    libpng-devel\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#macos","level":3,"title":"macOS","text":"<pre><code>xcode-select --install\nbrew install harfbuzz freetype fontconfig\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#windows","level":3,"title":"Windows","text":"<p>Install Visual Studio Build Tools, then use vcpkg:</p> <pre><code>git clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n.\\bootstrap-vcpkg.bat\n.\\vcpkg integrate install\n.\\vcpkg install harfbuzz[freetype]:x64-windows\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#installation-options","level":2,"title":"Installation Options","text":"","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#build-from-source","level":3,"title":"Build from Source","text":"<pre><code>git clone https://github.com/fontlaborg/typf.git\ncd typf\ncargo build --release --workspace\ncargo install --path crates/typf-cli\ncd bindings/python &amp;&amp; pip install -e .\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#cargo-only-cli","level":3,"title":"Cargo Only (CLI)","text":"<pre><code>cargo install typf-cli\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#python-only","level":3,"title":"Python Only","text":"<pre><code>pip install typfpy\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#pre-built-binaries","level":3,"title":"Pre-built Binaries","text":"<p>Download from GitHub releases.</p>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#feature-selection","level":2,"title":"Feature Selection","text":"<p>Build only what you need:</p> <pre><code># Minimal build\ncargo build --release --features minimal\n\n# Platform optimized (macOS)\ncargo build --release --features \"shaping-coretext,render-coregraphics\"\n\n# Full featured\ncargo build --release --all-features\n\n# Custom selection\ncargo build --release --features \"shaping-hb,render-skia,export-png,export-svg\"\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#configuration","level":2,"title":"Configuration","text":"<p>Set defaults via environment:</p> <pre><code>export TYPF_SHAPER=harfbuzz\nexport TYPF_RENDERER=skia\nexport TYPF_CACHE_DIR=$HOME/.typf/cache\n</code></pre> <p>Or create <code>~/.typf/config.toml</code>:</p> <pre><code>[default]\nshaper = \"harfbuzz\"\nrenderer = \"skia\"\nfont_size = 24.0\ncolor = \"#000000\"\ndpi = 72.0\n\n[cache]\nmax_fonts = 100\nmax_glyphs = 10000\ncache_dir = \"~/.typf/cache\"\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#verify-installation","level":2,"title":"Verify Installation","text":"<pre><code># Check CLI\ntypf-cli --version\ntypf-cli --help\ntypf-cli render --text \"Hello World\" --font /path/to/font.ttf\n\n# Check Python\npython -c \"import typfpy; print(typfpy.__version__)\"\n\n# Run tests\ncargo test --workspace\n./typf-tester/typfme.py render\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#platform-notes","level":2,"title":"Platform Notes","text":"","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#macos_1","level":3,"title":"macOS","text":"<pre><code># Enable native backends\ncargo build --features shaping-coretext,render-coregraphics\n\n# System fonts\ntypf-cli font-list | grep -i arial\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#windows_1","level":3,"title":"Windows","text":"<pre><code># Enable native backends\ncargo build --features shaping-directwrite,render-direct2d\n\n# Font paths (forward slashes work)\ntypf-cli render --text \"Hello\" --font \"C:/Windows/Fonts/arial.ttf\"\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#linux","level":3,"title":"Linux","text":"<pre><code># Rebuild font cache\nfc-cache -fv\nsudo apt-get install fonts-liberation fonts-dejavu-core fonts-noto\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#troubleshooting","level":2,"title":"Troubleshooting","text":"<p>Missing dependencies? Install the system packages listed above.</p> <p>Build fails? Update Rust and clean cache:</p> <pre><code>rustup update stable\ncargo clean\ncargo build --release\n</code></pre> <p>Font not found? Check permissions and path:</p> <pre><code>ls -la /path/to/font.ttf\ntypf-cli font-check --font /path/to/font.ttf\n</code></pre> <p>Backend missing? Rebuild with features:</p> <pre><code>cargo build --release --features shaping-hb,render-skia\n</code></pre>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"04-installation/#next-steps","level":2,"title":"Next Steps","text":"<ul> <li>Quick Start - Your first rendering</li> <li>Architecture - How it works</li> <li>Six-Stage Pipeline - Core concepts</li> </ul> <p>TypF is installed. Start rendering text.</p>","path":["Getting Started","Installation"],"tags":["Installation","Setup","Dependencies"]},{"location":"05-six-stage-pipeline/","level":1,"title":"The Six-Stage Pipeline","text":"<p>Text flows through six stages to become pixels.</p> <pre><code>Input → Unicode → Font → Shaping → Rendering → Export\n   ↓        ↓       ↓        ↓         ↓        ↓\nTextBuffer  ProcessedText  FontHandle  GlyphBuffer  RenderOutput  ExportResult\n</code></pre>","path":["Core Concepts","The Six-Stage Pipeline"],"tags":["Pipeline","Architecture","Data Flow"]},{"location":"05-six-stage-pipeline/#stage-1-input-parsing","level":2,"title":"Stage 1: Input Parsing","text":"<p>Raw text becomes structured data.</p> <pre><code>pub struct TextBuffer {\n    pub text: String,\n    pub language: Option&lt;Language&gt;,\n    pub script: Option&lt;Script&gt;,\n    pub direction: Direction,\n    pub metadata: HashMap&lt;String, String&gt;,\n}\n</code></pre> <p>The parser validates UTF-8, extracts metadata, and normalizes the input for the next stage.</p> <p>What it does: - Validates text encoding - Extracts language and script hints - Normalizes Unicode if requested - Creates the initial TextBuffer</p>","path":["Core Concepts","The Six-Stage Pipeline"],"tags":["Pipeline","Architecture","Data Flow"]},{"location":"05-six-stage-pipeline/#stage-2-unicode-processing","level":2,"title":"Stage 2: Unicode Processing","text":"<p>Text analysis for complex scripts.</p> <pre><code>pub struct ProcessedText {\n    pub original: String,\n    pub segments: Vec&lt;TextSegment&gt;,\n    pub base_direction: Direction,\n    pub unicode_version: UnicodeVersion,\n}\n</code></pre> <p>Identifies writing systems, handles bidirectional text, and breaks text into logical segments.</p> <p>What it does: - Detects scripts (Latin, Arabic, Devanagari) - Analyzes bidirectional text flow - Segments text for proper rendering - Applies Unicode normalization</p>","path":["Core Concepts","The Six-Stage Pipeline"],"tags":["Pipeline","Architecture","Data Flow"]},{"location":"05-six-stage-pipeline/#stage-3-font-selection","level":2,"title":"Stage 3: Font Selection","text":"<p>Matches text to fonts that can display it.</p> <pre><code>pub struct FontSelectionResult {\n    pub selections: Vec&lt;FontSelection&gt;,\n    pub fallbacks_used: bool,\n    pub unsupported_chars: Vec&lt;char&gt;,\n}\n</code></pre> <p>Finds fonts supporting required characters, handles fallbacks, and manages font matching.</p> <p>What it does: - Matches fonts to text segments - Selects fallback fonts for missing glyphs - Considers font style and weight - Tracks unsupported characters</p>","path":["Core Concepts","The Six-Stage Pipeline"],"tags":["Pipeline","Architecture","Data Flow"]},{"location":"05-six-stage-pipeline/#stage-4-shaping","level":2,"title":"Stage 4: Shaping","text":"<p>Characters become positioned glyphs.</p> <pre><code>pub struct ShapingResult {\n    pub glyphs: Vec&lt;Glyph&gt;,\n    pub advances: Vec&lt;f32&gt;,\n    pub positions: Vec&lt;Position&gt;,\n    pub clusters: Vec&lt;usize&gt;,\n    pub direction: Direction,\n    pub script: Script,\n}\n</code></pre> <p>Applies complex script rules, ligatures, kerning, and calculates glyph positions.</p> <p>What it does: - Substitutes glyphs (ligatures, contextual forms) - Positions glyphs with proper spacing - Handles complex script shaping - Calculates text metrics</p>","path":["Core Concepts","The Six-Stage Pipeline"],"tags":["Pipeline","Architecture","Data Flow"]},{"location":"05-six-stage-pipeline/#stage-5-rendering","level":2,"title":"Stage 5: Rendering","text":"<p>Glyphs become visual output.</p> <pre><code>pub struct RenderOutput {\n    pub data: RenderData,\n    pub width: u32,\n    pub height: u32,\n    pub format: PixelFormat,\n    pub dpi: f32,\n    pub transform: Transform,\n}\n</code></pre> <p>Rasterizes or vectorizes glyphs, applies colors and effects.</p> <p>What it does: - Converts glyphs to pixels or vectors - Applies colors and effects - Handles subpixel rendering - Transforms and positions final output</p>","path":["Core Concepts","The Six-Stage Pipeline"],"tags":["Pipeline","Architecture","Data Flow"]},{"location":"05-six-stage-pipeline/#stage-6-export","level":2,"title":"Stage 6: Export","text":"<p>Output becomes file formats.</p> <pre><code>pub struct ExportResult {\n    pub data: Vec&lt;u8&gt;,\n    pub format: ExportFormat,\n    pub metadata: ExportMetadata,\n    pub size: FileSize,\n}\n</code></pre> <p>Encodes to PNG, SVG, PDF, or other formats with compression and metadata.</p> <p>What it does: - Encodes to target formats - Applies compression - Embeds metadata - Validates output compliance</p>","path":["Core Concepts","The Six-Stage Pipeline"],"tags":["Pipeline","Architecture","Data Flow"]},{"location":"05-six-stage-pipeline/#pipeline-orchestration","level":2,"title":"Pipeline Orchestration","text":"<p>Connect all stages:</p> <pre><code>impl Pipeline {\n    pub fn process(&amp;self, input: &amp;str, options: &amp;ProcessOptions) -&gt; Result&lt;ExportResult&gt; {\n        // Stage 1: Parse input\n        let text_buffer = self.parser.parse(input, &amp;options.parse_options)?;\n\n        // Stage 2: Process Unicode\n        let processed_text = self.unicode_processor.process(&amp;text_buffer)?;\n\n        // Stage 3: Select fonts\n        let font_selection = self.font_selector.select_fonts(&amp;processed_text)?;\n\n        // Stage 4: Shape text\n        let shaping_results = self.shape_segments(&amp;processed_text, &amp;font_selection, &amp;options.shape_options)?;\n\n        // Stage 5: Render glyphs\n        let render_output = self.render_shaped(&amp;shaping_results, &amp;options.render_options)?;\n\n        // Stage 6: Export result\n        let export_result = self.exporter.export(&amp;render_output, &amp;options.export_options)?;\n\n        Ok(export_result)\n    }\n}\n</code></pre>","path":["Core Concepts","The Six-Stage Pipeline"],"tags":["Pipeline","Architecture","Data Flow"]},{"location":"05-six-stage-pipeline/#error-handling","level":2,"title":"Error Handling","text":"<p>Each stage reports specific failures:</p> <pre><code>pub enum PipelineError {\n    InputFailed { source: ParseError },\n    UnicodeFailed { source: UnicodeError },\n    FontSelectionFailed { source: FontError },\n    ShapingFailed { source: ShapingError },\n    RenderingFailed { source: RenderError },\n    ExportFailed { source: ExportError },\n}\n</code></pre>","path":["Core Concepts","The Six-Stage Pipeline"],"tags":["Pipeline","Architecture","Data Flow"]},{"location":"05-six-stage-pipeline/#performance-monitoring","level":2,"title":"Performance Monitoring","text":"<p>Track what matters:</p> <pre><code>pub struct PipelineMetrics {\n    pub stage_durations: HashMap&lt;String, Duration&gt;,\n    pub memory_usage: HashMap&lt;String, usize&gt;,\n    pub cache_hit_rates: HashMap&lt;String, f64&gt;,\n    pub total_duration: Duration,\n}\n</code></pre>","path":["Core Concepts","The Six-Stage Pipeline"],"tags":["Pipeline","Architecture","Data Flow"]},{"location":"05-six-stage-pipeline/#next-steps","level":2,"title":"Next Steps","text":"<ul> <li>Backend Architecture - How backends implement stages</li> <li>Memory Management - Efficient resource usage</li> <li>Performance - Optimization strategies</li> </ul> <p>Six stages transform text into pixels. Each stage handles one job well.</p>","path":["Core Concepts","The Six-Stage Pipeline"],"tags":["Pipeline","Architecture","Data Flow"]},{"location":"06-backend-architecture/","level":1,"title":"Backend Architecture","text":"<p>Backends implement the pipeline stages. Mix and match them for your needs.</p>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#core-traits","level":2,"title":"Core Traits","text":"<p>All backends implement these traits:</p> <pre><code>pub trait Shaper: Send + Sync {\n    fn shape(&amp;self, text: &amp;ProcessedText, font: &amp;FontHandle, options: &amp;ShapeOptions) -&gt; Result&lt;ShapingResult&gt;;\n    fn name(&amp;self) -&gt; &amp;str;\n    fn supports_script(&amp;self, script: Script) -&gt; bool;\n}\n\npub trait Renderer: Send + Sync {\n    fn render(&amp;self, glyphs: &amp;[Glyph], options: &amp;RenderOptions) -&gt; Result&lt;RenderOutput&gt;;\n    fn name(&amp;self) -&gt; &amp;str;\n    fn supports_format(&amp;self, format: PixelFormat) -&gt; bool;\n}\n\npub trait Exporter: Send + Sync {\n    fn export(&amp;self, output: &amp;RenderOutput, options: &amp;ExportOptions) -&gt; Result&lt;ExportResult&gt;;\n    fn name(&amp;self) -&gt; &amp;str;\n    fn supported_formats(&amp;self) -&gt; &amp;[ExportFormat];\n}\n</code></pre>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#shaping-backends","level":2,"title":"Shaping Backends","text":"","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#noneshaper","level":3,"title":"NoneShaper","text":"<p>The simplest shaper. No shaping, just character-to-glyph mapping.</p> <pre><code>pub struct NoneShaper;\nimpl Shaper for NoneShaper {\n    fn shape(&amp;self, text: &amp;ProcessedText, font: &amp;FontHandle, options: &amp;ShapeOptions) -&gt; Result&lt;ShapingResult&gt; {\n        // Map characters directly to glyph IDs\n        let glyphs: Vec&lt;Glyph&gt; = text.text.chars()\n            .map(|c| font.get_glyph(c, 0))\n            .collect();\n\n        Ok(ShapingResult {\n            glyphs,\n            advances: vec![font.units_per_em(); glyphs.len()],\n            positions: vec![Position::default(); glyphs.len()],\n            clusters: (0..text.text.len()).collect(),\n            direction: text.base_direction,\n            script: text.script.unwrap_or(Script::Latin),\n        })\n    }\n}\n</code></pre> <p>Use when: You need basic Latin text or are testing other components.</p> <p>Limitations: No ligatures, no complex script support, no kerning.</p>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#harfbuzz-shaper","level":3,"title":"HarfBuzz Shaper","text":"<p>Industry-standard text shaping.</p> <pre><code>pub struct HarfBuzzShaper {\n    font_cache: Arc&lt;HarfBuzzFontCache&gt;,\n    buffer_pool: Arc&lt;BufferPool&gt;,\n}\n\nimpl Shaper for HarfBuzzShaper {\n    fn shape(&amp;self, text: &amp;ProcessedText, font: &amp;FontHandle, options: &amp;ShapeOptions) -&gt; Result&lt;ShapingResult&gt; {\n        let mut buffer = self.buffer_pool.get();\n        buffer.set_text(&amp;text.text, text.script.unwrap_or(Script::Latin), text.base_direction);\n        buffer.set_font(font.harfbuzz_font());\n\n        // Apply features\n        for feature in &amp;options.features {\n            buffer.add_feature(feature.tag, feature.value, feature.start, feature.end);\n        }\n\n        buffer.shape();\n\n        Ok(self.convert_hb_result(&amp;buffer))\n    }\n}\n</code></pre> <p>Use when: You need proper shaping for any script.</p> <p>Features: Full Unicode support, ligatures, kerning, complex scripts.</p>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#coretext-shaper","level":3,"title":"CoreText Shaper","text":"<p>macOS native shaping engine.</p> <pre><code>#[cfg(target_os = \"macos\")]\npub struct CoreTextShaper;\nimpl Shaper for CoreTextShaper {\n    fn shape(&amp;self, text: &amp;ProcessedText, font: &amp;FontHandle, options: &amp;ShapeOptions) -&gt; Result&lt;ShapingResult&gt; {\n        let attributed_string = self.create_attributed_string(text, font, options);\n        let line = CTLineCreateWithAttributedString(attrib_string);\n        let runs = CTLineGetGlyphRuns(line);\n\n        self.extract_glyphs(runs)\n    }\n}\n</code></pre> <p>Use when: You're on macOS and want native performance.</p> <p>Features: Seamless macOS font integration, optimal performance.</p>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#rendering-backends","level":2,"title":"Rendering Backends","text":"","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#orge-renderer","level":3,"title":"Orge Renderer","text":"<p>Pure Rust rasterizer. No external dependencies.</p> <pre><code>pub struct OrgeRenderer {\n    rasterizer: OrgeRasterizer,\n    scan_converter: ScanConverter,\n}\n\nimpl Renderer for OrgeRenderer {\n    fn render(&amp;self, glyphs: &amp;[Glyph], options: &amp;RenderOptions) -&gt; Result&lt;RenderOutput&gt; {\n        // Convert glyphs to outlines\n        let outlines: Vec&lt;Outline&gt; = glyphs.iter()\n            .map(|g| self.glyph_to_outline(g))\n            .collect();\n\n        // Rasterize outlines to bitmap\n        let bitmap = self.rasterizer.rasterize(&amp;outlines, options)?;\n\n        Ok(RenderOutput {\n            data: RenderData::Bitmap(bitmap),\n            width: bitmap.width,\n            height: bitmap.height,\n            format: options.pixel_format,\n            dpi: options.dpi,\n            transform: options.transform,\n        })\n    }\n}\n</code></pre> <p>Use when: You need fast rasterization without dependencies.</p> <p>Features: Anti-aliasing, subpixel rendering, parallel processing.</p>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#skia-renderer","level":3,"title":"Skia Renderer","text":"<p>Cross-platform GPU-accelerated rendering.</p> <pre><code>pub struct SkiaRenderer {\n    surface: Surface,\n    canvas: Canvas,\n    paint: Paint,\n}\n\nimpl Renderer for SkiaRenderer {\n    fn render(&amp;self, glyphs: &amp;[Glyph], options: &amp;RenderOptions) -&gt; Result&lt;RenderOutput&gt; {\n        let mut canvas = self.canvas.clone();\n        canvas.clear(&amp;options.background_color);\n\n        for glyph in glyphs {\n            let positioned_glyph = self.position_glyph(glyph, &amp;options.transform);\n            canvas.draw_glyph(positioned_glyph, &amp;self.paint);\n        }\n\n        let image = canvas.surface().image_snapshot();\n        let data = image.encode_to_data(options.pixel_format)?;\n\n        Ok(RenderOutput {\n            data: RenderData::SkiaImage(data),\n            width: image.width(),\n            height: image.height(),\n            format: options.pixel_format,\n            dpi: options.dpi,\n            transform: options.transform,\n        })\n    }\n}\n</code></pre> <p>Use when: You need GPU acceleration or advanced effects.</p> <p>Features: GPU rendering, complex effects, cross-platform.</p>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#backend-registry","level":2,"title":"Backend Registry","text":"<p>Find and create backends by name:</p> <pre><code>pub struct BackendRegistry {\n    shapers: HashMap&lt;String, Box&lt;dyn Fn() -&gt; Box&lt;dyn Shaper&gt;&gt;&gt;,\n    renderers: HashMap&lt;String, Box&lt;dyn Fn() -&gt; Box&lt;dyn Renderer&gt;&gt;&gt;,\n    exporters: HashMap&lt;String, Box&lt;dyn Fn() -&gt; Box&lt;dyn Exporter&gt;&gt;&gt;,\n}\n\nimpl BackendRegistry {\n    pub fn register_shaper&lt;F&gt;(&amp;mut self, name: &amp;str, factory: F) \n    where F: Fn() -&gt; Box&lt;dyn Shaper&gt; + 'static {\n        self.shapers.insert(name.to_string(), Box::new(factory));\n    }\n\n    pub fn create_shaper(&amp;self, name: &amp;str) -&gt; Result&lt;Box&lt;dyn Shaper&gt;&gt; {\n        self.shapers.get(name)\n            .ok_or_else(|| BackendError::NotFound(name.to_string()))\n            .map(|factory| factory())\n    }\n}\n</code></pre>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#runtime-backend-selection","level":2,"title":"Runtime Backend Selection","text":"<p>Choose backends at runtime:</p> <pre><code>pub struct PipelineBuilder {\n    shaper_name: Option&lt;String&gt;,\n    renderer_name: Option&lt;String&gt;,\n    exporter_name: Option&lt;String&gt;,\n    registry: Arc&lt;BackendRegistry&gt;,\n}\n\nimpl PipelineBuilder {\n    pub fn with_shaper(mut self, name: &amp;str) -&gt; Result&lt;Self&gt; {\n        self.registry.create_shaper(name)?;\n        self.shaper_name = Some(name.to_string());\n        Ok(self)\n    }\n\n    pub fn build(self) -&gt; Result&lt;Pipeline&gt; {\n        let shaper = self.registry.create_shaper(self.shaper_name.unwrap_or(\"none\"))?;\n        let renderer = self.registry.create_renderer(self.renderer_name.unwrap_or(\"orge\"))?;\n        let exporter = self.registry.create_exporter(self.exporter_name.unwrap_or(\"pnm\"))?;\n\n        Ok(Pipeline::new(shaper, renderer, exporter))\n    }\n}\n</code></pre>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#platform-defaults","level":2,"title":"Platform Defaults","text":"<p>Automatic backend selection by platform:</p> <pre><code>#[cfg(target_os = \"macos\")]\nfn default_shaper() -&gt; &amp;'static str { \"mac\" }  // CoreText\n\n#[cfg(target_os = \"windows\")]\nfn default_shaper() -&gt; &amp;'static str { \"directwrite\" }\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\nfn default_shaper() -&gt; &amp;'static str { \"harfbuzz\" }\n\nfn default_renderer() -&gt; &amp;'static str {\n    if gpu_available() { \"skia\" } else { \"orge\" }\n}\n</code></pre>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#backend-combinations","level":2,"title":"Backend Combinations","text":"<p>Common combinations:</p> Use Case Shaper Renderer Exporter Performance Fastest data none json json 25K ops/sec Complex scripts harfbuzz zeno png 3K ops/sec macOS best mac mac png 4K ops/sec Pure Rust harfbuzz orge pnm 2K ops/sec Web rendering harfbuzz skia svg 3.5K ops/sec Mobile apps mac skia png 4K ops/sec","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#performance-characteristics","level":2,"title":"Performance Characteristics","text":"Backend Memory Speed Quality Platform NoneShaper Low 25K ops/sec Basic All HarfBuzz Medium 4K ops/sec High All ICU-HarfBuzz Medium 3.5K ops/sec High All CoreText (mac) Medium 4.5K ops/sec High macOS only Orge Low 2K ops/sec Medium All Skia High 3.5K ops/sec High All Zeno Medium 3K ops/sec High All CoreGraphics (mac) High 4K ops/sec High macOS only JSON Low 25K ops/sec Data only All","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#adding-new-backends","level":2,"title":"Adding New Backends","text":"<p>Implement the trait and register:</p> <pre><code>// 1. Implement the trait\npub struct MyCustomShaper;\nimpl Shaper for MyCustomShaper {\n    fn shape(&amp;self, text: &amp;ProcessedText, font: &amp;FontHandle, options: &amp;ShapeOptions) -&gt; Result&lt;ShapingResult&gt; {\n        // Your shaping logic\n    }\n}\n\n// 2. Register the backend\nregistry.register_shaper(\"my_custom\", || Box::new(MyCustomShaper));\n</code></pre>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#error-handling","level":2,"title":"Error Handling","text":"<p>Backend-specific errors:</p> <pre><code>#[derive(Debug, thiserror::Error)]\npub enum ShapingError {\n    #[error(\"Font not supported by backend: {backend}\")]\n    UnsupportedFont { backend: String },\n    #[error(\"Script not supported by backend: {backend}\")]\n    UnsupportedScript { backend: String },\n    #[error(\"Backend internal error: {message}\")]\n    InternalError { backend: String, message: String },\n}\n</code></pre>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"06-backend-architecture/#testing-backends","level":2,"title":"Testing Backends","text":"<p>Each backend includes tests:</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_basic_shaping() {\n        let shaper = HarfBuzzShaper::new();\n        let text = create_test_text(\"Hello\");\n        let font = load_test_font();\n\n        let result = shaper.shape(&amp;text, &amp;font, &amp;ShapeOptions::default());\n        assert!(result.is_ok());\n\n        let shaped = result.unwrap();\n        assert!(!shaped.glyphs.is_empty());\n    }\n}\n</code></pre> <p>Backends implement pipeline stages. Choose the right combination for your needs.</p>","path":["Core Concepts","Backend Architecture"],"tags":["Backends","Architecture","Implementation"]},{"location":"07-memory-management/","level":1,"title":"Memory Management","text":"<p>Fast text rendering needs smart memory use. Here's how TypF handles it.</p>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#font-data-strategy","level":2,"title":"Font Data Strategy","text":"<p>Fonts stay loaded once, shared everywhere.</p> <pre><code>pub struct Font {\n    pub data: &amp;'static [u8],           // Leaked memory, never freed\n    pub face: FontFace,                // Parsed font metadata\n    pub cache: GlyphCache,             // Pre-rendered glyphs\n}\n\nimpl FontDatabase {\n    pub fn load_font(&amp;self, path: &amp;Path) -&gt; Result&lt;Arc&lt;Font&gt;&gt; {\n        // Load font data once, leak it permanently\n        let data = std::fs::read(path)?;\n        let leaked = Box::leak(data.into_boxed_slice());\n        let face = FontFace::from_bytes(leaked)?;\n\n        Ok(Arc::new(Font {\n            data: leaked,\n            face,\n            cache: GlyphCache::new(),\n        }))\n    }\n}\n</code></pre> <p>Why leak memory? Fonts are read-only data used throughout the program. Loading once prevents duplicate parsing and improves performance.</p>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#glyph-caching","level":2,"title":"Glyph Caching","text":"<p>Rendered glyphs get cached to avoid重复的渲染。</p> <pre><code>pub struct GlyphCache {\n    bitmap_cache: LruCache&lt;GlyphKey, BitmapData&gt;,\n    outline_cache: LruCache&lt;GlyphKey, Outline&gt;,\n    metrics_cache: LruCache&lt;GlyphKey, GlyphMetrics&gt;,\n}\n\nimpl GlyphCache {\n    pub fn get_or_render&lt;F&gt;(&amp;mut self, key: GlyphKey, render_fn: F) -&gt; Result&lt;&amp;BitmapData&gt; \n    where F: FnOnce() -&gt; Result&lt;BitmapData&gt; {\n        if !self.bitmap_cache.contains(&amp;key) {\n            let bitmap = render_fn()?;\n            self.bitmap_cache.put(key, bitmap);\n        }\n\n        Ok(self.bitmap_cache.get(&amp;key).unwrap())\n    }\n}\n</code></pre> <p>Cache layers: 1. Bitmap cache - Final rendered pixels 2. Outline cache - Vector outlines for scaling 3. Metrics cache - Glyph measurements</p> <p>LRU eviction keeps memory usage bounded.</p>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#shaping-results","level":2,"title":"Shaping Results","text":"<p>Text shaping results get cached for reuse.</p> <pre><code>pub struct ShapingCache {\n    cache: Arc&lt;DashMap&lt;ShapingKey, ShapingResult&gt;&gt;,\n    max_entries: usize,\n}\n\n#[derive(Hash, Eq, PartialEq)]\nstruct ShapingKey {\n    text_hash: u64,\n    font_id: FontId,\n    options_hash: u64,\n}\n\nimpl ShapingCache {\n    pub fn get_or_shape&lt;F&gt;(&amp;self, key: ShapingKey, shape_fn: F) -&gt; Result&lt;ShapingResult&gt;\n    where F: FnOnce() -&gt; Result&lt;ShapingResult&gt; {\n        entry(self.cache.entry(key))\n            .or_try_insert_with(shape_fn)\n            .map(|entry| entry.clone())\n    }\n}\n</code></pre> <p>Thread-safe with DashMap for concurrent access.</p>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#render-output-pool","level":2,"title":"Render Output Pool","text":"<p>Reuse render buffers instead of allocating new ones.</p> <pre><code>pub struct RenderPool {\n    bitmaps: Vec&lt;BitmapData&gt;,\n    vectors: Vec&lt;VectorData&gt;,\n    max_size: usize,\n}\n\nimpl RenderPool {\n    pub fn get_bitmap(&amp;mut self, width: u32, height: u32) -&gt; BitmapData {\n        // Find existing buffer that fits\n        if let Some(pos) = self.bitmaps.iter().position(|b| b.width &gt;= width &amp;&amp; b.height &gt;= height) {\n            self.bitmaps.swap_remove(pos)\n        } else {\n            // Allocate new if none available\n            BitmapData::new(width, height)\n        }\n    }\n\n    pub fn return_bitmap(&amp;mut self, bitmap: BitmapData) {\n        if self.bitmaps.len() &lt; self.max_size {\n            self.bitmaps.push(bitmap);\n        }\n        // Otherwise drop it\n    }\n}\n</code></pre>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#memory-pools","level":2,"title":"Memory Pools","text":"<p>Pre-allocate common data structures.</p> <pre><code>pub struct MemoryPool {\n    glyph_buffer: Vec&lt;Glyph&gt;,\n    position_buffer: Vec&lt;Position&gt;,\n    segment_buffer: Vec&lt;TextSegment&gt;,\n}\n\nimpl MemoryPool {\n    pub fn with_capacity(capacity: usize) -&gt; Self {\n        Self {\n            glyph_buffer: Vec::with_capacity(capacity),\n            position_buffer: Vec::with_capacity(capacity),\n            segment_buffer: Vec::with_capacity(capacity / 10), // Estimate\n        }\n    }\n\n    pub fn borrow_buffers(&amp;mut self) -&gt; (&amp;mut Vec&lt;Glyph&gt;, &amp;mut Vec&lt;Position&gt;) {\n        self.glyph_buffer.clear();\n        self.position_buffer.clear();\n        (&amp;mut self.glyph_buffer, &amp;mut self.position_buffer)\n    }\n}\n</code></pre>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#concurrent-access","level":2,"title":"Concurrent Access","text":"<p>Share data safely across threads.</p> <pre><code>pub struct SharedResources {\n    fonts: Arc&lt;DashMap&lt;FontId, Arc&lt;Font&gt;&gt;&gt;,\n    glyph_cache: Arc&lt;RwLock&lt;GlyphCache&gt;&gt;,\n    shaping_cache: Arc&lt;ShapingCache&gt;,\n    render_pool: Arc&lt;Mutex&lt;RenderPool&gt;&gt;,\n}\n\nimpl SharedResources {\n    pub fn new() -&gt; Self {\n        Self {\n            fonts: Arc::new(DashMap::new()),\n            glyph_cache: Arc::new(RwLock::new(GlyphCache::new(1000))),\n            shaping_cache: Arc::new(ShapingCache::new(500)),\n            render_pool: Arc::new(Mutex::new(RenderPool::new())),\n        }\n    }\n}\n</code></pre> <p>Different synchronization for different use cases: - DashMap - Lock-free concurrent hash map - RwLock - Multiple readers, exclusive writer - Mutex - Exclusive access for complex operations</p>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#memory-usage-tracking","level":2,"title":"Memory Usage Tracking","text":"<p>Monitor what's using memory.</p> <pre><code>pub struct MemoryTracker {\n    font_usage: AtomicUsize,\n    cache_usage: AtomicUsize,\n    pool_usage: AtomicUsize,\n    peak_usage: AtomicUsize,\n}\n\nimpl MemoryTracker {\n    pub fn allocate(&amp;self, size: usize) {\n        self.font_usage.fetch_add(size, Ordering::Relaxed);\n        self.update_peak();\n    }\n\n    pub fn cache_add(&amp;self, size: usize) {\n        self.cache_usage.fetch_add(size, Ordering::Relaxed);\n        self.update_peak();\n    }\n\n    fn update_peak(&amp;self) {\n        let current = self.font_usage.load(Ordering::Relaxed) + \n                     self.cache_usage.load(Ordering::Relaxed) +\n                     self.pool_usage.load(Ordering::Relaxed);\n\n        let mut peak = self.peak_usage.load(Ordering::Relaxed);\n        while current &gt; peak {\n            match self.peak_usage.compare_exchange_weak(\n                peak, current, Ordering::Relaxed, Ordering::Relaxed\n            ) {\n                Ok(_) =&gt; break,\n                Err(actual) =&gt; peak = actual,\n            }\n        }\n    }\n}\n</code></pre>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#cleanup-strategies","level":2,"title":"Cleanup Strategies","text":"<p>Control memory growth.</p>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#cache-size-limits","level":3,"title":"Cache Size Limits","text":"<pre><code>impl GlyphCache {\n    pub fn enforce_limits(&amp;mut self) {\n        while self.bitmap_cache.len() &gt; MAX_BITMAP_CACHE {\n            self.bitmap_cache.pop_lru();\n        }\n\n        while self.outline_cache.len() &gt; MAX_OUTLINE_CACHE {\n            self.outline_cache.pop_lru();\n        }\n    }\n}\n</code></pre>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#periodic-cleanup","level":3,"title":"Periodic Cleanup","text":"<pre><code>pub struct CacheJanitor {\n    cleanup_interval: Duration,\n    max_age: Duration,\n}\n\nimpl CacheJanitor {\n    pub fn start(&amp;self, caches: Vec&lt;Arc&lt;dyn Cacheable&gt;&gt;) {\n        for cache in caches {\n            let interval = self.cleanup_interval;\n            let max_age = self.max_age;\n\n            thread::spawn(move || {\n                loop {\n                    thread::sleep(interval);\n                    cache.cleanup_old_entries(max_age);\n                }\n            });\n        }\n    }\n}\n</code></pre>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#memory-profiling","level":2,"title":"Memory Profiling","text":"<p>Find memory bottlenecks.</p> <pre><code>#[cfg(debug_assertions)]\npub struct MemoryProfiler {\n    allocations: HashMap&lt;String, usize&gt;,\n    allocations_by_type: HashMap&lt;std::any::TypeId, usize&gt;,\n}\n\nimpl MemoryProfiler {\n    pub fn track_allocation&lt;T&gt;(&amp;mut self, size: usize) {\n        let type_name = std::any::type_name::&lt;T&gt;();\n        *self.allocations.entry(type_name.to_string()).or_insert(0) += size;\n\n        let type_id = std::any::TypeId::of::&lt;T&gt;();\n        *self.allocations_by_type.entry(type_id).or_insert(0) += size;\n    }\n\n    pub fn report(&amp;self) -&gt; String {\n        let mut report = String::new();\n        for (name, size) in &amp;self.allocations {\n            report.push_str(&amp;format!(\"{}: {} bytes\\n\", name, size));\n        }\n        report\n    }\n}\n</code></pre>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#platform-specific-optimizations","level":2,"title":"Platform-Specific Optimizations","text":"","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#macos","level":3,"title":"macOS","text":"<pre><code>#[cfg(target_os = \"macos\")]\npub fn allocate_font_data(path: &amp;Path) -&gt; Result&lt;&amp;'static [u8]&gt; {\n    use std::os::macos::fs::MetadataExt;\n\n    let file = std::fs::File::open(path)?;\n    let metadata = file.metadata()?;\n    let size = metadata.st_size() as usize;\n\n    let fd = file.as_raw_fd();\n    let ptr = unsafe {\n        libc::mmap(\n            std::ptr::null_mut(),\n            size,\n            libc::PROT_READ,\n            libc::MAP_PRIVATE,\n            fd,\n            0,\n        )\n    };\n\n    if ptr == libc::MAP_FAILED {\n        return Err(MemoryError::MapFailed);\n    }\n\n    Ok(unsafe { std::slice::from_raw_parts(ptr as *const u8, size) })\n}\n</code></pre>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#linuxwindows","level":3,"title":"Linux/Windows","text":"<pre><code>#[cfg(any(target_os = \"linux\", target_os = \"windows\"))]\npub fn allocate_font_data(path: &amp;Path) -&gt; Result&lt;&amp;'static [u8]&gt; {\n    let data = std::fs::read(path)?;\n    Ok(Box::leak(data.into_boxed_slice()))\n}\n</code></pre>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#best-practices","level":2,"title":"Best Practices","text":"<ol> <li>Load once, share everywhere - Font data is immutable</li> <li>Cache aggressively, evict intelligently - LRU for most things</li> <li>Reuse buffers - Object pools for temporary data</li> <li>Track usage - Know where memory goes</li> <li>Clean up periodically - Don't let caches grow forever</li> <li>Profile in debug - Find memory leaks early</li> </ol>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#common-pitfalls","level":2,"title":"Common Pitfalls","text":"","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#dont-clone-font-data","level":3,"title":"Don't clone font data","text":"<pre><code>// BAD - Duplicates font data\nlet font_data = std::fs::read(\"font.ttf\")?;\nlet font1 = Font::from_data(font_data.clone())?;\nlet font2 = Font::from_data(font_data)?;\n\n// GOOD - Shared reference\nlet font_data = load_font_data(\"font.ttf\")?; // &amp;'static [u8]\nlet font1 = Font::from_data(font_data)?;\nlet font2 = Font::from_data(font_data)?;\n</code></pre>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"07-memory-management/#dont-over-cache","level":3,"title":"Don't over-cache","text":"<pre><code>// BAD - Caching everything\ncache.put(image_1000x1000); // Uses 4MB\ncache.put(image_2000x2000); // Uses 16MB\ncache.put(image_4000x4000); // Uses 64MB\n\n// GOOD - Size limits and intelligent eviction\nif cache.total_size() &lt; MAX_CACHE_SIZE {\n    cache.put(image);\n} else {\n    cache.evict_lru();\n    cache.put(image);\n}\n</code></pre> <p>Smart memory management makes text rendering fast. Load once, cache wisely, clean up regularly.</p>","path":["Core Concepts","Memory Management"],"tags":["Memory","Performance","Optimization"]},{"location":"08-performance-fundamentals/","level":1,"title":"Performance Fundamentals","text":"<p>Fast text rendering requires smart optimization. Here are the core principles.</p>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#measuring-what-matters","level":2,"title":"Measuring What Matters","text":"<p>Track the metrics that impact users.</p> <pre><code>pub struct PerformanceMetrics {\n    pub shaping_time: Duration,\n    pub rendering_time: Duration,\n    pub export_time: Duration,\n    pub total_time: Duration,\n    pub memory_usage: usize,\n    pub cache_hit_rate: f64,\n}\n\nimpl PerformanceMetrics {\n    pub fn start_measurement() -&gt; Self {\n        Self {\n            shaping_time: Duration::ZERO,\n            rendering_time: Duration::ZERO,\n            export_time: Duration::ZERO,\n            total_time: Instant::now().elapsed(),\n            memory_usage: get_memory_usage(),\n            cache_hit_rate: 0.0,\n        }\n    }\n}\n</code></pre> <p>Focus on: - Latency - Time from text to pixels - Throughput - Characters per second - Memory - Peak and average usage - Cache efficiency - Hit rates across all caches</p>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#shaping-optimization","level":2,"title":"Shaping Optimization","text":"<p>Text shaping often dominates performance.</p>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#cache-shaping-results","level":3,"title":"Cache Shaping Results","text":"<pre><code>pub struct ShapingOptimizer {\n    cache: Arc&lt;DashMap&lt;ShapingKey, ShapingResult&gt;&gt;,\n    segment_cache: LruCache&lt;TextSegment, ShapedSegment&gt;,\n}\n\nimpl ShapingOptimizer {\n    pub fn shape_optimized(&amp;mut self, text: &amp;ProcessedText, font: &amp;Font, options: &amp;ShapeOptions) -&gt; Result&lt;ShapingResult&gt; {\n        // Check cache first\n        let cache_key = ShapingKey::new(text, font.id, options);\n\n        if let Some(cached) = self.cache.get(&amp;cache_key) {\n            return Ok(cached.clone());\n        }\n\n        // Split into cacheable segments\n        let segments = self.split_cacheable_segments(text);\n        let mut results = Vec::new();\n\n        for segment in segments {\n            if let Some(cached) = self.segment_cache.get(&amp;segment) {\n                results.push(cached.clone());\n            } else {\n                let shaped = self.shape_segment(&amp;segment, font, options)?;\n                self.segment_cache.put(segment.clone(), shaped.clone());\n                results.push(shaped);\n            }\n        }\n\n        let final_result = self.merge_results(results);\n        self.cache.insert(cache_key, final_result.clone());\n\n        Ok(final_result)\n    }\n}\n</code></pre>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#incremental-shaping","level":3,"title":"Incremental Shaping","text":"<pre><code>impl ShapingOptimizer {\n    pub fn shape_incremental(&amp;mut self, text: &amp;ProcessedText, previous: Option&lt;&amp;ShapingResult&gt;) -&gt; Result&lt;ShapingResult&gt; {\n        match previous {\n            Some(prev) if self.can_reuse(text, prev) =&gt; {\n                // Only.reshape the changed portion\n                let changed_range = self.find_changed_range(text, prev);\n                let reshaped = self.shape_range(text, changed_range)?;\n                Ok(self.merge_with_previous(prev, reshaped, changed_range))\n            }\n            _ =&gt; {\n                // Full reshape when we can't reuse\n                self.shape_optimized(text, font, options)\n            }\n        }\n    }\n}\n</code></pre>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#rendering-optimization","level":2,"title":"Rendering Optimization","text":"<p>Rasterization is the next bottleneck.</p>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#simd-acceleration","level":3,"title":"SIMD Acceleration","text":"<pre><code>#[cfg(target_arch = \"x86_64\")]\npub struct SimdRenderer {\n    rasterizer: OrgeRasterizer,\n    // SSE4.1, AVX2 support\n}\n\nimpl SimdRenderer {\n    pub fn render_scanline_simd(&amp;self, pixels: &amp;mut [u8], coverage: &amp;[f32]) {\n        if is_x86_feature_detected!(\"avx2\") {\n            self.render_scanline_avx2(pixels, coverage);\n        } else if is_x86_feature_detected!(\"sse4.1\") {\n            self.render_scanline_sse41(pixels, coverage);\n        } else {\n            self.render_scanline_scalar(pixels, coverage);\n        }\n    }\n\n    #[target_feature(enable = \"avx2\")]\n    unsafe fn render_scanline_avx2(&amp;self, pixels: &amp;mut [u8], coverage: &amp;[f32]) {\n        // Process 8 pixels at once\n        for (chunk, cov_chunk) in pixels.chunks_exact_mut(8).zip(coverage.chunks_exact(8)) {\n            let coverage_vec = _mm256_load_ps(cov_chunk.as_ptr());\n            let pixels_vec = _mm256_loadu_ps(pixels.as_ptr() as *const f32);\n            let result = _mm256_add_ps(pixels_vec, coverage_vec);\n            _mm256_storeu_ps(pixels.as_mut_ptr() as *mut f32, result);\n        }\n    }\n}\n</code></pre>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#parallel-rendering","level":3,"title":"Parallel Rendering","text":"<pre><code>pub struct ParallelRenderer {\n    thread_pool: ThreadPool,\n    max_threads: usize,\n}\n\nimpl ParallelRenderer {\n    pub fn render_parallel(&amp;self, glyphs: &amp;[Glyph], options: &amp;RenderOptions) -&gt; Result&lt;RenderOutput&gt; {\n        let chunks = self.split_into_chunks(glyphs);\n        let mut handles = Vec::new();\n\n        for chunk in chunks {\n            let handle = self.thread_pool.spawn(move || {\n                self.render_chunk(chunk, options)\n            });\n            handles.push(handle);\n        }\n\n        let results: Result&lt;Vec&lt;_&gt;&gt; = handles.into_iter()\n            .map(|h| h.join().unwrap())\n            .collect();\n\n        self.merge_render_results(results?)\n    }\n\n    fn split_into_chunks(&amp;self, glyphs: &amp;[Glyph]) -&gt; Vec&lt;&amp;[Glyph]&gt; {\n        let chunk_size = (glyphs.len() + self.max_threads - 1) / self.max_threads;\n        glyphs.chunks(chunk_size).collect()\n    }\n}\n</code></pre>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#memory-optimization","level":2,"title":"Memory Optimization","text":"<p>Memory access patterns matter more than allocation.</p>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#cache-friendly-data-layout","level":3,"title":"Cache-Friendly Data Layout","text":"<pre><code>// BAD - Random memory access\npub struct GlyphDataBad {\n    glyph_ids: Vec&lt;GlyphId&gt;,\n    positions: Vec&lt;Position&gt;,\n    advances: Vec&lt;f32&gt;,\n}\n\n// GOOD - Contiguous memory access\npub struct GlyphDataGood {\n    glyphs: Vec&lt;GlyphInfo&gt;, // All data for one glyph together\n}\n\n#[repr(C)]\npub struct GlyphInfo {\n    id: GlyphId,\n    x: f32,\n    y: f32,\n    advance: f32,\n}\n\nimpl GlyphDataGood {\n    pub fn render(&amp;self, renderer: &amp;mut Renderer) {\n        // Sequential memory access\n        for glyph in &amp;self.glyphs {\n            renderer.render_glyph(glyph);\n        }\n    }\n}\n</code></pre>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#memory-pooling","level":3,"title":"Memory Pooling","text":"<pre><code>pub struct MemoryPool {\n    bitmap_pool: Vec&lt;BitmapData&gt;,\n    vector_pool: Vec&lt;VectorData&gt;,\n    temp_buffer: Vec&lt;u8&gt;,\n}\n\nimpl MemoryPool {\n    pub fn get_bitmap(&amp;mut self, width: u32, height: u32) -&gt; BitmapData {\n        self.bitmap_pool.pop()\n            .filter(|b| b.width &gt;= width &amp;&amp; b.height &gt;= height)\n            .unwrap_or_else(|| BitmapData::new(width, height))\n    }\n\n    pub fn return_bitmap(&amp;mut self, bitmap: BitmapData) {\n        if self.bitmap_pool.len() &lt; 50 { // Limit pool size\n            bitmap.clear(); // Reset to zero state\n            self.bitmap_pool.push(bitmap);\n        }\n    }\n}\n</code></pre>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#backend-performance","level":2,"title":"Backend Performance","text":"<p>Different backends have different performance characteristics.</p>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#harfbuzz-optimization","level":3,"title":"HarfBuzz Optimization","text":"<pre><code>pub struct OptimizedHarfBuzz {\n    font_cache: HashMap&lt;FontId, HarfBuzzFont&gt;,\n    buffer_pool: Vec&lt;harfbuzz_rs::Buffer&gt;,\n}\n\nimpl OptimizedHarfBuzz {\n    pub fn shape_with_pool(&amp;mut self, text: &amp;str, font: &amp;Font, options: &amp;ShapeOptions) -&gt; Result&lt;ShapingResult&gt; {\n        // Reuse buffers to avoid allocation\n        let mut buffer = self.buffer_pool.pop()\n            .unwrap_or_else(|| harfbuzz_rs::Buffer::new());\n\n        buffer.set_text(text, script, direction);\n\n        // Apply features efficiently\n        buffer.guess_segment_properties();\n\n        // Shape\n        buffer.shape(font.harfbuzz_font(), &amp;features);\n\n        let result = self.extract_result(&amp;buffer);\n\n        // Return buffer to pool\n        buffer.clear();\n        self.buffer_pool.push(buffer);\n\n        Ok(result)\n    }\n}\n</code></pre>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#skia-optimization","level":3,"title":"Skia Optimization","text":"<pre><code>pub struct OptimizedSkia {\n    surface: Surface,\n    canvas: Canvas,\n    paint_pool: Vec&lt;Paint&gt;,\n}\n\nimpl OptimizedSkia {\n    pub fn render_batch(&amp;mut self, glyphs: &amp;[Glyph]) -&gt; Result&lt;RenderOutput&gt; {\n        let mut paint = self.paint_pool.pop()\n            .unwrap_or_else(|| Paint::default());\n\n        // Batch render glyphs with same properties\n        let mut current_run = Vec::new();\n\n        for glyph in glyphs {\n            if current_run.len() == 0 || self.can_batch_with(&amp;current_run[0], glyph) {\n                current_run.push(glyph);\n            } else {\n                self.render_run(&amp;current_run, &amp;mut paint);\n                current_run.clear();\n                current_run.push(glyph);\n            }\n        }\n\n        if !current_run.is_empty() {\n            self.render_run(&amp;current_run, &amp;mut paint);\n        }\n\n        // Return paint to pool\n        self.paint_pool.push(paint);\n\n        Ok(self.capture_surface())\n    }\n}\n</code></pre>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#performance-profiling","level":2,"title":"Performance Profiling","text":"<p>Find bottlenecks before optimizing.</p> <pre><code>#[cfg(debug_assertions)]\npub struct Profiler {\n    timings: HashMap&lt;String, Vec&lt;Duration&gt;&gt;,\n    counters: HashMap&lt;String, usize&gt;,\n}\n\nimpl Profiler {\n    pub fn time_section&lt;F, R&gt;(&amp;mut self, name: &amp;str, f: F) -&gt; R \n    where F: FnOnce() -&gt; R {\n        let start = Instant::now();\n        let result = f();\n        let duration = start.elapsed();\n\n        self.timings.entry(name.to_string())\n            .or_insert_with(Vec::new)\n            .push(duration);\n\n        result\n    }\n\n    pub fn report(&amp;self) -&gt; String {\n        let mut report = String::new();\n\n        for (name, timings) in &amp;self.timings {\n            let avg = timings.iter().sum::&lt;Duration&gt;() / timings.len() as u32;\n            let max = timings.iter().max().unwrap();\n            let min = timings.iter().min().unwrap();\n\n            report.push_str(&amp;format!(\n                \"{}: avg={:?}, min={:?}, max={:?}, count={}\\n\",\n                name, avg, min, max, timings.len()\n            ));\n        }\n\n        report\n    }\n}\n</code></pre>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#performance-targets","level":2,"title":"Performance Targets","text":"<p>Know what \"fast\" means for your use case.</p> Use Case Target Reason UI text &lt;1ms User interaction latency Document rendering &lt;100ms per page Acceptable wait time Batch processing &gt;1000 chars/sec Throughput focus Embedded systems &lt;10MB memory Memory constraints","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#common-performance-pitfalls","level":2,"title":"Common Performance Pitfalls","text":"","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#dont-optimize-too-early","level":3,"title":"Don't Optimize Too Early","text":"<pre><code>// BAD - Premature optimization\npub fn render_glyph_cached(glyph: Glyph) {\n    // Complex caching for rarely used function\n    if !self.cache.contains(&amp;glyph) {\n        let result = expensive_render(glyph);\n        self.cache.insert(glyph, result);\n    }\n}\n\n// GOOD - Profile first\npub fn render_glyph_simple(glyph: Glyph) {\n    // Simple, clear implementation\n    expensive_render(glyph)\n}\n</code></pre>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#dont-over-parallelize","level":3,"title":"Don't Over-Parallelize","text":"<pre><code>// BAD - Too much overhead\nlet results: Vec&lt;_&gt; = glyphs.iter()\n    .map(|g| thread::spawn(|| render_one(g))) // One thread per glyph!\n    .collect();\n\n// GOOD - Reasonable chunking\nlet chunks = glyphs.chunks(100).collect::&lt;Vec&lt;_&gt;&gt;();\nlet results: Vec&lt;_&gt; = chunks.iter()\n    .map(|chunk| thread::spawn(|| render_batch(chunk)))\n    .collect();\n</code></pre>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#dont-cache-everything","level":3,"title":"Don't Cache Everything","text":"<pre><code>// BAD - Infinite cache growth\ncache.put(very_large_image);\ncache.put(another_large_image);\n\n// GOOD - Size limits\nif cache.size() &lt; MAX_CACHE_SIZE {\n    cache.put(image);\n} else {\n    cache.evict_lru();\n    cache.put(image);\n}\n</code></pre>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"08-performance-fundamentals/#performance-checklist","level":2,"title":"Performance Checklist","text":"<p>Before shipping performance-critical code:</p> <ul> <li> Profile with realistic data</li> <li> Measure before and after optimization</li> <li> Check memory usage trends</li> <li> Test on target hardware</li> <li> Verify cache hit rates</li> <li> Benchmark edge cases</li> <li> Monitor for regressions</li> </ul> <p>Fast text rendering comes from smart caching, parallel processing, and memory-efficient data structures. Profile first, optimize second.</p>","path":["Core Concepts","Performance Fundamentals"],"tags":["Performance","Optimization","Speed"]},{"location":"09-harfbuzz-shaping/","level":1,"title":"HarfBuzz Shaping","text":"<p>HarfBuzz shapes text. TypF uses it for complex scripts, bidirectional text, and OpenType features.</p>","path":["Shaping Backends","HarfBuzz Shaping"],"tags":["HarfBuzz","Shaping","Unicode","OpenType"]},{"location":"09-harfbuzz-shaping/#why-harfbuzz","level":2,"title":"Why HarfBuzz?","text":"Feature What it means for you Unicode Compliance Handles the latest text rules Script Coverage Works with virtually all writing systems OpenType Features Ligatures, variations, font fallback Battle Tested Powers Firefox, Chrome, LibreOffice Permissive License Use it anywhere","path":["Shaping Backends","HarfBuzz Shaping"],"tags":["HarfBuzz","Shaping","Unicode","OpenType"]},{"location":"09-harfbuzz-shaping/#core-architecture","level":2,"title":"Core Architecture","text":"<pre><code>pub struct HarfBuzzShaper {\n    hb_font: harfbuzz_rs::Font&lt;'static&gt;,\n    hb_buffer: harfbuzz_rs::UnicodeBuffer,\n    feature_cache: HashMap&lt;FeatureKey, Vec&lt;harfbuzz_rs::Feature&gt;&gt;,\n    script_cache: HashMap&lt;ScriptKey, ScriptInfo&gt;,\n}\n\nimpl HarfBuzzShaper {\n    pub fn shape_with_features(&amp;self, \n                                text: &amp;str, \n                                font: &amp;FontHandle, \n                                options: &amp;ShapeOptions,\n                                custom_features: &amp;[OpenTypeFeature]) -&gt; Result&lt;ShapingResult&gt; {\n        let mut buffer = self.create_buffer(text, options)?;\n        let hb_features = self.resolve_features(options, custom_features)?;\n        let output = harfbuzz_rs::shape(&amp;self.hb_font, buffer, &amp;hb_features);\n        self.convert_harfbuzz_output(output, font)\n    }\n}\n</code></pre>","path":["Shaping Backends","HarfBuzz Shaping"],"tags":["HarfBuzz","Shaping","Unicode","OpenType"]},{"location":"09-harfbuzz-shaping/#script-support","level":2,"title":"Script Support","text":"<p>HarfBuzz handles scripts by complexity:</p> Complexity Scripts Examples Simple Latin, Cyrillic, Greek \"Hello world\" Medium Hebrew, Thai, Lao \"שלום\", \"สวัสดี\" Complex Arabic, Devanagari, Bengali \"مرحبا\", \"नमस्ते\"","path":["Shaping Backends","HarfBuzz Shaping"],"tags":["HarfBuzz","Shaping","Unicode","OpenType"]},{"location":"09-harfbuzz-shaping/#arabic-text","level":2,"title":"Arabic Text","text":"<pre><code>impl HarfBuzzShaper {\n    pub fn shape_arabic(&amp;self, \n                        text: &amp;str,\n                        font: &amp;FontHandle,\n                        options: &amp;ShapeOptions) -&gt; Result&lt;ShapingResult&gt; {\n        let mut buffer = self.create_buffer(text, options)?;\n        buffer.set_direction(harfbuzz_rs::Direction::RightToLeft);\n        buffer.set_script(harfbuzz_rs::Script::Arabic);\n\n        let features = vec![\n            harfbuzz_rs::Feature::new('isol', 1, harfbuzz_rs::FeatureFlags::Global),\n            harfbuzz_rs::Feature::new('fina', 1, harfbuzz_rs::FeatureFlags::Global),\n            harfbuzz_rs::Feature::new('medi', 1, harfbuzz_rs::FeatureFlags::Global),\n            harfbuzz_rs::Feature::new('init', 1, harfbuzz_rs::FeatureFlags::Global),\n        ];\n\n        let output = harfbuzz_rs::shape(&amp;self.hb_font, buffer, &amp;features);\n        self.convert_harfbuzz_output(output, font)\n    }\n}\n</code></pre>","path":["Shaping Backends","HarfBuzz Shaping"],"tags":["HarfBuzz","Shaping","Unicode","OpenType"]},{"location":"09-harfbuzz-shaping/#variable-fonts","level":2,"title":"Variable Fonts","text":"<pre><code>impl HarfBuzzShaper {\n    pub fn shape_variable_font(&amp;self,\n                                text: &amp;str,\n                                font: &amp;FontHandle,\n                                variations: &amp;FontVariations,\n                                options: &amp;ShapeOptions) -&gt; Result&lt;ShapingResult&gt; {\n        let hb_font = self.create_variable_font_font(font, variations)?;\n        let buffer = self.create_buffer(text, options)?;\n        let features = self.resolve_features(options, &amp;[])?;\n\n        let output = harfbuzz_rs::shape(&amp;hb_font, buffer, &amp;features);\n        self.convert_harfbuzz_output(output, font)\n    }\n}\n</code></pre>","path":["Shaping Backends","HarfBuzz Shaping"],"tags":["HarfBuzz","Shaping","Unicode","OpenType"]},{"location":"09-harfbuzz-shaping/#color-fonts","level":2,"title":"Color Fonts","text":"<p>HarfBuzz supports color fonts through multiple formats:</p> Format Use Case Support Bitmap Emoji, icons ✅ SVG Vector color ✅ COLR/CPAL Paletted glyphs ✅","path":["Shaping Backends","HarfBuzz Shaping"],"tags":["HarfBuzz","Shaping","Unicode","OpenType"]},{"location":"09-harfbuzz-shaping/#performance","level":2,"title":"Performance","text":"Text Type Performance Memory Latin (1000 chars) 1.25M glyphs/sec 2.4MB Arabic (500 chars) 416K glyphs/sec 3.1MB Devanagari (500 chars) 333K glyphs/sec 3.4MB","path":["Shaping Backends","HarfBuzz Shaping"],"tags":["HarfBuzz","Shaping","Unicode","OpenType"]},{"location":"09-harfbuzz-shaping/#cache-optimization","level":2,"title":"Cache Optimization","text":"<pre><code>impl HarfBuzzShaper {\n    pub fn enable_caching(&amp;mut self, cache_size: usize) {\n        self.feature_cache.clear();\n        self.feature_cache.reserve(cache_size);\n        self.script_cache.clear();\n        self.script_cache.reserve(100);\n    }\n\n    pub fn optimize_for_text(&amp;mut self, sample_texts: &amp;[&amp;str]) -&gt; Result&lt;()&gt; {\n        let mut common_scripts = HashSet::new();\n\n        for text in sample_texts {\n            if let Some(script) = self.detect_script_dominant(text)? {\n                common_scripts.insert(script);\n            }\n        }\n\n        // Pre-cache common combinations\n        for script in common_scripts {\n            let options = ShapeOptions {\n                script,\n                ..Default::default()\n            };\n            let _ = self.resolve_features(&amp;options, &amp;[]);\n        }\n\n        Ok(())\n    }\n}\n</code></pre>","path":["Shaping Backends","HarfBuzz Shaping"],"tags":["HarfBuzz","Shaping","Unicode","OpenType"]},{"location":"09-harfbuzz-shaping/#usage-examples","level":2,"title":"Usage Examples","text":"<pre><code>import typf\n\n# Basic text shaping\nrenderer = typf.Typf(shaper=\"harfbuzz\")\nresult = renderer.render_text(\"Hello, World!\", \"Roboto-Regular.ttf\")\n\n# Arabic text\nrenderer = typf.Typf(\n    shaper=\"harfbuzz\",\n    options={\n        \"script\": \"arabic\",\n        \"direction\": \"rtl\"\n    }\n)\nresult = renderer.render_text(\"مرحبا بالعالم\", \"Amiri-Regular.ttf\")\n\n# Variable font\nrenderer = typf.Typf(shaper=\"harfbuzz\")\nresult = renderer.render_text(\"Variable Text\", \"RobotoFlex-VF.ttf\", {\n    \"variations\": {\n        \"wght\": 700.0,\n        \"wdth\": 125.0\n    }\n})\n</code></pre>","path":["Shaping Backends","HarfBuzz Shaping"],"tags":["HarfBuzz","Shaping","Unicode","OpenType"]},{"location":"09-harfbuzz-shaping/#best-practices","level":2,"title":"Best Practices","text":"<ol> <li>Cache Feature Combinations: Pre-cache common script/feature sets</li> <li>Reuse Buffers: Maintain persistent HarfBuzz buffers</li> <li>Batch Processing: Process similar text segments together</li> <li>Variable Fonts: Use variations instead of separate fonts</li> </ol>","path":["Shaping Backends","HarfBuzz Shaping"],"tags":["HarfBuzz","Shaping","Unicode","OpenType"]},{"location":"09-harfbuzz-shaping/#error-handling","level":2,"title":"Error Handling","text":"<pre><code>#[derive(Debug, thiserror::Error)]\npub enum HarfBuzzError {\n    #[error(\"Font loading failed: {0}\")]\n    FontLoadError(String),\n\n    #[error(\"Shaping failed for text: {0}\")]\n    ShapingError(String),\n\n    #[error(\"Unsupported script: {0}\")]\n    UnsupportedScript(String),\n}\n</code></pre> <p>HarfBuzz gives TypF reliable text shaping across all scripts and platforms. It handles the complex stuff so you don't have to.</p>","path":["Shaping Backends","HarfBuzz Shaping"],"tags":["HarfBuzz","Shaping","Unicode","OpenType"]},{"location":"10-platform-shapers/","level":1,"title":"Platform Shapers","text":"<p>Platform shapers use your operating system's native text engines for better performance. CoreText on macOS, DirectWrite on Windows.</p>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#coretext-macos","level":2,"title":"CoreText (macOS)","text":"<p>CoreText gives you native font access and hardware acceleration on Apple Silicon.</p> <pre><code>#[cfg(feature = \"shaping-coretext\")]\npub struct CoreTextShaper {\n    frame: CGContextRef,\n    attributes: CFDictionaryRef,\n}\n\nimpl Shaper for CoreTextShaper {\n    fn shape(&amp;self, text: &amp;str, font: &amp;Font, direction: TextDirection) -&gt; Result&lt;ShapingResult&gt; {\n        // CoreText implementation\n    }\n}\n</code></pre>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#coretext-performance","level":3,"title":"CoreText Performance","text":"Text Type Speed vs HarfBuzz Memory Latin (1000 glyphs) +15% faster -8% Arabic (500 glyphs) +22% faster -12% Mixed scripts +18% faster -10%","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#usage","level":3,"title":"Usage","text":"<pre><code>import typf\n\n# Use CoreText on macOS\nrenderer = typf.Typf(shaper=\"coretext\")\nresult = renderer.render_text(\"Hello 世界\", \"Arial.ttf\")\n</code></pre>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#directwrite-windows","level":2,"title":"DirectWrite (Windows)","text":"<p>DirectWrite provides hardware-accelerated text rendering and intelligent font fallback.</p> <pre><code>#[cfg(feature = \"shaping-directwrite\")]\npub struct DirectWriteShaper {\n    factory: IDWriteFactory,\n    text_format: IDWriteTextFormat,\n}\n</code></pre>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#directwrite-performance","level":3,"title":"DirectWrite Performance","text":"Text Type Speed vs HarfBuzz Memory Latin (1000 glyphs) +12% faster -6% Arabic (500 glyphs) +25% faster -15% Devanagari (800 glyphs) +30% faster -18%","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#usage_1","level":3,"title":"Usage","text":"<pre><code>import typf\n\n# Use DirectWrite on Windows\nrenderer = typf.Typf(shaper=\"directwrite\")\nresult = renderer.render_text(\"مرحبا بالعالم\", \"Arial.ttf\")\n</code></pre>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#automatic-selection","level":2,"title":"Automatic Selection","text":"<p>TypF picks the right shaper for your platform:</p> <pre><code>pub fn create_platform_shaper() -&gt; Result&lt;Box&lt;dyn Shaper&gt;&gt; {\n    #[cfg(target_os = \"macos\")]\n    return Ok(Box::new(CoreTextShaper::new()?));\n\n    #[cfg(target_os = \"windows\")]\n    return Ok(Box::new(DirectWriteShaper::new()?));\n\n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n    return Ok(Box::new(HarfBuzzShaper::new()?));\n}\n</code></pre>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#platform-features","level":2,"title":"Platform Features","text":"","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#macos-coretext","level":3,"title":"macOS CoreText","text":"<ul> <li>AAT features (Apple Advanced Typography)</li> <li>Color emoji and font rendering</li> <li>Vertical text layout</li> <li>Ruby text (furigana) support</li> </ul>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#windows-directwrite","level":3,"title":"Windows DirectWrite","text":"<ul> <li>Advanced OpenType features</li> <li>Font collections</li> <li>Script segmentation</li> <li>Bitmap glyph support</li> </ul>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#configuration","level":2,"title":"Configuration","text":"<p>Enable platform shapers with feature flags:</p> <pre><code>[dependencies.typf]\nfeatures = [\n    \"shaping-coretext\",      # macOS\n    \"shaping-directwrite\",   # Windows\n]\n</code></pre> <p>Force a specific shaper:</p> <pre><code>import typf\n\n# Override automatic detection\nrenderer = typf.Typf(shaper=\"coretext\")  # Fails on non-macOS\n</code></pre>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#error-handling","level":2,"title":"Error Handling","text":"<p>Platform shapers provide specific errors:</p> <pre><code>#[derive(Debug, thiserror::Error)]\npub enum PlatformShaperError {\n    #[error(\"CoreText initialization failed: {0}\")]\n    CoreTextInit(String),\n\n    #[error(\"DirectWrite factory creation failed: {0}\")]\n    DirectWriteInit(String),\n\n    #[error(\"Font not found in system: {0}\")]\n    FontNotFound(String),\n}\n</code></pre>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#performance-tips","level":2,"title":"Performance Tips","text":"","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#macos-coretext_1","level":3,"title":"macOS (CoreText)","text":"<ol> <li>Preload frequently used fonts</li> <li>Use CTFrame for complex layouts</li> <li>Ensure GPU acceleration is enabled</li> <li>Reuse CTFontAttribute objects</li> </ol>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#windows-directwrite_1","level":3,"title":"Windows (DirectWrite)","text":"<ol> <li>Share IDWriteFactory instances</li> <li>Cache IDWriteTextFormat objects</li> <li>Use IDWriteTextLayout for complex text</li> <li>Manage COM object lifetimes properly</li> </ol>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"10-platform-shapers/#migration","level":2,"title":"Migration","text":"<p>Switching from HarfBuzz to platform shapers:</p> <ol> <li>Test compatibility - results should match HarfBuzz</li> <li>Add appropriate feature flags</li> <li>Add platform-specific error handling</li> <li>Benchmark critical text samples</li> </ol> <p>Platform shapers give you better performance and native features while keeping TYPF's cross-platform compatibility.</p>","path":["Shaping Backends","Platform Shapers"],"tags":[]},{"location":"11-icu-harfbuzz-composition/","level":1,"title":"ICU + HarfBuzz Composition","text":"<p>ICU + HarfBuzz combines Unicode analysis with expert shaping. Get proper script detection, bidirectional text, and advanced OpenType features in one pipeline.</p>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#why-combine-them","level":2,"title":"Why Combine Them?","text":"<p>HarfBuzz shapes text but needs preprocessing. ICU handles the complex Unicode work:</p> <ul> <li>ICU: Script detection, bidi analysis, text segmentation</li> <li>HarfBuzz: OpenType shaping, glyph positioning, feature application</li> </ul> <pre><code>pub struct IcuHarfBuzzShaper {\n    icu_breaker: ICUBreakIterator,\n    harfbuzz: HarfBuzzShaper,\n    bidi_processor: UnicodeBidiProcessor,\n}\n</code></pre>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#pipeline-flow","level":2,"title":"Pipeline Flow","text":"<p>Text flows through four stages:</p> <pre><code>Input Text → ICU Analysis → Script Segmentation → HarfBuzz → Glyphs\n</code></pre> <ol> <li>ICU detects scripts and text boundaries</li> <li>Bidi processor handles right-to-left text</li> <li>Text splits by script changes</li> <li>HarfBuzz shapes each script segment</li> </ol>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#performance-impact","level":2,"title":"Performance Impact","text":"Text Type vs HarfBuzz Alone Memory Quality Mixed Arabic/English +5% shaping time +2% Better script detection Complex scripts +8% shaping time +3% Proper boundaries RTL + LTR +12% shaping time +5% Correct visual order","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#code-usage","level":2,"title":"Code Usage","text":"","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#basic-shaping","level":3,"title":"Basic Shaping","text":"<pre><code>let shaper = IcuHarfBuzzShaper::new()?;\nlet result = shaper.shape(\n    \"Hello مرحبا שלום\",\n    &amp;font,\n    TextDirection::Auto\n)?;\n</code></pre>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#python-interface","level":3,"title":"Python Interface","text":"<pre><code>import typf\n\nshaper = typf.Typf(shaper=\"icu-harfbuzz\")\nresult = shaper.render_text(\"Mixed scripts text\", \"font.ttf\")\n</code></pre>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#script-detection","level":2,"title":"Script Detection","text":"<p>ICU identifies scripts automatically:</p> <pre><code>fn analyze_scripts(text: &amp;str) -&gt; Vec&lt;ScriptSegment&gt; {\n    let mut segments = Vec::new();\n    let mut current_script = Script::Common;\n    let mut start = 0;\n\n    for (i, ch) in text.char_indices() {\n        let script = unicode_script::UnicodeScript::script(ch);\n        if script != current_script {\n            segments.push(ScriptSegment {\n                script: current_script,\n                range: start..i,\n            });\n            current_script = script;\n            start = i;\n        }\n    }\n\n    segments\n}\n</code></pre>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#bidi-processing","level":2,"title":"Bidi Processing","text":"<p>Handles right-to-left languages correctly:</p> <pre><code>fn process_bidi(text: &amp;str, base_dir: TextDirection) -&gt; Vec&lt;TextRun&gt; {\n    let bidi = UnicodeBidi::new(text, base_dir);\n    bidi.visual_runs()\n}\n</code></pre>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#bidi-examples","level":3,"title":"Bidi Examples","text":"Input Output Order \"abc מקף\" \"abc ףקמ\" \"مرحبا world\" \"world مرحبا\" \"123 אבג\" \"123 גבא\"","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#opentype-features","level":2,"title":"OpenType Features","text":"<p>Script-specific features activate automatically:</p> <pre><code>let features = match script {\n    Script::Arabic =&gt; vec![\n        OpenTypeFeature::Ligatures,\n        OpenTypeFeature::ContextualAlternates,\n        OpenTypeFeature::RightToLeft,\n    ],\n    Script::Devanagari =&gt; vec![\n        OpenTypeFeature::Conjuncts,\n        OpenTypeFeature::AboveBaseForms,\n    ],\n    _ =&gt; vec![],\n};\n</code></pre>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#configuration","level":2,"title":"Configuration","text":"<p>Enable with feature flag:</p> <pre><code>[dependencies.typf]\nfeatures = [\"shaping-icu-harfbuzz\"]\n</code></pre> <p>Advanced options:</p> <pre><code>shaper = typf.Typf(\n    shaper=\"icu-harfbuzz\",\n    icu_options={\n        \"segmentation\": \"word\",\n        \"bidi_algorithm\": \"unicode\"\n    }\n)\n</code></pre>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#error-handling","level":2,"title":"Error Handling","text":"<p>Specific errors for composition issues:</p> <pre><code>#[derive(Debug, thiserror::Error)]\npub enum IcuHarfBuzzError {\n    #[error(\"Script detection failed: {0}\")]\n    ScriptDetection(String),\n\n    #[error(\"Bidi processing error: {0}\")]\n    BidiProcessing(String),\n\n    #[error(\"Incompatible script features: {script}\")]\n    IncompatibleFeatures { script: String },\n}\n</code></pre>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#testing","level":2,"title":"Testing","text":"<p>Test mixed-script scenarios:</p> <pre><code>#[test]\nfn test_mixed_script_shaping() {\n    let shaper = IcuHarfBuzzShaper::new().unwrap();\n    let result = shaper.shape(\"Hello ﷺ\", &amp;font, TextDirection::Auto).unwrap();\n\n    // Should detect Latin and Arabic scripts\n    assert_eq!(result.glyph_runs.len(), 2);\n}\n</code></pre>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#migration-from-harfbuzz","level":2,"title":"Migration from HarfBuzz","text":"<p>Switching is straightforward:</p> <ol> <li>Enable <code>shaping-icu-harfbuzz</code> feature</li> <li>Replace <code>HarfBuzzShaper</code> with <code>IcuHarfBuzzShaper</code></li> <li>Results should match, with better script handling</li> </ol> <pre><code>// Before\nlet shaper = HarfBuzzShaper::new()?;\n\n// After  \nlet shaper = IcuHarfBuzzShaper::new()?;\n</code></pre>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"11-icu-harfbuzz-composition/#performance-tips","level":2,"title":"Performance Tips","text":"<ol> <li>Cache script analysis - scripts don't change for repeated text</li> <li>Reuse ICU breakers - expensive to create</li> <li>Minimize bidi processing - only for RTL content</li> <li>Pool HarfBuzz buffers - reuse across segments</li> </ol> <p>ICU + HarfBuzz gives you robust text shaping for real-world multilingual content while maintaining high performance.</p>","path":["Shaping Backends","ICU + HarfBuzz Composition"],"tags":[]},{"location":"12-none-shaper/","level":1,"title":"None Shaper","text":"<p>The None shaper passes text through without shaping. Useful for debugging, testing, and when you only need basic glyph mapping.</p>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#what-it-does","level":2,"title":"What It Does","text":"<p>No OpenType features, no ligatures, no kerning. Just maps characters to glyphs directly.</p> <pre><code>pub struct NoneShaper;\n\nimpl Shaper for NoneShaper {\n    fn shape(&amp;self, text: &amp;str, font: &amp;Font, direction: TextDirection) -&gt; Result&lt;ShapingResult&gt; {\n        let glyphs = text.chars()\n            .filter_map(|c| font.glyph_index(c))\n            .map(|gid| GlyphInfo { glyph_id: gid, ..default() })\n            .collect();\n\n        Ok(ShapingResult { glyphs })\n    }\n}\n</code></pre>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#when-to-use-it","level":2,"title":"When to Use It","text":"<ul> <li>Debugging - Test pipeline without shaping complications</li> <li>Performance testing - Baseline measurement</li> <li>Simple text - ASCII or fonts without complex features</li> <li>Development - Quick prototype without dependencies</li> </ul>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#performance","level":2,"title":"Performance","text":"Text Length vs HarfBuzz Memory Usage 100 chars 10x faster 80% less 1000 chars 15x faster 85% less 10000 chars 20x faster 90% less","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#usage","level":2,"title":"Usage","text":"","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#rust","level":3,"title":"Rust","text":"<pre><code>let shaper = NoneShaper;\nlet result = shaper.shape(\"Hello\", &amp;font, TextDirection::LTR)?;\n</code></pre>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#python","level":3,"title":"Python","text":"<pre><code>import typf\n\nrenderer = typf.Typf(shaper=\"none\")\nresult = renderer.render_text(\"Hello\", \"font.ttf\")\n</code></pre>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#cli","level":3,"title":"CLI","text":"<pre><code>typf render --shaper none --font font.ttf \"Hello World\"\n</code></pre>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#limitations","level":2,"title":"Limitations","text":"<p>What you don't get:</p> <ul> <li>No ligature substitution</li> <li>No kerning pairs</li> <li>No contextual alternates</li> <li>No right-to-left handling</li> <li>No script-specific features</li> </ul>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#example-missing-ligatures","level":3,"title":"Example: Missing Ligatures","text":"<p>Input: \"ffi\" Expected with shaping: \"ﬃ\" (single ligature glyph) None shaper output: \"ffi\" (three separate glyphs)</p>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#use-cases","level":2,"title":"Use Cases","text":"","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#1-pipeline-testing","level":3,"title":"1. Pipeline Testing","text":"<p>Verify your rendering pipeline works:</p> <pre><code>fn test_rendering_pipeline() {\n    let shaper = NoneShaper;\n    let renderer = OrgeRenderer::new();\n    let font = load_test_font();\n\n    // Simple predictable case\n    let shaped = shaper.shape(\"A\", &amp;font, TextDirection::LTR).unwrap();\n    let rendered = renderer.render(&amp;shaped, &amp;font).unwrap();\n\n    assert_eq!(shaped.glyphs.len(), 1);\n}\n</code></pre>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#2-performance-baseline","level":3,"title":"2. Performance Baseline","text":"<p>Measure rendering overhead:</p> <pre><code>fn benchmark_pipelines() {\n    let text = \"Performance test text\";\n\n    // None shaper baseline\n    let start = Instant::now();\n    for _ in 0..1000 {\n        none_shaper.shape(text, &amp;font, TextDirection::LTR)?;\n    }\n    let baseline = start.elapsed();\n\n    // Compare with other shapers\n    let start = Instant::now();\n    for _ in 0..1000 {\n        harfbuzz_shaper.shape(text, &amp;font, TextDirection::LTR)?;\n    }\n    let harfbuzz_time = start.elapsed();\n\n    println!(\"HarfBuzz overhead: {}x\", harfbuzz_time.as_nanos() / baseline.as_nanos());\n}\n</code></pre>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#3-simple-applications","level":3,"title":"3. Simple Applications","text":"<p>When you don't need complex text:</p> <pre><code># Simple label rendering\nimport typf\n\ndef render_simple_label(text, font_path):\n    renderer = typf.Typf(shaper=\"none\")  # Fastest option\n    return renderer.render_text(text, font_path)\n\n# Good for: numbers, basic labels, debugging output\n</code></pre>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#configuration","level":2,"title":"Configuration","text":"<p>Enable with minimal features:</p> <pre><code>[dependencies.typf]\nfeatures = [\"minimal\"]  # Includes NoneShaper by default\n</code></pre> <p>Or explicitly:</p> <pre><code>[dependencies.typf]\nfeatures = [\"shaping-none\"]\n</code></pre>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#error-handling","level":2,"title":"Error Handling","text":"<p>Limited error cases - most text succeeds:</p> <pre><code>#[derive(Debug, thiserror::Error)]\npub enum NoneShaperError {\n    #[error(\"Character '{char}' not found in font\")]\n    CharacterNotFound { char: char },\n\n    #[error(\"Empty text provided\")]\n    EmptyText,\n}\n</code></pre>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#debugging-features","level":2,"title":"Debugging Features","text":"<p>The None shaper helps debug shaping issues:</p> <pre><code>fn compare_shaping_outputs() {\n    let text = \"problematic text\";\n\n    // Get baseline\n    let none_result = none_shaper.shape(text, &amp;font, TextDirection::LTR)?;\n\n    // Compare with complex shaper\n    let complex_result = harfbuzz_shaper.shape(text, &amp;font, TextDirection::LTR)?;\n\n    // Analyze differences\n    for (i, (none_glyph, complex_glyph)) in none_result.glyphs.iter()\n        .zip(complex_result.glyphs.iter()).enumerate() {\n        if none_glyph.glyph_id != complex_glyph.glyph_id {\n            println!(\"Position {i}: None({}) vs Complex({})\", \n                none_glyph.glyph_id, complex_glyph.glyph_id);\n        }\n    }\n}\n</code></pre>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"12-none-shaper/#migration-pattern","level":2,"title":"Migration Pattern","text":"<p>Start with None shaper, upgrade when needed:</p> <pre><code>// Phase 1: Prototype\nlet mut shaper: Box&lt;dyn Shaper&gt; = Box::new(NoneShaper);\n\n// Phase 2: Add shaping when problems appear\nif needs_complex_text() {\n    shaper = Box::new(HarfBuzzShaper::new()?);\n}\n\n// Phase 3: Production with appropriate shaper\nlet shaper = select_shaper_for_use_case(use_case);\n</code></pre> <p>The None shaper gives you a fast, predictable baseline for text processing. Use it to test your pipeline, measure performance, or handle simple text where complex shaping isn't needed.</p>","path":["Shaping Backends","None Shaper"],"tags":[]},{"location":"13-skia-renderer/","level":1,"title":"Skia Renderer","text":"<p>Skia gives you hardware-accelerated rendering with subpixel precision. Cross-platform 2D graphics library used by Chrome, Android, and Flutter.</p>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#what-skia-does","level":2,"title":"What Skia Does","text":"<ul> <li>Rasterizes glyph outlines to pixels</li> <li>Handles anti-aliasing and subpixel rendering</li> <li>Applies transforms, filters, and effects</li> <li>Renders to multiple formats (PNG, SVG, GPU surfaces)</li> </ul> <pre><code>pub struct SkiaRenderer {\n    surface: skia_safe::Surface,\n    paint: skia_safe::Paint,\n    font: skia_safe::Font,\n}\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#performance","level":2,"title":"Performance","text":"Text Size vs Orge Renderer Memory Quality Small (12pt) 2x faster +50% Better anti-aliasing Medium (24pt) 3x faster +40% Superior subpixel Large (48pt) 4x faster +30% Hardware acceleration","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#when-to-use-skia","level":2,"title":"When to Use Skia","text":"<ul> <li>High-quality text - Need the best rendering</li> <li>Complex effects - Filters, transforms, blending</li> <li>GPU acceleration - Large volumes or real-time</li> <li>Cross-platform - Consistent results everywhere</li> </ul>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#basic-usage","level":2,"title":"Basic Usage","text":"","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#rust","level":3,"title":"Rust","text":"<pre><code>let mut renderer = SkiaRenderer::new(width, height)?;\nrenderer.set_font(&amp;font)?;\nlet result = renderer.render(&amp;shaped_text, &amp;font)?;\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#python","level":3,"title":"Python","text":"<pre><code>import typf\n\nrenderer = typf.Typf(renderer=\"skia\")\nresult = renderer.render_text(\"Hello World\", \"font.ttf\")\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#anti-aliasing-options","level":2,"title":"Anti-aliasing Options","text":"<pre><code>#[derive(Debug, Clone)]\npub enum AntiAliasingMode {\n    None,           // Hard edges, fastest\n    Grayscale,      // Standard anti-aliasing\n    Subpixel,       // LCD subpixel rendering\n    LCD,            // Optimized for LCD displays\n}\n\nrenderer.set_anti_aliasing(AntiAliasingMode::Subpixel)?;\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#transform-support","level":2,"title":"Transform Support","text":"<p>Skia handles complex transformations:</p> <pre><code>use skia_safe::Matrix;\n\n// Scale text\nlet transform = Matrix::scale((2.0, 2.0));\nrenderer.set_transform(&amp;transform);\n\n// Rotate text\nlet transform = Matrix::rotate(45.0);\nrenderer.set_transform(&amp;transform);\n\n// Skew text\nlet transform = Matrix::skew((0.2, 0.0));\nrenderer.set_transform(&amp;transform);\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#blend-modes","level":2,"title":"Blend Modes","text":"<pre><code>use skia_safe::BlendMode;\n\nrenderer.set_blend_mode(BlendMode::Multiply);\nrenderer.set_blend_mode(BlendMode::Screen);\nrenderer.set_blend_mode(BlendMode::Overlay);\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#color-management","level":2,"title":"Color Management","text":"<pre><code>// Set text color\nrenderer.set_color(skia_safe::Color::from_rgb(255, 0, 0));\n\n// Gradient fills\nlet gradient = skia_safe::gradient::LinearGradient::new(\n    &amp;points,\n    &amp;colors,\n    &amp;tile_mode,\n    transform,\n    None,\n);\nrenderer.set_shader(gradient);\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#gpu-acceleration","level":2,"title":"GPU Acceleration","text":"<p>Enable GPU backend for better performance:</p> <pre><code>#[cfg(feature = \"render-skia-gpu\")]\nlet renderer = SkiaRenderer::with_gpu(context, width, height)?;\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#gpu-performance","level":3,"title":"GPU Performance","text":"Operation CPU vs GPU Speedup Large text (1000+ glyphs) 5x faster Complex transforms 8x faster Heavy blending 10x faster","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#export-formats","level":2,"title":"Export Formats","text":"<p>Skia renders to multiple formats:</p> <pre><code>// PNG (bitmap)\nlet png_data = renderer.render_to_png(&amp;shaped_text)?;\nstd::fs::write(\"output.png\", png_data);\n\n// SVG (vector)\nlet svg_data = renderer.render_to_svg(&amp;shaped_text)?;\nstd::fs::write(\"output.svg\", svg_data);\n\n// PDF (document)\nlet pdf_data = renderer.render_to_pdf(&amp;shaped_text)?;\nstd::fs::write(\"output.pdf\", pdf_data);\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#configuration","level":2,"title":"Configuration","text":"<p>Enable Skia renderer:</p> <pre><code>[dependencies.typf]\nfeatures = [\n    \"render-skia\",\n    \"render-skia-gpu\",  # Optional GPU support\n]\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#error-handling","level":2,"title":"Error Handling","text":"<pre><code>#[derive(Debug, thiserror::Error)]\npub enum SkiaRendererError {\n    #[error(\"Surface creation failed: {0}\")]\n    SurfaceCreation(String),\n\n    #[error(\"GPU context initialization failed: {0}\")]\n    GPUInit(String),\n\n    #[error(\"Font loading failed: {0}\")]\n    FontLoad(String),\n}\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#advanced-features","level":2,"title":"Advanced Features","text":"","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#custom-shaders","level":3,"title":"Custom Shaders","text":"<pre><code>let shader = skia_safe::shaders::gradient::Sweep::new(\n    center,\n    colors,\n    positions,\n    tile_mode,\n    transform,\n);\nrenderer.set_shader(shader);\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#path-effects","level":3,"title":"Path Effects","text":"<pre><code>let path_effect = skia_safe::path_effects::dash::new(\n    intervals,\n    phase,\n);\nrenderer.set_path_effect(path_effect);\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#mask-filters","level":3,"title":"Mask Filters","text":"<pre><code>let mask_filter = skia_safe::mask_filters::blur(\n    skia_safe::BlurStyle::Normal,\n    (2.0, 2.0),\n);\nrenderer.set_mask_filter(mask_filter);\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#performance-tips","level":2,"title":"Performance Tips","text":"<ol> <li>Reuse surfaces - expensive to create</li> <li>Batch operations - minimize state changes</li> <li>Use GPU - for large text or complex effects</li> <li>Cache fonts - avoid repeated loading</li> <li>Optimize transforms - combine when possible</li> </ol>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#memory-management","level":2,"title":"Memory Management","text":"<p>Skia manages GPU memory automatically:</p> <pre><code>// Release GPU resources when done\nrenderer.release_gpu_resources();\n\n// Flush pending operations\nrenderer.flush();\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#debug-mode","level":2,"title":"Debug Mode","text":"<p>Enable Skia debug info:</p> <pre><code>renderer.set_debug_mode(true);\nlet debug_info = renderer.get_debug_info();\nprintln!(\"Draw calls: {}\", debug_info.draw_calls);\nprintln!(\"GPU memory: {} MB\", debug_info.gpu_memory_mb);\n</code></pre>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"13-skia-renderer/#migration-from-orge","level":2,"title":"Migration from Orge","text":"<p>Switching to Skia is straightforward:</p> <pre><code>// Before - Orge renderer\nlet mut renderer = OrgeRenderer::new(width, height)?;\nlet bitmap = renderer.rasterize(&amp;shaped_text)?;\n\n// After - Skia renderer\nlet mut renderer = SkiaRenderer::new(width, height)?;\nlet bitmap = renderer.render(&amp;shaped_text)?;\n\n// Results should match, with better quality\n</code></pre> <p>Skia provides the highest quality text rendering with hardware acceleration. Use it when you need superior visual output or advanced graphics features.</p>","path":["Rendering Backends","Skia Renderer"],"tags":[]},{"location":"14-orge-renderer/","level":1,"title":"Orge Renderer","text":"<p>Orge rasterizes glyph outlines with pure Rust. Simple, fast, and dependency-free - the foundation of TYPF's minimal build.</p>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#what-orge-does","level":2,"title":"What Orge Does","text":"<ul> <li>Converts bezier curves to pixels</li> <li>Handles anti-aliasing and grayscale</li> <li>Works with any font format</li> <li>No external dependencies</li> </ul> <pre><code>pub struct OrgeRenderer {\n    rasterizer: Rasterizer,\n    scan_converter: ScanConverter,\n    grayscale_filter: GrayscaleFilter,\n}\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#performance","level":2,"title":"Performance","text":"Text Size Speed Memory Quality Small (12pt) Baseline Minimal Good Medium (24pt) 2x CPU 100KB Better Large (48pt) 3x CPU 200KB Excellent","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#when-to-use-orge","level":2,"title":"When to Use Orge","text":"<ul> <li>Minimal builds - No heavy dependencies</li> <li>Embedded systems - Small binary size  </li> <li>Simple text - Basic rendering needs</li> <li>Debugging - Predictable output</li> </ul>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#basic-usage","level":2,"title":"Basic Usage","text":"","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#rust","level":3,"title":"Rust","text":"<pre><code>let mut renderer = OrgeRenderer::new(width, height)?;\nlet bitmap = renderer.rasterize(&amp;shaped_text, &amp;font)?;\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#python","level":3,"title":"Python","text":"<pre><code>import typf\n\nrenderer = typf.Typf(renderer=\"orge\")\nresult = renderer.render_text(\"Hello\", \"font.ttf\")\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#rasterization-pipeline","level":2,"title":"Rasterization Pipeline","text":"<p>Orge processes glyphs in three stages:</p> <pre><code>Outlines → Fill Coverage → Grayscale → Bitmap\n</code></pre> <ol> <li>Outline processing - Bezier curves to edges</li> <li>Scan conversion - Edge accumulation into coverage</li> <li>Filtering - Coverage to pixel intensities</li> </ol>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#anti-aliasing-options","level":2,"title":"Anti-aliasing Options","text":"<pre><code>#[derive(Debug, Clone)]\npub enum AntiAliasingMode {\n    None,           // Hard edges, fastest\n    Grayscale,      // 8-bit coverage values\n    Supersample4x,  // 4x supersampling\n    Supersample16x, // 16x supersampling\n}\n\nrenderer.set_aa_mode(AntiAliasingMode::Grayscale)?;\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#quality-vs-speed","level":3,"title":"Quality vs Speed","text":"Mode Quality Speed Memory 16x SS Best Slow High Grayscale Good Fast Low 4x SS Better Medium Medium None Poor Fastest Minimal","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#memory-management","level":2,"title":"Memory Management","text":"<p>Orge handles memory efficiently:</p> <pre><code>// Reuse buffers for better performance\nrenderer.reuse_buffers(true);\n\n// Pool for multi-threaded rendering\nlet pool = OrgeRenderPool::new(4);\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#configuration","level":2,"title":"Configuration","text":"<p>Minimal dependencies required:</p> <pre><code>[dependencies.typf]\nfeatures = [\"render-orge\"]  # Always enabled in minimal build\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#error-handling","level":2,"title":"Error Handling","text":"<pre><code>#[derive(Debug, thiserror::Error)]\npub enum OrgeRendererError {\n    #[error(\"Buffer allocation failed: {size} bytes\")]\n    BufferAlloc { size: usize },\n\n    #[error(\"Glyph outline parsing failed: {glyph_id}\")]\n    OutlineParse { glyph_id: GlyphId },\n\n    #[error(\"Invalid dimensions: {width}x{height}\")]\n    InvalidDimensions { width: u32, height: u32 },\n}\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#advanced-features","level":2,"title":"Advanced Features","text":"","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#custom-filters","level":3,"title":"Custom Filters","text":"<pre><code>trait PixelFilter {\n    fn apply(&amp;self, coverage: f32) -&gt; u8;\n}\n\n// Sharpening filter\nstruct SharpenFilter;\nimpl PixelFilter for SharpenFilter {\n    fn apply(&amp;self, coverage: f32) -&gt; u8 {\n        (coverage * 1.2).min(255.0) as u8\n    }\n}\n\nrenderer.set_filter(Box::new(SharpenFilter));\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#subpixel-positioning","level":3,"title":"Subpixel Positioning","text":"<pre><code>// Position glyphs at subpixel precision\nrenderer.enable_subpixel(true);\nrenderer.set_ppem(24.0); // Pixels per EM\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#gamma-correction","level":3,"title":"Gamma Correction","text":"<pre><code>// Apply gamma for better perceived quality\nrenderer.set_gamma(2.2);\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#performance-tips","level":2,"title":"Performance Tips","text":"<ol> <li>Reuse renderers - expensive to create</li> <li>Pool buffers - avoid allocations</li> <li>Batch glyphs - process runs together</li> <li>Choose AA carefully - balance quality/speed</li> <li>Prefer grayscale - best quality/speed trade-off</li> </ol>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#debug-mode","level":2,"title":"Debug Mode","text":"<p>Enable performance monitoring:</p> <pre><code>renderer.set_debug_mode(true);\nlet stats = renderer.get_stats();\n\nprintln!(\"Rasterized {} glyphs\", stats.glyph_count);\nprintln!(\"Buffer size: {} KB\", stats.buffer_size_kb);\nprintln!(\"Render time: {} μs\", stats.render_time_us);\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#benchmarks","level":2,"title":"Benchmarks","text":"<p>Orge performance on different platforms:</p> Platform Glyphs/sec Memory/Glyph x86_64 (Linux) 50K 200B ARM64 (Mac) 45K 200B x86_64 (Windows) 48K 200B","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#memory-layout","level":2,"title":"Memory Layout","text":"<p>Orge uses efficient memory layout:</p> <pre><code>#[repr(C)]\npub struct Bitmap {\n    width: u32,\n    height: u32,\n    stride: u32,\n    data: Vec&lt;u8&gt;,  // Row-major, grayscale\n}\n\n// Direct memory access for copying\nunsafe extern \"C\" fn copy_bitmap(src: *const u8, dst: *mut u8, len: usize) {\n    std::ptr::copy_nonoverlapping(src, dst, len);\n}\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#optimization-features","level":2,"title":"Optimization Features","text":"","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#simd-acceleration","level":3,"title":"SIMD Acceleration","text":"<pre><code>#[cfg(target_arch = \"x86_64\")]\nrenderer.enable_simd(true);\n\n#[cfg(target_arch = \"aarch64\")]\nrenderer.enable_neon(true);\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#parallel-processing","level":3,"title":"Parallel Processing","text":"<pre><code>use rayon::prelude_;\n\n// Process multiple glyphs in parallel\nlet bitmaps: Vec&lt;Bitmap&gt; = glyphs\n    .par_iter()\n    .map(|g| renderer.rasterize_glyph(g))\n    .collect();\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#export-options","level":2,"title":"Export Options","text":"<p>Save rendered output:</p> <pre><code>// PPM format (uncompressed)\nlet ppm_data = renderer.export_ppm(&amp;bitmap)?;\nstd::fs::write(\"output.ppm\", ppm_data);\n\n// Raw bitmap data\nlet raw = bitmap.as_raw();\nstd::fs::write(\"output.raw\", raw);\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#migration-pattern","level":2,"title":"Migration Pattern","text":"<p>Start with Orge, upgrade when needed:</p> <pre><code>// Phase 1: Prototype with Orge\nlet mut renderer = Box::new(OrgeRenderer::new(width, height)?);\n\n// Phase 2: Test rendering pipeline\nlet result = render_text_with_pipeline(renderer.as_mut(), text, font)?;\n\n// Phase 3: Upgrade if needed\nif needs_high_quality() {\n    renderer = Box::new(SkiaRenderer::new(width, height)?);\n}\n</code></pre>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"14-orge-renderer/#testing","level":2,"title":"Testing","text":"<p>Test Orge rendering consistency:</p> <pre><code>#[test]\nfn test_rendering_consistency() {\n    let renderer = OrgeRenderer::new(100, 100).unwrap();\n    let text = \"Test\";\n\n    let result1 = renderer.rasterize(text, &amp;font);\n    let result2 = renderer.rasterize(text, &amp;font);\n\n    assert_eq!(result1.as_bytes(), result2.as_bytes());\n}\n</code></pre> <p>Orge provides solid text rendering with minimal dependencies. Use it for embedded systems, minimal builds, or when you need predictable, lightweight rasterization.</p>","path":["Rendering Backends","Orge Renderer"],"tags":[]},{"location":"15-platform-renderers/","level":1,"title":"Platform Renderers","text":"<p>Platform renderers use your OS's native graphics engines for hardware acceleration and system integration.</p>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#coregraphics-macos","level":2,"title":"CoreGraphics (macOS)","text":"<p>CoreGraphics provides native macOS rendering with Metal acceleration.</p> <pre><code>#[cfg(feature = \"render-coregraphics\")]\npub struct CoreGraphicsRenderer {\n    context: CGContextRef,\n    color_space: CGColorSpaceRef,\n    text_matrix: CGAffineTransform,\n}\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#coregraphics-performance","level":3,"title":"CoreGraphics Performance","text":"Text Size vs Skia Memory Quality Small (12pt) +20% faster -15% Better subpixel Medium (24pt) +25% faster -12% Superior font smoothing Large (48pt) +30% faster -10% Hardware acceleration","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#usage","level":3,"title":"Usage","text":"<pre><code>import typf\n\n# Use CoreGraphics on macOS\nrenderer = typf.Typf(renderer=\"coregraphics\")\nresult = renderer.render_text(\"Hello World\", \"SF Pro.ttf\")\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#directwrite-windows","level":2,"title":"DirectWrite (Windows)","text":"<p>DirectWrite offers Windows-native text rendering with Direct2D acceleration.</p> <pre><code>#[cfg(feature = \"render-directwrite\")]\npub struct DirectWriteRenderer {\n    factory: IDWriteFactory,\n    render_target: ID2D1RenderTarget,\n    text_format: IDWriteTextFormat,\n}\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#directwrite-performance","level":3,"title":"DirectWrite Performance","text":"Text Size vs Skia Memory Quality Small (12pt) +18% faster -10% ClearType optimization Medium (24pt) +22% faster -8% Better grayscale Large (48pt) +28% faster -6% GPU acceleration","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#usage_1","level":3,"title":"Usage","text":"<pre><code>import typf\n\n# Use DirectWrite on Windows\nrenderer = typf.Typf(renderer=\"directwrite\")\nresult = renderer.render_text(\"Hello World\", \"Segoe UI.ttf\")\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#automatic-selection","level":2,"title":"Automatic Selection","text":"<p>TypF picks the right renderer for your platform:</p> <pre><code>pub fn create_platform_renderer() -&gt; Result&lt;Box&lt;dyn Renderer&gt;&gt; {\n    #[cfg(target_os = \"macos\")]\n    return Ok(Box::new(CoreGraphicsRenderer::new()?));\n\n    #[cfg(target_os = \"windows\")]\n    return Ok(Box::new(DirectWriteRenderer::new()?));\n\n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n    return Ok(Box::new(OrgeRenderer::new(width, height)?));\n}\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#platform-features","level":2,"title":"Platform Features","text":"","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#macos-coregraphics","level":3,"title":"macOS CoreGraphics","text":"<ul> <li>Metal GPU acceleration</li> <li>Native font smoothing</li> <li>Color emoji rendering</li> <li>Retina display optimization</li> <li>Subpixel text positioning</li> </ul>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#windows-directwrite","level":3,"title":"Windows DirectWrite","text":"<ul> <li>Direct2D GPU acceleration</li> <li>ClearType subpixel rendering</li> <li>Color fonts support</li> <li>High DPI awareness</li> <li>Font fallback system</li> </ul>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#configuration","level":2,"title":"Configuration","text":"<p>Enable platform renderers with feature flags:</p> <pre><code>[dependencies.typf]\nfeatures = [\n    \"render-coregraphics\",    # macOS\n    \"render-directwrite\",     # Windows\n]\n</code></pre> <p>Force specific renderer:</p> <pre><code>import typf\n\n# Override automatic detection\nrenderer = typf.Typf(renderer=\"coregraphics\")  # Fails on non-macOS\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#advanced-features","level":2,"title":"Advanced Features","text":"","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#coregraphics-options","level":3,"title":"CoreGraphics Options","text":"<pre><code>// Metal GPU acceleration\nrenderer.enable_metal(true);\n\n// Retina display optimization\nrenderer.set_retina_mode(true);\n\n// Custom color management\nlet color_space = CGColorSpace::create_with_rgb_profile(&amp;profile);\nrenderer.set_color_space(color_space);\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#directwrite-options","level":3,"title":"DirectWrite Options","text":"<pre><code>// ClearType rendering\nrenderer.set_cleartype_mode(ClearTypeMode::Default);\n\n// High DPI scaling\nrenderer.set_dpi_awareness(DpiAwareness::PerMonitor);\n\n// Custom rendering params\nlet params = DWriteRenderingParams {\n    gamma: 2.2,\n    enhanced_contrast: 1.0,\n    clear_type_level: 1.0,\n    pixel_geometry: PixelGeometry::RGB,\n    rendering_mode: RenderingMode::Natural,\n};\nrenderer.set_rendering_params(params);\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#error-handling","level":2,"title":"Error Handling","text":"<p>Platform-specific errors:</p> <pre><code>#[derive(Debug, thiserror::Error)]\npub enum PlatformRendererError {\n    #[error(\"CoreGraphics context creation failed: {0}\")]\n    CoreGraphicsInit(String),\n\n    #[error(\"DirectWrite factory creation failed: {0}\")]\n    DirectWriteInit(String),\n\n    #[error(\"GPU acceleration unavailable\")]\n    GPUUnavailable,\n\n    #[error(\"Font not found in system: {0}\")]\n    FontNotFound(String),\n}\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#performance-tips","level":2,"title":"Performance Tips","text":"","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#macos-coregraphics_1","level":3,"title":"macOS (CoreGraphics)","text":"<ol> <li>Enable Metal for large text</li> <li>Use proper color spaces</li> <li>Leverage Retina optimization</li> <li>Cache CGContext objects</li> </ol>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#windows-directwrite_1","level":3,"title":"Windows (DirectWrite)","text":"<ol> <li>Enable ClearType for LCD displays</li> <li>Set DPI awareness for scaling</li> <li>Use Direct2D for complex rendering</li> <li>Cache text format objects</li> </ol>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#memory-management","level":2,"title":"Memory Management","text":"","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#coregraphics","level":3,"title":"CoreGraphics","text":"<pre><code>// Automatic memory management with ARC\n// Manual buffer management for performance\nrenderer.buffer_pool_enabled(true);\n\n// GPU memory optimization\nrenderer.optimize_gpu_memory(true);\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#directwrite","level":3,"title":"DirectWrite","text":"<pre><code>// COM object lifetime management\nrenderer.set_com_threading(ComThreadingMode::Multi);\n\n// Texture sharing with GPU\nrenderer.enable_texture_sharing(true);\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#integration-examples","level":2,"title":"Integration Examples","text":"","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#macos-integration","level":3,"title":"macOS Integration","text":"<pre><code>// Render to NSImage\nlet ns_image = renderer.render_to_nsimage(text, &amp;font, size)?;\n\n// Core Animation layer\nlet layer = renderer.render_to_calayer(text, &amp;font, rect)?;\n\n// Metal texture\nlet metal_texture = renderer.render_to_metal_texture(text, &amp;font)?;\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#windows-integration","level":3,"title":"Windows Integration","text":"<pre><code>// Render to HBITMAP\nlet bitmap = renderer.render_to_hbitmap(text, &amp;font, size)?;\n\n// Direct2D surface\nlet surface = renderer.render_to_d2d_surface(text, &amp;font, rect)?;\n\n// DirectX texture\nlet dx_texture = renderer.render_to_dx_texture(text, &amp;font)?;\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#testing-platform-differences","level":2,"title":"Testing Platform Differences","text":"<pre><code>#[test]\nfn test_platform_consistency() {\n    let text = \"Hello World\";\n    let font = load_roboto_font();\n\n    #[cfg(target_os = \"macos\")]\n    let cg_result = coregraphics_renderer.render(text, &amp;font);\n\n    #[cfg(target_os = \"windows\")]\n    let dw_result = directwrite_renderer.render(text, &amp;font);\n\n    // Compare with software fallback\n    let orge_result = orge_renderer.render(text, &amp;font);\n\n    // Results should be visually similar\n    assert!(images_similar(&amp;cg_result, &amp;orge_result));\n}\n</code></pre>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"15-platform-renderers/#migration","level":2,"title":"Migration","text":"<p>Switch from software rendering:</p> <pre><code>// Before - Orge renderer\nlet mut renderer = OrgeRenderer::new(width, height)?;\n\n// After - Platform renderer\n#[cfg(target_os = \"macos\")]\nlet mut renderer = CoreGraphicsRenderer::new(width, height)?;\n\n#[cfg(target_os = \"windows\")]\nlet mut renderer = DirectWriteRenderer::new(width, height)?;\n</code></pre> <p>Benchmark before switching to ensure performance gains:</p> <pre><code>fn benchmark_renderers() {\n    let text = \"Performance test text\";\n    let iterations = 1000;\n\n    // Test software renderer\n    let software_time = benchmark(|| {\n        orge_renderer.render(text, &amp;font)\n    }, iterations);\n\n    // Test platform renderer\n    let platform_time = benchmark(|| {\n        platform_renderer.render(text, &amp;font)\n    }, iterations);\n\n    let speedup = software_time.as_millis() / platform_time.as_millis();\n    println!(\"Platform renderer {}x faster\", speedup);\n}\n</code></pre> <p>Platform renderers give you the best performance and visual quality by leveraging your operating system's native graphics capabilities. Use them for desktop applications where system integration matters.</p>","path":["Rendering Backends","Platform Renderers"],"tags":[]},{"location":"16-zeno-renderer/","level":1,"title":"Zeno Renderer","text":"<p>Zeno renders high-quality vector graphics with precise curve handling and smooth gradients.</p>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#what-zeno-does","level":2,"title":"What Zeno Does","text":"<p>Zeno transforms shaped glyphs into vector paths with: - Exact Bézier curve preservation - Anti-aliased edge rendering - Gradient and transparency support - Subpixel precision positioning</p> <pre><code>#[cfg(feature = \"render-zeno\")]\npub struct ZenoRenderer {\n    canvas: Canvas,\n    transform: Transform,\n    stroke_width: f32,\n    fill_rule: FillRule,\n}\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#when-to-use-zeno","level":2,"title":"When to Use Zeno","text":"<p>Choose Zeno when you need: - Vector output (SVG, PDF) - High-quality printed typography - Complex visual effects - Precise curve control</p> <p>Skip Zeno for: - Simple bitmap rendering - Maximum speed requirements - Minimal binary size</p>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#performance-profile","level":2,"title":"Performance Profile","text":"Task Skia Orge Zeno Small text (12pt) 0.8ms 0.3ms 1.2ms Medium text (24pt) 1.5ms 0.7ms 2.1ms Large text (48pt) 3.2ms 1.8ms 3.8ms Vector export 0.5ms N/A 0.3ms <p>Zeno excels at vector export quality but is slower than raster renderers.</p>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#basic-usage","level":2,"title":"Basic Usage","text":"<pre><code>use typf_core::traits::Renderer;\nuse backends::typf_render_zeno::ZenoRenderer;\n\n// Create renderer\nlet mut renderer = ZenoRenderer::new(width, height)?;\nrenderer.set_quality(RenderQuality::High);\n\n// Render text\nlet result = renderer.render(shaped_text, &amp;font)?;\n\n// Export to SVG\nlet svg_bytes = renderer.export_svg(&amp;result)?;\n</code></pre> <pre><code>import typf\n\n# Use Zeno for vector output\nrenderer = typf.Typf(renderer=\"zeno\")\nresult = renderer.render_text(\"Hello World\", \"font.ttf\", \n                              output_format=\"svg\")\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#quality-settings","level":2,"title":"Quality Settings","text":"","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#render-quality","level":3,"title":"Render Quality","text":"<pre><code>#[derive(Debug, Clone, Copy)]\npub enum RenderQuality {\n    Draft,      // Fast, lower precision\n    Normal,     // Balance of speed/quality\n    High,       // Maximum precision\n    Print,      // Print-optimized curves\n}\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#anti-aliasing","level":3,"title":"Anti-aliasing","text":"<pre><code>// Anti-aliasing levels\nrenderer.set_antialiasing(AntialiasingLevel::None);     // No AA\nrenderer.set_antialiasing(AntialiasingLevel::Low);      // 2x supersample\nrenderer.set_antialiasing(AntialiasingLevel::Medium);   // 4x supersample\nrenderer.set_antialiasing(AntialiasingLevel::High);     // 8x supersample\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#advanced-rendering","level":2,"title":"Advanced Rendering","text":"","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#stroke-effects","level":3,"title":"Stroke Effects","text":"<pre><code>// Custom stroke styling\nlet stroke_options = StrokeOptions {\n    width: 2.0,\n    line_cap: LineCap::Round,\n    line_join: LineJoin::Round,\n    dash_array: vec![5.0, 3.0],\n    dash_offset: 0.0,\n};\nrenderer.set_stroke_options(stroke_options);\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#fill-patterns","level":3,"title":"Fill Patterns","text":"<pre><code>// Gradient fills\nlet gradient = LinearGradient::new(\n    Point::new(0.0, 0.0),\n    Point::new(width as f32, height as f32),\n    vec![\n        ColorStop::new(0.0, Color::rgb(255, 0, 0)),\n        ColorStop::new(1.0, Color::rgb(0, 0, 255)),\n    ],\n);\nrenderer.set_fill_pattern(FillPattern::Linear(gradient));\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#filters-and-effects","level":3,"title":"Filters and Effects","text":"<pre><code>// Drop shadow\nlet shadow = DropShadow {\n    offset: Vector::new(2.0, 2.0),\n    blur_radius: 3.0,\n    color: Color::rgba(0, 0, 0, 128),\n};\nrenderer.add_effect(Box::new(shadow));\n\n// Glow effect\nlet glow = Glow {\n    radius: 5.0,\n    color: Color::rgba(255, 255, 0, 64),\n};\nrenderer.add_effect(Box::new(glow));\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#export-formats","level":2,"title":"Export Formats","text":"","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#svg-export","level":3,"title":"SVG Export","text":"<pre><code>// Export with optimizations\nlet svg_options = SvgOptions {\n    precision: 6,              // Decimal places\n    optimize_paths: true,      // Remove redundant points\n    embed_fonts: false,        // Reference external fonts\n    pretty_print: true,        // Human-readable output\n};\n\nlet svg_content = renderer.export_svg_with_options(&amp;result, svg_options)?;\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#pdf-export","level":3,"title":"PDF Export","text":"<pre><code>// PDF for print\nlet pdf_options = PdfOptions {\n    dpi: 300,                  // Print resolution\n    embed_fonts: true,         // Include font subsets\n    compress: true,            // Compress content\n    version: PdfVersion::V1_7, // PDF version\n};\n\nlet pdf_bytes = renderer.export_pdf(&amp;result, pdf_options)?;\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#precision-control","level":2,"title":"Precision Control","text":"","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#coordinate-precision","level":3,"title":"Coordinate Precision","text":"<pre><code>// Set precision for different use cases\nrenderer.set_coordinate_precision(6);    // Web graphics\nrenderer.set_coordinate_precision(8);    // Desktop apps  \nrenderer.set_coordinate_precision(12);   // Print quality\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#curve-optimization","level":3,"title":"Curve Optimization","text":"<pre><code>// Curve tolerance for simplification\nlet curve_options = CurveOptions {\n    tolerance: 0.01,           // Maximum deviation\n    min_segments: 4,           // Minimum curve segments\n    max_segments: 100,         // Maximum curve segments\n    preserve_corners: true,    // Keep sharp corners\n};\nrenderer.set_curve_options(curve_options);\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#memory-management","level":2,"title":"Memory Management","text":"","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#canvas-pooling","level":3,"title":"Canvas Pooling","text":"<pre><code>// Reuse canvases for better performance\nlet canvas_pool = CanvasPool::new(10);    // Pool of 10 canvases\nrenderer.set_canvas_pool(canvas_pool);\n\n// Clear pool when done\nrenderer.clear_canvas_pool();\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#buffer-management","level":3,"title":"Buffer Management","text":"<pre><code>// Optimize buffer sizes\nrenderer.set_buffer_size(BufferSize::Auto);     // Auto-detect\nrenderer.set_buffer_size(BufferSize::Fixed(4096)); // 4KB buffers\nrenderer.set_buffer_size(BufferSize::Huge(65536));  // 64KB buffers\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#error-handling","level":2,"title":"Error Handling","text":"<pre><code>#[derive(Debug, thiserror::Error)]\npub enum ZenoRendererError {\n    #[error(\"Canvas creation failed: {0}\")]\n    CanvasCreation(String),\n\n    #[error(\"Invalid curve parameters: {0}\")]\n    InvalidCurve(String),\n\n    #[error(\"Export format not supported: {0}\")]\n    UnsupportedExport(String),\n\n    #[error(\"Memory allocation failed: {0}\")]\n    MemoryError(String),\n}\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#integration-examples","level":2,"title":"Integration Examples","text":"","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#web-graphics","level":3,"title":"Web Graphics","text":"<pre><code>// Generate SVG for web pages\nlet web_renderer = ZenoRenderer::new(800, 600)?;\nweb_renderer.set_quality(RenderQuality::Normal);\nweb_renderer.set_coordinate_precision(6);\n\nlet svg = web_renderer.export_svg(&amp;result)?;\nweb_page.insert_svg(&amp;svg, \"#text-container\");\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#print-production","level":3,"title":"Print Production","text":"<pre><code>// High-quality PDF for printing\nlet print_renderer = ZenoRenderer::new(2400, 3300)?; // 8\" x 11\" at 300 DPI\nprint_renderer.set_quality(RenderQuality::Print);\nprint_renderer.set_coordinate_precision(12);\n\nlet pdf = print_renderer.export_pdf(&amp;result, pdf_options)?;\nsend_to_printer(&amp;pdf);\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#desktop-applications","level":3,"title":"Desktop Applications","text":"<pre><code>// Render to window surface\nlet window_renderer = ZenoRenderer::new(window_width, window_height)?;\nwindow_renderer.set_quality(RenderQuality::High);\n\nlet frame = window_renderer.render_frame(&amp;result)?;\nwindow_surface.display_frame(&amp;frame);\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#performance-optimization","level":2,"title":"Performance Optimization","text":"","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#batching","level":3,"title":"Batching","text":"<pre><code>// Group similar operations\nlet batch = renderer.begin_batch();\nfor glyph in glyphs {\n    batch.add_glyph(&amp;glyph);\n}\nlet result = batch.finish()?;\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#caching","level":3,"title":"Caching","text":"<pre><code>// Cache complex curves\nlet cache_key = format!(\"{}:{}:{}\", text, font_name, size);\nif let Some(cached) = renderer.get_cached_curve(&amp;cache_key) {\n    return cached;\n}\n\nlet curve = renderer.generate_curve(text, font, size)?;\nrenderer.cache_curve(cache_key, curve.clone());\nOk(curve)\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#testing","level":2,"title":"Testing","text":"","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#quality-tests","level":3,"title":"Quality Tests","text":"<pre><code>#[test]\nfn test_curve_precision() {\n    let renderer = ZenoRenderer::new(1000, 1000)?;\n    renderer.set_quality(RenderQuality::Print);\n\n    // Test complex curves\n    let complex_glyph = load_complex_glyph();\n    let result = renderer.render_glyph(&amp;complex_glyph)?;\n\n    // Verify curve smoothness\n    assert!(is_curve_smooth(&amp;result, tolerance: 0.001));\n}\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#export-tests","level":3,"title":"Export Tests","text":"<pre><code>#[test]\nfn test_svg_export() {\n    let renderer = ZenoRenderer::new(800, 600)?;\n    let result = renderer.render(sample_text, &amp;font)?;\n\n    let svg = renderer.export_svg(&amp;result)?;\n\n    // Verify SVG validity\n    assert!(is_valid_svg(&amp;svg));\n    assert!(svg.contains(r#\"&lt;svg\"#));\n    assert!(svg.contains(r#\"&lt;/svg&gt;\"#));\n}\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#migration","level":2,"title":"Migration","text":"","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#from-orge-renderer","level":3,"title":"From Orge Renderer","text":"<pre><code>// Before - Orge (raster only)\nlet orge = OrgeRenderer::new(width, height)?;\nlet bitmap = orge.render(text, &amp;font)?;\n\n// After - Zeno (vector + raster)\nlet zeno = ZenoRenderer::new(width, height)?;\nlet vector = zeno.render(text, &amp;font)?;\nlet bitmap = zeno.rasterize(&amp;vector)?; // Optional rasterization\n</code></pre>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"16-zeno-renderer/#from-skia","level":3,"title":"From Skia","text":"<pre><code>// Skia and Zeno have similar APIs\nlet renderer = ZenoRenderer::new(width, height)?;\nrenderer.set_quality(RenderQuality::High); // Similar to Skia quality\n\n// Most Skia options have Zeno equivalents\nrenderer.set_antialiasing(AntialiasingLevel::High); // Like Skia anti-aliasing\n</code></pre> <p>Zeno provides the highest quality vector rendering with precise curve control and advanced effects. Use it when visual quality matters more than raw speed.</p>","path":["Rendering Backends","Zeno Renderer"],"tags":[]},{"location":"17-export-formats/","level":1,"title":"Export Formats","text":"<p>TypF exports rendered text to multiple formats for different use cases.</p>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#available-formats","level":2,"title":"Available Formats","text":"Format Type Use Case Size Quality PNG Raster Web, documents Medium High SVG Vector Web, print Small Excellent PDF Vector Print, documents Small Excellent PNM Raster Testing, debugging Large Medium JSON Data Debugging, analysis Medium N/A","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#quick-export","level":2,"title":"Quick Export","text":"<pre><code>use typf_export::{PngExporter, SvgExporter, JsonExporter};\n\n// PNG for raster output\nlet png_exporter = PngExporter::new();\nlet png_bytes = png_exporter.export(&amp;render_output)?;\n\n// SVG for vector output  \nlet svg_exporter = SvgExporter::new();\nlet svg_string = svg_exporter.export(&amp;render_output)?;\n\n// JSON for debugging\nlet json_exporter = JsonExporter::new();\nlet json_string = json_exporter.export(&amp;render_output)?;\n</code></pre> <pre><code>import typf\n\n# Simple export\nrenderer = typf.Typf()\nrenderer.render_text(\"Hello\", \"font.ttf\", output=\"output.png\")\nrenderer.render_text(\"Hello\", \"font.ttf\", output=\"output.svg\") \nrenderer.render_text(\"Hello\", \"font.ttf\", output=\"output.json\")\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#png-export","level":2,"title":"PNG Export","text":"<p>PNG provides compressed raster images with transparency support.</p>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#png-options","level":3,"title":"PNG Options","text":"<pre><code>pub struct PngOptions {\n    pub compression: CompressionLevel,\n    pub filter: FilterType,\n    pub color_type: ColorType,\n    pub bit_depth: BitDepth,\n}\n\nimpl PngOptions {\n    pub fn high_quality() -&gt; Self {\n        Self {\n            compression: CompressionLevel::Best,\n            filter: FilterType::Adaptive,\n            color_type: ColorType::RGBA,\n            bit_depth: BitDepth::Eight,\n        }\n    }\n\n    pub fn web_optimized() -&gt; Self {\n        Self {\n            compression: CompressionLevel::Fast,\n            filter: FilterType::Sub,\n            color_type: ColorType::RGB,\n            bit_depth: BitDepth::Eight,\n        }\n    }\n}\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#png-usage","level":3,"title":"PNG Usage","text":"<pre><code>// High quality PNG for print\nlet png_options = PngOptions::high_quality();\nlet png_bytes = png_exporter.export_with_options(&amp;output, png_options)?;\n\n// Fast PNG for web\nlet web_options = PngOptions::web_optimized();\nlet web_png = png_exporter.export_with_options(&amp;output, web_options)?;\n\n// PNG with custom DPI metadata\nlet mut png_exporter = PngExporter::new();\npng_exporter.set_dpi(300);\nlet print_png = png_exporter.export(&amp;output)?;\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#svg-export","level":2,"title":"SVG Export","text":"<p>SVG creates scalable vector graphics perfect for web and print.</p>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#svg-options","level":3,"title":"SVG Options","text":"<pre><code>pub struct SvgOptions {\n    pub precision: u32,           // Decimal places\n    pub optimize_paths: bool,     // Remove redundant points\n    pub embed_fonts: bool,        // Include font data\n    pub pretty_print: bool,       // Human-readable formatting\n    pub viewbox: Option&lt;Rect&gt;,    // Custom viewbox\n}\n\nimpl SvgOptions {\n    pub fn web() -&gt; Self {\n        Self {\n            precision: 6,\n            optimize_paths: true,\n            embed_fonts: false,\n            pretty_print: true,\n            viewbox: None,\n        }\n    }\n\n    pub fn standalone() -&gt; Self {\n        Self {\n            precision: 8,\n            optimize_paths: false,\n            embed_fonts: true,\n            pretty_print: true,\n            viewbox: None,\n        }\n    }\n}\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#svg-features","level":3,"title":"SVG Features","text":"<pre><code>// SVG with embedded fonts\nlet standalone_svg = SvgOptions::standalone();\nlet svg_content = svg_exporter.export_with_options(&amp;output, standalone_svg)?;\n\n// Optimized web SVG\nlet web_svg = SvgOptions::web();\nlet optimized = svg_exporter.export_with_options(&amp;output, web_svg)?;\n\n// SVG with custom dimensions\nlet mut custom_svg = SvgOptions::web();\ncustom_svg.viewbox = Some(Rect::new(0.0, 0.0, 800.0, 600.0));\nlet sized_svg = svg_exporter.export_with_options(&amp;output, custom_svg)?;\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#pdf-export","level":2,"title":"PDF Export","text":"<p>PDF generates print-ready documents with proper typography and fonts.</p>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#pdf-options","level":3,"title":"PDF Options","text":"<pre><code>pub struct PdfOptions {\n    pub page_size: PageSize,\n    pub margins: Margins,\n    pub embed_fonts: bool,\n    pub compress: bool,\n    pub version: PdfVersion,\n    pub metadata: Option&lt;DocumentMetadata&gt;,\n}\n\npub struct PageSize {\n    pub width: f64,\n    pub height: f64,\n    pub units: Units,\n}\n\npub struct Margins {\n    pub top: f64,\n    pub right: f64,\n    pub bottom: f64,\n    pub left: f64,\n    pub units: Units,\n}\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#pdf-usage","level":3,"title":"PDF Usage","text":"<pre><code>// Standard letter size\nlet letter_opts = PdfOptions {\n    page_size: PageSize::letter(),\n    margins: Margins::inches(0.5, 0.5, 0.5, 0.5),\n    embed_fonts: true,\n    compress: true,\n    version: PdfVersion::V1_7,\n    metadata: None,\n};\n\nlet letter_pdf = pdf_exporter.export_with_options(&amp;output, letter_opts)?;\n\n// Custom page size\nlet custom_page = PdfOptions {\n    page_size: PageSize::new(210.0, 297.0, Units::Millimeters), // A4\n    margins: Margins::millimeters(10.0, 10.0, 10.0, 10.0),\n    embed_fonts: true,\n    compress: true,\n    version: PdfVersion::V1_7,\n    metadata: Some(DocumentMetadata {\n        title: \"Rendered Text\".to_string(),\n        author: \"TYPF\".to_string(),\n        subject: \"Text Rendering\".to_string(),\n    }),\n};\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#pnm-export","level":2,"title":"PNM Export","text":"<p>PNM provides simple uncompressed raster formats for testing.</p>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#pnm-types","level":3,"title":"PNM Types","text":"<pre><code>pub enum PnmFormat {\n    PBM,    // Portable bitmap (binary)\n    PGM,    // Portable grayscale (8-bit)\n    PPM,    // Portable pixmap (RGB)\n    PAM,    // Portable arbitrary map (RGBA)\n}\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#pnm-usage","level":3,"title":"PNM Usage","text":"<pre><code>// Binary bitmap (1-bit)\nlet pbm_exporter = PnmExporter::new(PnmFormat::PBM);\nlet pbm_bytes = pbm_exporter.export(&amp;output)?;\n\n// Grayscale image\nlet pgm_exporter = PnmExporter::new(PnmFormat::PGM);\nlet pgm_bytes = pgm_exporter.export(&amp;output)?;\n\n// Color image\nlet ppm_exporter = PnmExporter::new(PnmFormat::PPM);\nlet ppm_bytes = ppm_exporter.export(&amp;output)?;\n\n// RGBA with transparency\nlet pam_exporter = PnmExporter::new(PnmFormat::PAM);\nlet pam_bytes = pam_exporter.export(&amp;output)?;\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#json-export","level":2,"title":"JSON Export","text":"<p>JSON exports structured data for debugging and analysis.</p>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#json-content","level":3,"title":"JSON Content","text":"<pre><code>{\n  \"metadata\": {\n    \"width\": 800,\n    \"height\": 600,\n    \"format\": \"rgba\",\n    \"dpi\": 72\n  },\n  \"glyphs\": [\n    {\n      \"gid\": 1,\n      \"unicode\": \"H\",\n      \"x\": 0,\n      \"y\": 0,\n      \"width\": 45,\n      \"height\": 60,\n      \"advance\": 48\n    }\n  ],\n  \"image\": {\n    \"data\": \"base64-encoded-pixel-data\",\n    \"stride\": 3200\n  }\n}\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#json-usage","level":3,"title":"JSON Usage","text":"<pre><code>// Export with all metadata\nlet json_exporter = JsonExporter::new();\nlet full_json = json_exporter.export(&amp;output)?;\n\n// Export minimal data\nlet minimal_json = json_exporter.export_minimal(&amp;output)?;\n\n// Export with custom formatting\nlet pretty_json = json_exporter.export_pretty(&amp;output, 2)?;\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#format-selection","level":2,"title":"Format Selection","text":"<p>Choose the right format for your needs:</p>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#web-use","level":3,"title":"Web Use","text":"<ul> <li>PNG: For raster images with transparency</li> <li>SVG: For scalable icons and graphics</li> <li>Size: Prefer PNG for photos, SVG for text/shapes</li> </ul>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#print-production","level":3,"title":"Print Production","text":"<ul> <li>PDF: For final documents with proper fonts</li> <li>SVG: For vector graphics in design software</li> <li>High-DPI PNG: For raster images in layouts</li> </ul>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#developmenttesting","level":3,"title":"Development/Testing","text":"<ul> <li>JSON: For debugging and analysis</li> <li>PNM: Simple format for unit tests</li> <li>SVG: Easy to inspect in browsers</li> </ul>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#data-processing","level":3,"title":"Data Processing","text":"<ul> <li>JSON: Structured data for pipelines</li> <li>PNG: Compressed image data</li> <li>Raw buffers: For further processing</li> </ul>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#performance-comparison","level":2,"title":"Performance Comparison","text":"Format Export Speed File Size Memory PNG 15ms 45KB 8MB SVG 5ms 12KB 2MB PDF 25ms 18KB 6MB PNM 2ms 1.5MB 8MB JSON 8ms 89KB 4MB","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#advanced-configuration","level":2,"title":"Advanced Configuration","text":"","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#custom-exporters","level":3,"title":"Custom Exporters","text":"<pre><code>pub struct CustomExporter {\n    format: ExportFormat,\n    options: ExportOptions,\n}\n\nimpl Exporter for CustomExporter {\n    fn export(&amp;self, output: &amp;RenderOutput) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {\n        match self.format {\n            ExportFormat::Custom =&gt; self.custom_export(output),\n            _ =&gt; fallback_exporter().export(output),\n        }\n    }\n}\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#batch-export","level":3,"title":"Batch Export","text":"<pre><code>// Export to multiple formats\nlet batch_exporter = BatchExporter::new();\nbatch_exporter.add_format(PngExporter::new());\nbatch_exporter.add_format(SvgExporter::new());\nbatch_exporter.add_format(JsonExporter::new());\n\nlet results = batch_exporter.export_all(&amp;output)?;\n// Returns HashMap&lt;Format, Vec&lt;u8&gt;&gt;\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#streaming-export","level":3,"title":"Streaming Export","text":"<pre><code>// Export large images without loading entirely in memory\nlet streaming_exporter = StreamingPngExporter::new(file_path);\n\nstreaming_exporter.begin_image(width, height)?;\nfor row in image_rows() {\n    streaming_exporter.write_row(row)?;\n}\nstreaming_exporter.finish()?;\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#error-handling","level":2,"title":"Error Handling","text":"<pre><code>#[derive(Debug, thiserror::Error)]\npub enum ExportError {\n    #[error(\"Format not supported: {0}\")]\n    UnsupportedFormat(String),\n\n    #[error(\"Encoding failed: {0}\")]\n    EncodingError(String),\n\n    #[error(\"File write error: {0}\")]\n    FileError(std::io::Error),\n\n    #[error(\"Memory allocation failed\")]\n    OutOfMemory,\n\n    #[error(\"Invalid options: {0}\")]\n    InvalidOptions(String),\n}\n</code></pre>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"17-export-formats/#testing-exports","level":2,"title":"Testing Exports","text":"<pre><code>#[test]\nfn test_png_export_roundtrip() {\n    let exporter = PngExporter::new();\n    let original = create_test_output();\n\n    let png_bytes = exporter.export(&amp;original)?;\n    let loaded = load_png_from_bytes(&amp;png_bytes)?;\n\n    assert_images_equal(&amp;original, &amp;loaded);\n}\n\n#[test]\nfn test_svg_validity() {\n    let exporter = SvgExporter::new();\n    let output = create_test_output();\n\n    let svg_content = exporter.export(&amp;output)?;\n\n    // Verify valid XML\n    let doc = XmlDocument::parse(&amp;svg_content).unwrap();\n    assert_eq!(doc.root_tag(), \"svg\");\n\n    // Verify paths present\n    assert!(svg_content.contains(\"&lt;path\"));\n}\n\n#[test]\nfn test_json_structure() {\n    let exporter = JsonExporter::new();\n    let output = create_test_output();\n\n    let json = exporter.export(&amp;output)?;\n    let parsed: serde_json::Value = serde_json::from_str(&amp;json)?;\n\n    assert!(parsed[\"metadata\"].is_object());\n    assert!(parsed[\"glyphs\"].is_array());\n    assert!(parsed[\"image\"].is_object());\n}\n</code></pre> <p>Export formats let you deliver rendered text exactly where it's needed. Pick the right format for your use case and configure the options for optimal results.</p>","path":["Output & Export","Export Formats"],"tags":[]},{"location":"18-rust-api/","level":1,"title":"Rust API","text":"<p>TYPF's Rust API provides high-performance text rendering with zero-copy operations and compile-time safety.</p>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#quick-start","level":2,"title":"Quick Start","text":"<pre><code>use typf::{Pipeline, PipelineBuilder};\n\n// Build a rendering pipeline\nlet mut pipeline = PipelineBuilder::new()\n    .with_shaper(\"harfbuzz\")?\n    .with_renderer(\"orge\")?\n    .build();\n\n// Render text\nlet result = pipeline.render_text(\"Hello World\", \"font.ttf\")?;\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#core-types","level":2,"title":"Core Types","text":"","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#pipeline","level":3,"title":"Pipeline","text":"<p>The main interface for text rendering operations.</p> <pre><code>pub struct Pipeline {\n    shaper: Arc&lt;dyn Shaper&gt;,\n    renderer: Arc&lt;dyn Renderer&gt;,\n    font_db: Arc&lt;FontDatabase&gt;,\n    cache: Arc&lt;RenderCache&gt;,\n}\n\nimpl Pipeline {\n    /// Create a new pipeline with defaults\n    pub fn new() -&gt; Result&lt;Self&gt;;\n\n    /// Render text to bitmap\n    pub fn render_text(&amp;mut self, text: &amp;str, font_path: &amp;str) \n        -&gt; Result&lt;RenderOutput&gt;;\n\n    /// Render with custom settings\n    pub fn render_with_options(&amp;mut self, \n        text: &amp;str, \n        font_path: &amp;str,\n        options: &amp;RenderOptions\n    ) -&gt; Result&lt;RenderOutput&gt;;\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#pipelinebuilder","level":3,"title":"PipelineBuilder","text":"<p>Configure your rendering pipeline with the builder pattern.</p> <pre><code>pub struct PipelineBuilder {\n    shaper: Option&lt;Arc&lt;dyn Shaper&gt;&gt;,\n    renderer: Option&lt;Arc&lt;dyn Renderer&gt;&gt;,\n    font_db: Option&lt;Arc&lt;FontDatabase&gt;&gt;,\n    cache: Option&lt;Arc&lt;RenderCache&gt;&gt;,\n}\n\nimpl PipelineBuilder {\n    pub fn new() -&gt; Self;\n\n    /// Select shaping backend\n    pub fn with_shaper(mut self, name: &amp;str) -&gt; Result&lt;Self&gt;;\n\n    /// Select rendering backend  \n    pub fn with_renderer(mut self, name: &amp;str) -&gt; Result&lt;Self&gt;;\n\n    /// Configure font database\n    pub fn with_font_db(mut self, db: FontDatabase) -&gt; Self;\n\n    /// Set up cache\n    pub fn with_cache(mut self, cache: RenderCache) -&gt; Self;\n\n    /// Build the pipeline\n    pub fn build(self) -&gt; Result&lt;Pipeline&gt;;\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#rendering-configuration","level":2,"title":"Rendering Configuration","text":"","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#renderoptions","level":3,"title":"RenderOptions","text":"<p>Control how text gets rendered.</p> <pre><code>pub struct RenderOptions {\n    pub font_size: f32,           // Size in pixels\n    pub dpi: f32,                 // Output resolution\n    pub width: u32,               // Image width\n    pub height: u32,              // Image height\n    pub color: Color,             // Text color\n    pub background: Color,        // Background color\n    pub hinting: HintingMode,     // Font hinting\n    pub antialiasing: bool,       // Edge smoothing\n}\n\nimpl Default for RenderOptions {\n    fn default() -&gt; Self {\n        Self {\n            font_size: 16.0,\n            dpi: 72.0,\n            width: 800,\n            height: 600,\n            color: Color::BLACK,\n            background: Color::TRANSPARENT,\n            hinting: HintingMode::Normal,\n            antialiasing: true,\n        }\n    }\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#color","level":3,"title":"Color","text":"<p>RGBA color with alpha support.</p> <pre><code>#[derive(Debug, Clone, Copy, PartialEq)]\npub struct Color {\n    pub r: u8,\n    pub g: u8, \n    pub b: u8,\n    pub a: u8,\n}\n\nimpl Color {\n    pub const BLACK: Color = Color { r: 0, g: 0, b: 0, a: 255 };\n    pub const WHITE: Color = Color { r: 255, g: 255, b: 255, a: 255 };\n    pub const TRANSPARENT: Color = Color { r: 0, g: 0, b: 0, a: 0 };\n\n    pub fn rgb(r: u8, g: u8, b: u8) -&gt; Self {\n        Self { r, g, b, a: 255 }\n    }\n\n    pub fn rgba(r: u8, g: u8, b: u8, a: u8) -&gt; Self {\n        Self { r, g, b, a }\n    }\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#output-types","level":2,"title":"Output Types","text":"","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#renderoutput","level":3,"title":"RenderOutput","text":"<p>The result of a rendering operation.</p> <pre><code>pub struct RenderOutput {\n    pub bitmap: BitmapData,       // Pixel data\n    pub metadata: RenderMetadata, // Rendering info\n    pub glyphs: Vec&lt;GlyphInfo&gt;,   // Glyph positions\n}\n\npub struct BitmapData {\n    pub width: u32,\n    pub height: u32,\n    pub stride: u32,              // Bytes per row\n    pub format: PixelFormat,      // Color format\n    pub data: Vec&lt;u8&gt;,            // Raw pixel data\n}\n\npub enum PixelFormat {\n    Gray,                         // 8-bit grayscale\n    GrayAlpha,                    // 8-bit gray + 8-bit alpha\n    RGB,                          // 24-bit RGB\n    RGBA,                         // 32-bit RGBA\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#glyphinfo","level":3,"title":"GlyphInfo","text":"<p>Information about each rendered glyph.</p> <pre><code>pub struct GlyphInfo {\n    pub glyph_id: u32,            // Glyph index in font\n    pub codepoint: u32,           // Unicode character\n    pub x: f32,                   // X position\n    pub y: f32,                   // Y position\n    pub width: f32,               // Glyph width\n    pub height: f32,              // Glyph height\n    pub advance: f32,             // X advance to next glyph\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#font-management","level":2,"title":"Font Management","text":"","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#fontdatabase","level":3,"title":"FontDatabase","text":"<p>Load and manage fonts efficiently.</p> <pre><code>pub struct FontDatabase {\n    fonts: DashMap&lt;String, Arc&lt;Font&gt;&gt;,\n    system_fonts: bool,\n}\n\nimpl FontDatabase {\n    /// Create empty database\n    pub fn new() -&gt; Self;\n\n    /// Create with system fonts\n    pub fn with_system_fonts() -&gt; Result&lt;Self&gt;;\n\n    /// Load font from file\n    pub fn load_font(&amp;self, path: &amp;str) -&gt; Result&lt;Arc&lt;Font&gt;&gt;;\n\n    /// Load font from bytes\n    pub fn load_font_bytes(&amp;self, \n        name: &amp;str, \n        data: Vec&lt;u8&gt;\n    ) -&gt; Result&lt;Arc&lt;Font&gt;&gt;;\n\n    /// Get font by name\n    pub fn get_font(&amp;self, name: &amp;str) -&gt; Option&lt;Arc&lt;Font&gt;&gt;;\n\n    /// List available fonts\n    pub fn list_fonts(&amp;self) -&gt; Vec&lt;String&gt;;\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#font","level":3,"title":"Font","text":"<p>Represents a loaded font.</p> <pre><code>pub struct Font {\n    pub name: String,\n    pub family: String,\n    pub style: FontStyle,\n    pub metrics: FontMetrics,\n    data: &amp;'static [u8],          // Memory-mapped font data\n}\n\npub struct FontMetrics {\n    pub ascender: f32,            // Height of ascender\n    pub descender: f32,           // Depth of descender  \n    pub line_gap: f32,            // Space between lines\n    pub units_per_em: u16,        // Font design units\n}\n\npub enum FontStyle {\n    Normal,\n    Italic,\n    Oblique,\n    Bold,\n    BoldItalic,\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#shaping-backends","level":2,"title":"Shaping Backends","text":"","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#shaper-trait","level":3,"title":"Shaper Trait","text":"<p>All shapers implement this trait.</p> <pre><code>pub trait Shaper: Send + Sync {\n    /// Shape text into glyphs\n    fn shape(&amp;self, \n        text: &amp;str, \n        font: &amp;Font, \n        options: &amp;ShapeOptions\n    ) -&gt; Result&lt;ShapingResult&gt;;\n\n    /// Get shaper name\n    fn name(&amp;self) -&gt; &amp;str;\n\n    /// Check if script is supported\n    fn supports_script(&amp;self, script: UnicodeScript) -&gt; bool;\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#shapingresult","level":3,"title":"ShapingResult","text":"<p>Output from the shaping stage.</p> <pre><code>pub struct ShapingResult {\n    pub glyphs: Vec&lt;PositionedGlyph&gt;,\n    pub clusters: Vec&lt;TextCluster&gt;,\n    pub direction: TextDirection,\n    pub script: UnicodeScript,\n}\n\npub struct PositionedGlyph {\n    pub glyph_id: u32,\n    pub x_offset: f32,\n    pub y_offset: f32,\n    pub x_advance: f32,\n    pub y_advance: f32,\n    pub cluster: u32,\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#rendering-backends","level":2,"title":"Rendering Backends","text":"","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#renderer-trait","level":3,"title":"Renderer Trait","text":"<p>All renderers implement this trait.</p> <pre><code>pub trait Renderer: Send + Sync {\n    /// Render shaped glyphs to bitmap\n    fn render(&amp;self,\n        glyphs: &amp;[PositionedGlyph],\n        font: &amp;Font,\n        options: &amp;RenderOptions\n    ) -&gt; Result&lt;BitmapData&gt;;\n\n    /// Get renderer name\n    fn name(&amp;self) -&gt; &amp;str;\n\n    /// Check if format is supported\n    fn supports_format(&amp;self, format: PixelFormat) -&gt; bool;\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#error-handling","level":2,"title":"Error Handling","text":"","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#typferror","level":3,"title":"TypfError","text":"<p>Comprehensive error type for all operations.</p> <pre><code>#[derive(Debug, thiserror::Error)]\npub enum TypfError {\n    #[error(\"Font loading failed: {0}\")]\n    FontLoad(String),\n\n    #[error(\"Shaping failed: {0}\")]  \n    Shaping(String),\n\n    #[error(\"Rendering failed: {0}\")]\n    Rendering(String),\n\n    #[error(\"Backend not available: {0}\")]\n    BackendUnavailable(String),\n\n    #[error(\"Invalid configuration: {0}\")]\n    InvalidConfig(String),\n\n    #[error(\"I/O error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#performance-features","level":2,"title":"Performance Features","text":"","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#rendercache","level":3,"title":"RenderCache","text":"<p>Cache rendered text for repeated use.</p> <pre><code>pub struct RenderCache {\n    glyph_cache: LruCache&lt;GlyphKey, BitmapData&gt;,\n    text_cache: LruCache&lt;TextKey, RenderOutput&gt;,\n    max_memory: usize,\n}\n\nimpl RenderCache {\n    /// Create cache with memory limit\n    pub fn new(max_memory: usize) -&gt; Self;\n\n    /// Get cached glyph\n    pub fn get_glyph(&amp;self, key: &amp;GlyphKey) -&gt; Option&lt;BitmapData&gt;;\n\n    /// Cache glyph data\n    pub fn put_glyph(&amp;mut self, key: GlyphKey, data: BitmapData);\n\n    /// Get cached text\n    pub fn get_text(&amp;self, key: &amp;TextKey) -&gt; Option&lt;RenderOutput&gt;;\n\n    /// Cache text result\n    pub fn put_text(&amp;mut self, key: TextKey, output: RenderOutput);\n\n    /// Clear all cached data\n    pub fn clear(&amp;mut self);\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#parallel-processing","level":3,"title":"Parallel Processing","text":"<p>Render multiple texts concurrently.</p> <pre><code>use rayon::prelude::*;\n\n// Parallel batch rendering\nlet texts = vec![\"Hello\", \"World\", \"TYPF\"];\nlet results: Vec&lt;Result&lt;RenderOutput&gt;&gt; = texts\n    .par_iter()\n    .map(|text| pipeline.render_text(text, \"font.ttf\"))\n    .collect();\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#advanced-usage","level":2,"title":"Advanced Usage","text":"","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#custom-shapers","level":3,"title":"Custom Shapers","text":"<pre><code>struct CustomShaper {\n    // Your shaping logic\n}\n\nimpl Shaper for CustomShaper {\n    fn shape(&amp;self, \n        text: &amp;str, \n        font: &amp;Font, \n        options: &amp;ShapeOptions\n    ) -&gt; Result&lt;ShapingResult&gt; {\n        // Implement custom shaping\n        todo!()\n    }\n\n    fn name(&amp;self) -&gt; &amp;str {\n        \"custom\"\n    }\n}\n\n// Register with pipeline\nlet pipeline = PipelineBuilder::new()\n    .with_custom_shaper(Arc::new(CustomShaper::new()))\n    .build()?;\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#custom-renderers","level":3,"title":"Custom Renderers","text":"<pre><code>struct CustomRenderer {\n    // Your rendering logic\n}\n\nimpl Renderer for CustomRenderer {\n    fn render(&amp;self,\n        glyphs: &amp;[PositionedGlyph],\n        font: &amp;Font,  \n        options: &amp;RenderOptions\n    ) -&gt; Result&lt;BitmapData&gt; {\n        // Implement custom rendering\n        todo!()\n    }\n\n    fn name(&amp;self) -&gt; &amp;str {\n        \"custom\"\n    }\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#feature-flags","level":2,"title":"Feature Flags","text":"<p>Control what gets compiled:</p> <pre><code>[dependencies.typf]\nfeatures = [\n    \"shaping-harfbuzz\",     # HarfBuzz text shaping\n    \"render-orge\",          # Orge rasterizer\n    \"render-skia\",          # Skia renderer\n    \"export-png\",           # PNG export\n    \"export-svg\",           # SVG export\n    \"system-fonts\",         # System font discovery\n    \"fontdb\",               # Font database\n    \"cache\",                # Caching system\n]\n</code></pre> <p>Minimal build:</p> <pre><code>[dependencies.typf]\nfeatures = [\n    \"shaping-none\",         # No shaping (identity only)\n    \"render-orge\",          # Basic rasterizer\n    \"export-pnm\",           # PNM export for testing\n]\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#examples","level":2,"title":"Examples","text":"","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#basic-text-rendering","level":3,"title":"Basic Text Rendering","text":"<pre><code>use typf::{Pipeline, RenderOptions, Color};\n\nfn main() -&gt; Result&lt;()&gt; {\n    let mut pipeline = Pipeline::new()?;\n\n    let options = RenderOptions {\n        font_size: 24.0,\n        width: 400,\n        height: 100,\n        color: Color::BLACK,\n        background: Color::WHITE,\n        ..Default::default()\n    };\n\n    let result = pipeline.render_with_options(\n        \"Hello TYPF!\", \n        \"Roboto-Regular.ttf\",\n        &amp;options\n    )?;\n\n    println!(\"Rendered {}x{} image\", \n        result.bitmap.width, \n        result.bitmap.height);\n\n    Ok(())\n}\n</code></pre>","path":["API Reference","Rust API"],"tags":[]},{"location":"18-rust-api/#batch-processing","level":3,"title":"Batch Processing","text":"<pre><code>use typf::{Pipeline, FontDatabase};\n\nfn process_texts(texts: &amp;[String]) -&gt; Result&lt;Vec&lt;RenderOutput&gt;&gt; {\n    let font_db = FontDatabase::with_system_fonts()?;\n    let mut pipeline = PipelineBuilder::new()\n        .with_font_db(font_db)\n        .build()?;\n\n    let mut results = Vec::new();\n\n    for text in texts {\n        let result = pipeline.render_text(text, \"Arial\")?;\n        results.push(result);\n    }\n\n    Ok(results)\n}\n</code></pre> <p>The Rust API gives you maximum control over the text rendering pipeline with zero-copy operations and compile-time safety. Use the builder pattern to configure exactly what you need.</p>","path":["API Reference","Rust API"],"tags":[]},{"location":"19-python-api/","level":1,"title":"Python API","text":"<p>TYPF's Python bindings bring high-performance text rendering to Python with the same speed as the Rust implementation.</p>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#quick-start","level":2,"title":"Quick Start","text":"<pre><code>import typf\n\n# Simple text rendering\nrenderer = typf.Typf()\nresult = renderer.render_text(\"Hello World\", \"font.ttf\")\n\n# Save to different formats\nresult.save(\"output.png\")\nresult.save(\"output.svg\") \nresult.save(\"output.pdf\")\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#installation","level":2,"title":"Installation","text":"<pre><code># Install from PyPI\npip install typf\n\n# Or build from source with specific features\npip install typf --features=\"shaping-harfbuzz,render-skia\"\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#core-classes","level":2,"title":"Core Classes","text":"","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#typf","level":3,"title":"Typf","text":"<p>Main class for text rendering operations.</p> <pre><code>class Typf:\n    def __init__(self, \n                 shaper: str = \"harfbuzz\",\n                 renderer: str = \"orge\",\n                 font_db: Optional[FontDatabase] = None):\n        \"\"\"Initialize renderer with backends.\"\"\"\n\n    def render_text(self, \n                    text: str, \n                    font_path: str,\n                    font_size: float = 16.0,\n                    width: int = 800,\n                    height: int = 600,\n                    **kwargs) -&gt; RenderResult:\n        \"\"\"Render text to bitmap.\"\"\"\n\n    def render_with_options(self,\n                           text: str,\n                           font_path: str,\n                           options: RenderOptions) -&gt; RenderResult:\n        \"\"\"Render with custom options.\"\"\"\n\n    def list_backends(self) -&gt; Dict[str, List[str]]:\n        \"\"\"Get available backends.\"\"\"\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#renderresult","level":3,"title":"RenderResult","text":"<p>Contains the rendered output and metadata.</p> <pre><code>class RenderResult:\n    @property\n    def width(self) -&gt; int:\n        \"\"\"Image width in pixels.\"\"\"\n\n    @property  \n    def height(self) -&gt; int:\n        \"\"\"Image height in pixels.\"\"\"\n\n    @property\n    def glyph_count(self) -&gt; int:\n        \"\"\"Number of glyphs rendered.\"\"\"\n\n    def save(self, filename: str, format: Optional[str] = None):\n        \"\"\"Save to file. Format inferred from extension.\"\"\"\n\n    def to_bytes(self, format: str) -&gt; bytes:\n        \"\"\"Get encoded bytes.\"\"\"\n\n    def get_pixels(self) -&gt; numpy.ndarray:\n        \"\"\"Get pixel data as NumPy array.\"\"\"\n\n    def get_glyphs(self) -&gt; List[GlyphInfo]:\n        \"\"\"Get glyph positioning info.\"\"\"\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#renderoptions","level":3,"title":"RenderOptions","text":"<p>Configure rendering parameters.</p> <pre><code>@dataclass\nclass RenderOptions:\n    font_size: float = 16.0\n    dpi: float = 72.0\n    width: int = 800\n    height: int = 600\n    color: Tuple[int, int, int, int] = (0, 0, 0, 255)\n    background: Tuple[int, int, int, int] = (255, 255, 255, 0)\n    hinting: str = \"normal\"\n    antialiasing: bool = True\n\n    # Advanced options\n    subpixel_positioning: bool = True\n    embolden: float = 0.0\n    slant: float = 0.0\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#font-management","level":2,"title":"Font Management","text":"","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#fontdatabase","level":3,"title":"FontDatabase","text":"<p>Load and manage fonts efficiently.</p> <pre><code>class FontDatabase:\n    def __init__(self, include_system: bool = True):\n        \"\"\"Create font database.\"\"\"\n\n    def load_font(self, path: str) -&gt; Font:\n        \"\"\"Load font from file path.\"\"\"\n\n    def load_font_bytes(self, name: str, data: bytes) -&gt; Font:\n        \"\"\"Load font from bytes.\"\"\"\n\n    def get_font(self, name: str) -&gt; Optional[Font]:\n        \"\"\"Get font by name.\"\"\"\n\n    def list_fonts(self) -&gt; List[str]:\n        \"\"\"List available font names.\"\"\"\n\n    def search_family(self, family: str) -&gt; List[Font]:\n        \"\"\"Find fonts in same family.\"\"\"\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#font","level":3,"title":"Font","text":"<p>Represents a loaded font.</p> <pre><code>class Font:\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Font full name.\"\"\"\n\n    @property\n    def family(self) -&gt; str:\n        \"\"\"Font family name.\"\"\"\n\n    @property\n    def style(self) -&gt; str:\n        \"\"\"Font style (normal, italic, bold, etc.).\"\"\"\n\n    @property\n    def metrics(self) -&gt; FontMetrics:\n        \"\"\"Font measurements.\"\"\"\n\n    def supports_glyph(self, codepoint: int) -&gt; bool:\n        \"\"\"Check if font contains glyph.\"\"\"\n\n    def get_glyph_advance(self, glyph_id: int) -&gt; float:\n        \"\"\"Get glyph advance width.\"\"\"\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#backends-selection","level":2,"title":"Backends Selection","text":"","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#available-shapers","level":3,"title":"Available Shapers","text":"<pre><code># List available text shapers\nrenderer = typf.Typf()\nbackends = renderer.list_backends()\nprint(backends['shapers'])\n# ['none', 'harfbuzz', 'icu-harfbuzz', 'coretext', 'directwrite']\n\n# Use specific shaper\nhb_renderer = typf.Typf(shaper=\"harfbuzz\")\nicu_renderer = typf.Typf(shaper=\"icu-harfbuzz\")\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#available-renderers","level":3,"title":"Available Renderers","text":"<pre><code>print(backends['renderers'])  \n# ['orge', 'skia', 'coregraphics', 'directwrite', 'zeno']\n\n# Use specific renderer\nskia_renderer = typf.Typf(renderer=\"skia\")\nzeno_renderer = typf.Typf(renderer=\"zeno\")\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#backend-recommendations","level":3,"title":"Backend Recommendations","text":"Use Case Shaper Renderer Web graphics harfbuzz skia Print production icu-harfbuzz zeno Simple text none orge macOS apps coretext coregraphics Windows apps directwrite directwrite Cross-platform harfbuzz orge","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#color-and-formatting","level":2,"title":"Color and Formatting","text":"","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#colors","level":3,"title":"Colors","text":"<pre><code># RGBA tuples\nblack = (0, 0, 0, 255)\nred = (255, 0, 0, 255)\ntransparent = (0, 0, 0, 0)\n\n# Helper functions\ndef rgb(r, g, b):\n    return (r, g, b, 255)\n\ndef rgba(r, g, b, a):\n    return (r, g, b, a)\n\n# Use in rendering\noptions = typf.RenderOptions(\n    color=rgb(50, 100, 200),\n    background=rgba(255, 255, 255, 128)\n)\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#text-effects","level":3,"title":"Text Effects","text":"<pre><code># Embolden text\noptions = typf.RenderOptions(embolden=0.1)  # 10% bolder\n\n# Slant text  \noptions = typf.RenderOptions(slant=0.2)     # 20% slant\n\n# disable hinting for small text\noptions = typf.RenderOptions(\n    font_size=8.0,\n    hinting=\"none\"\n)\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#export-formats","level":2,"title":"Export Formats","text":"","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#supported-formats","level":3,"title":"Supported Formats","text":"<pre><code>result.save(\"image.png\")    # Raster image\nresult.save(\"vector.svg\")   # Vector graphics  \nresult.save(\"document.pdf\") # Print document\nresult.save(\"data.json\")    # Debug data\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#format-specific-options","level":3,"title":"Format-Specific Options","text":"<pre><code># PNG with compression\nresult.save(\"output.png\", quality=9)  # PNG compression level\n\n# SVG with embedded fonts\nresult.save(\"output.svg\", embed_fonts=True)\n\n# PDF with metadata\nresult.save(\"output.pdf\", \n           title=\"My Document\",\n           author=\"My Name\",\n           subject=\"Text Rendering\")\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#numpy-integration","level":2,"title":"NumPy Integration","text":"","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#get-pixel-data","level":3,"title":"Get Pixel Data","text":"<pre><code>import numpy as np\nimport typf\n\n# Render text\nrenderer = typf.Typf()\nresult = renderer.render_text(\"Hello NumPy\", \"font.ttf\")\n\n# Get as NumPy array\npixels = result.get_pixels()\nprint(pixels.shape)  # (height, width, 4) for RGBA\n\n# Process pixels\ngray = np.mean(pixels[:,:,:3], axis=2)  # Convert to grayscale\nblurred = gaussian_filter(gray, sigma=1.0)  # Apply filter\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#create-from-numpy","level":3,"title":"Create from NumPy","text":"<pre><code># Create from existing pixel data\ndef create_from_numpy(pixels: np.ndarray) -&gt; typf.RenderResult:\n    \"\"\"Create Result from NumPy array.\"\"\"\n    data = pixels.tobytes()\n    return typf.RenderResult.from_bytes(\n        data=data,\n        width=pixels.shape[1],\n        height=pixels.shape[0],\n        format=\"rgba\"\n    )\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#batch-processing","level":2,"title":"Batch Processing","text":"","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#render-multiple-texts","level":3,"title":"Render Multiple Texts","text":"<pre><code>def render_batch(texts: List[str], font_path: str) -&gt; List[typf.RenderResult]:\n    \"\"\"Render multiple texts efficiently.\"\"\"\n    renderer = typf.Typf()\n    results = []\n\n    for text in texts:\n        result = renderer.render_text(text, font_path)\n        results.append(result)\n\n    return results\n\n# Usage\ntexts = [\"Hello\", \"World\", \"TYPF\", \"Python\"]\nresults = render_batch(texts, \"Roboto-Regular.ttf\")\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#parallel-processing","level":3,"title":"Parallel Processing","text":"<pre><code>from concurrent.futures import ThreadPoolExecutor\nimport typf\n\ndef render_worker(args):\n    text, font_path = args\n    renderer = typf.Typf()\n    return renderer.render_text(text, font_path)\n\ndef parallel_render(texts: List[str], font_path: str, workers: int = 4):\n    \"\"\"Render texts in parallel.\"\"\"\n    with ThreadPoolExecutor(max_workers=workers) as executor:\n        args = [(text, font_path) for text in texts]\n        results = list(executor.map(render_worker, args))\n    return results\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#error-handling","level":2,"title":"Error Handling","text":"","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#exception-types","level":3,"title":"Exception Types","text":"<pre><code>try:\n    result = renderer.render_text(\"Hello\", \"nonexistent.ttf\")\nexcept typf.TypfError as e:\n    print(f\"TypF error: {e}\")\n\n# Specific error types\ntry:\n    result = renderer.render_text(\"Hello\", \"font.ttf\")\nexcept typf.FontError as e:\n    print(f\"Font loading failed: {e}\")\nexcept typf.RenderError as e:\n    print(f\"Rendering failed: {e}\")\nexcept typf.BackendError as e:\n    print(f\"Backend not available: {e}\")\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#best-practices","level":3,"title":"Best Practices","text":"<pre><code>def safe_render(text: str, font_path: str) -&gt; Optional[typf.RenderResult]:\n    \"\"\"Render with error handling.\"\"\"\n    try:\n        renderer = typf.Typf()\n        return renderer.render_text(text, font_path)\n    except typf.FontError:\n        print(f\"Could not load font: {font_path}\")\n        return None\n    except typf.RenderError as e:\n        print(f\"Rendering failed: {e}\")\n        return None\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return None\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#performance-tips","level":2,"title":"Performance Tips","text":"","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#caching","level":3,"title":"Caching","text":"<pre><code># Create renderer once, reuse many times\nclass TextRenderer:\n    def __init__(self):\n        self.renderer = typf.Typf(shaper=\"harfbuzz\", renderer=\"skia\")\n\n    def render(self, text: str, font_path: str) -&gt; typf.RenderResult:\n        return self.renderer.render_text(text, font_path)\n\n# Usage\nrenderer = TextRenderer()  # Initialize once\nfor text in texts:\n    result = renderer.render(text, \"font.ttf\")  # Reuse\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#memory-management","level":3,"title":"Memory Management","text":"<pre><code># Process large texts in chunks\ndef render_large_text(text: str, font_path: str, chunk_size: int = 1000):\n    \"\"\"Render text in manageable chunks.\"\"\"\n    renderer = typf.Typf()\n    results = []\n\n    for i in range(0, len(text), chunk_size):\n        chunk = text[i:i + chunk_size]\n        result = renderer.render_text(chunk, font_path)\n        results.append(result)\n\n    return results\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#async-support","level":3,"title":"Async Support","text":"<pre><code>import asyncio\nimport typf\n\nasync def render_async(texts: List[str], font_path: str):\n    \"\"\"Render texts asynchronously.\"\"\"\n    loop = asyncio.get_event_loop()\n\n    def render_text(text):\n        renderer = typf.Typf()\n        return renderer.render_text(text, font_path)\n\n    tasks = []\n    for text in texts:\n        task = loop.run_in_executor(None, render_text, text)\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n    return results\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#web-framework-integration","level":2,"title":"Web Framework Integration","text":"","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#flask-example","level":3,"title":"Flask Example","text":"<pre><code>from flask import Flask, send_file\nimport typf\nimport io\n\napp = Flask(__name__)\nrenderer = typf.Typf()\n\n@app.route('/render/&lt;text&gt;')\ndef render_text(text):\n    \"\"\"Render text as PNG.\"\"\"\n    result = renderer.render_text(text, \"Roboto-Regular.ttf\")\n\n    # Convert to BytesIO for Flask\n    img_bytes = result.to_bytes(\"png\")\n    return send_file(io.BytesIO(img_bytes), \n                    mimetype='image/png')\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#django-example","level":3,"title":"Django Example","text":"<pre><code>from django.http import HttpResponse\nimport typf\n\ndef render_text_view(request, text):\n    \"\"\"Render text and return as response.\"\"\"\n    renderer = typf.Typf()\n    result = renderer.render_text(text, \"font.ttf\")\n\n    png_bytes = result.to_bytes(\"png\")\n    return HttpResponse(png_bytes, content_type='image/png')\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#testing","level":2,"title":"Testing","text":"","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#unit-tests","level":3,"title":"Unit Tests","text":"<pre><code>import unittest\nimport typf\n\nclass TestTypf(unittest.TestCase):\n    def setUp(self):\n        self.renderer = typf.Typf()\n\n    def test_basic_render(self):\n        \"\"\"Test basic text rendering.\"\"\"\n        result = self.renderer.render_text(\"Test\", \"font.ttf\")\n        self.assertIsNotNone(result)\n        self.assertEqual(result.width, 800)\n        self.assertEqual(result.height, 600)\n\n    def test_invalid_font(self):\n        \"\"\"Test error handling for invalid font.\"\"\"\n        with self.assertRaises(typf.FontError):\n            self.renderer.render_text(\"Test\", \"nonexistent.ttf\")\n</code></pre>","path":["API Reference","Python API"],"tags":[]},{"location":"19-python-api/#performance-tests","level":3,"title":"Performance Tests","text":"<pre><code>import time\nimport typf\n\ndef benchmark_render():\n    \"\"\"Benchmark rendering performance.\"\"\"\n    renderer = typf.Typf()\n    text = \"Performance test text\"\n    iterations = 100\n\n    start_time = time.time()\n    for _ in range(iterations):\n        result = renderer.render_text(text, \"font.ttf\")\n    end_time = time.time()\n\n    avg_time = (end_time - start_time) / iterations\n    print(f\"Average render time: {avg_time:.3f}s\")\n</code></pre> <p>The Python API provides the same performance as Rust while integrating seamlessly with Python's ecosystem. Use NumPy for image processing, async for concurrent work, and your favorite web framework for serving rendered text.</p>","path":["API Reference","Python API"],"tags":[]},{"location":"20-cli-interface/","level":1,"title":"CLI Interface","text":"<p>TYPF's command-line interface provides fast text rendering from the terminal.</p>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#basic-usage","level":2,"title":"Basic Usage","text":"<pre><code># Simple text rendering\ntypf render \"Hello World\" -f font.ttf -o hello.png\n\n# Use specific backends\ntypf render \"Text\" -f font.ttf --shaper harfbuzz --renderer skia -o text.png\n\n# Python CLI (identical syntax)\ntypfpy render \"Hello World\" -f font.ttf -o hello.png\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#installation","level":2,"title":"Installation","text":"<pre><code># Build from source\ngit clone https://github.com/fontlaborg/typf.git\ncd typf\n./build.sh\n\n# Install Python bindings\ncd bindings/python\nuv sync\nmaturin develop\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#commands","level":2,"title":"Commands","text":"","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#info","level":3,"title":"info","text":"<p>Show available backends and system information.</p> <pre><code>typf info [--shapers] [--renderers] [--formats]\n\nOptions:\n  --shapers       Show available shaper backends\n  --renderers     Show available renderer backends\n  --formats       Show supported export formats\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#render","level":3,"title":"render","text":"<p>Main command for text rendering.</p> <pre><code>typf render [OPTIONS] &lt;TEXT&gt;\n\nArguments:\n  &lt;TEXT&gt;          Text to render\n\nOptions:\n  -f, --font &lt;FONT&gt;           Font file path [required]\n  -o, --output &lt;OUTPUT&gt;       Output file path\n  -s, --size &lt;SIZE&gt;           Font size in pixels [default: 32]\n  -w, --width &lt;WIDTH&gt;         Image width [default: auto]\n  -h, --height &lt;HEIGHT&gt;       Image height [default: auto]\n      --shaper &lt;SHAPER&gt;       Text shaper backend [none|hb|icu-hb|mac]\n      --renderer &lt;RENDERER&gt;   Rendering backend [orge|skia|zeno|json|mac|cg]\n      --format &lt;FORMAT&gt;       Output format [png|svg|pnm|json]\n  -c, --color &lt;COLOR&gt;         Text color (RRGGBBAA hex) [default: 000000FF]\n  -b, --background &lt;COLOR&gt;    Background color (RRGGBBAA hex) [default: 00000000]\n      --direction &lt;DIR&gt;       Text direction [ltr|rtl|ttb] [default: auto]\n      --language &lt;LANG&gt;       Language code [default: auto]\n      --script &lt;SCRIPT&gt;       Unicode script [default: auto]\n  -F, --features &lt;FEATURES&gt;   Font features (comma-separated)\n      --dpi &lt;DPI&gt;             Output resolution [default: 72]\n  -v, --verbose               Show detailed output\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#examples","level":3,"title":"Examples","text":"<pre><code># Basic rendering\ntypf render \"Hello World\" -f Roboto.ttf -o hello.png\n\n# Large text for printing\ntypf render \"Print Title\" -f serif.ttf -s 48 --dpi 300 -o title.png\n\n# SVG export\ntypf render \"Vector Text\" -f sans.ttf --format svg -o vector.svg\n\n# Custom colors (hex format)\ntypf render \"Red Text\" -f font.ttf -c FF0000FF -b F0F0F0FF -o red.png\n\n# Using specific backends\ntypf render \"Hi-Quality\" -f font.ttf --shaper harfbuzz --renderer skia -o high.png\n\n# Complex script with proper settings\ntypf render \"مرحبا بالعالم\" -f arabic.ttf --shaper harfbuzz --language ar --script Arab --direction rtl -o arabic.png\n\n# Font features\ntypf render \"Ligatures\" -f font.ttf -F \"liga,kern,dlig\" -o features.png\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#batch","level":3,"title":"batch","text":"<p>Render multiple texts from a JSONL file.</p> <pre><code>typf batch [OPTIONS] --input &lt;INPUT&gt; --output-dir &lt;OUTPUT_DIR&gt;\n\nOptions:\n  -i, --input &lt;INPUT&gt;         Input JSONL file path\n  -o, --output-dir &lt;OUTPUT_DIR&gt;  Output directory\n  -f, --font &lt;FONT&gt;           Default font file path\n      --format &lt;FORMAT&gt;       Default output format [default: png]\n      --size &lt;SIZE&gt;           Default font size [default: 32]\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#input-format-jsonl","level":3,"title":"Input Format (JSONL)","text":"<p>Each line contains a JSON object: <pre><code>{\"text\": \"Hello World\", \"size\": 24, \"output\": \"hello.png\"}\n{\"text\": \"Big Title\", \"size\": 48, \"output\": \"title.png\", \"shaper\": \"harfbuzz\"}\n{\"text\": \"مرحبا\", \"language\": \"ar\", \"script\": \"Arab\", \"direction\": \"rtl\", \"output\": \"arabic.png\"}\n</code></pre></p>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#example","level":3,"title":"Example","text":"<pre><code># Create jobs file\ncat &gt; jobs.jsonl &lt;&lt; 'EOF'\n{\"text\": \"Title\", \"size\": 72, \"output\": \"title.png\"}\n{\"text\": \"Subtitle\", \"size\": 48, \"output\": \"subtitle.png\"}\n{\"text\": \"Body\", \"size\": 16, \"output\": \"body.png\"}\nEOF\n\n# Process all jobs\ntypf batch -i jobs.jsonl -o ./rendered/\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#configuration","level":2,"title":"Configuration","text":"","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#config-file","level":3,"title":"Config File","text":"<p>Create <code>~/.config/typf/config.toml</code>:</p> <pre><code>[default]\nfont = \"~/fonts/Roboto-Regular.ttf\"\nsize = 16\nwidth = 800\nheight = 600\nformat = \"png\"\nshaper = \"harfbuzz\"\nrenderer = \"orge\"\n\n[colors]\ntext = \"0,0,0,255\"\nbackground = \"255,255,255,0\"\n\n[performance]\ncache_size = \"100MB\"\nparallel_jobs = 4\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#environment-variables","level":3,"title":"Environment Variables","text":"<pre><code>export TYPF_FONT=~/fonts/MyFont.ttf\nexport TYPF_SIZE=24\nexport TYPF_OUTPUT_DIR=./output\nexport TYPF_CONFIG=~/my-typf-config.toml\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#command-precedence","level":3,"title":"Command Precedence","text":"<ol> <li>Command line flags (highest)</li> <li>Environment variables</li> <li>Config file</li> <li>Defaults (lowest)</li> </ol>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#backend-selection","level":2,"title":"Backend Selection","text":"","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#available-backends","level":3,"title":"Available Backends","text":"<pre><code># List available backends\ntypf --list-backends\n\nShapers:\n- none          No shaping (identity mapping)\n- harfbuzz      HarfBuzz text shaper\n- icu-harfbuzz ICU + HarfBuzz composition\n- coretext     macOS CoreText (macOS only)\n- directwrite  Windows DirectWrite (Windows only)\n\nRenderers:\n- orge          Pure Rust rasterizer\n- skia          Skia graphics library\n- coregraphics macOS CoreGraphics (macOS only)\n- directwrite  Windows DirectWrite (Windows only)\n- zeno          Vector graphics renderer\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#selecting-backends","level":3,"title":"Selecting Backends","text":"<pre><code># Use specific shaper\ntypf render \"Text\" --font font.ttf --shaper harfbuzz\n\n# Use specific renderer\ntypf render \"Text\" --font font.ttf --renderer skia\n\n# Combine backends\ntypf render \"Text\" --font font.ttf --shaper icu-harfbuzz --renderer zeno\n\n# Auto-select best available\ntypf render \"Text\" --font font.ttf  # Uses defaults\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#output-formats","level":2,"title":"Output Formats","text":"","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#format-support","level":3,"title":"Format Support","text":"Format Extension Type Features PNG .png Raster Transparency, compression SVG .svg Vector Scalable, web-friendly PDF .pdf Document Print-optimized, fonts PNM .pnm/.pbm/.pgm Raster Simple, uncompressed JSON .json Data Debug information","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#format-options","level":3,"title":"Format Options","text":"<pre><code># PNG with quality\ntypf render \"Text\" --font font.ttf --output image.png --png-quality 9\n\n# SVG with embedded fonts\ntypf render \"Text\" --font font.ttf --output vector.svg --svg-embed-fonts\n\n# PDF with metadata\ntypf render \"Report\" --font font.ttf --output doc.pdf --pdf-title \"Report\" --pdf-author \"Me\"\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#color-specification","level":2,"title":"Color Specification","text":"","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#color-formats","level":3,"title":"Color Formats","text":"<pre><code># Hex colors\ntypf render \"Text\" --font font.ttf --color \"#FF0000\"    --background \"#FFFFFF\"\n\n# RGB/RGBA tuples\ntypf render \"Text\" --font font.ttf --color \"255,0,0,255\" --background \"240,240,240,128\"\n\n# Named colors\ntypf render \"Text\" --font font.ttf --color red --background white\n\n# Transparent background\ntypf render \"Text\" --font font.ttf --background transparent\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#named-colors","level":3,"title":"Named Colors","text":"<ul> <li><code>black</code>, <code>white</code>, <code>red</code>, <code>green</code>, <code>blue</code>, <code>yellow</code>, <code>cyan</code>, <code>magenta</code></li> <li><code>gray</code>, <code>grey</code>, <code>lightgray</code>, <code>darkgray</code></li> <li><code>orange</code>, <code>purple</code>, <code>brown</code>, <code>pink</code></li> <li><code>transparent</code></li> </ul>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#performance-options","level":2,"title":"Performance Options","text":"","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#parallel-processing","level":3,"title":"Parallel Processing","text":"<pre><code># Use multiple threads\ntypf batch --input texts.txt --template \"out_{line}.png\" --jobs 8\n\n# Benchmark with parallel processing\ntypf benchmark --iterations 1000 --parallel\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#caching","level":3,"title":"Caching","text":"<pre><code># Enable caching (default)\ntypf render \"Cached text\" --font font.ttf --cache\n\n# Disable caching\ntypf render \"One-time text\" --font font.ttf --no-cache\n\n# Clear cache\ntypf cache clear\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#memory-management","level":3,"title":"Memory Management","text":"<pre><code># Limit memory usage\ntypf render \"Large text\" --font font.ttf --memory-limit 1GB\n\n# Stream large files\ntypf batch --input huge.txt --template \"out_{line}.png\" --stream\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#error-handling","level":2,"title":"Error Handling","text":"","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#exit-codes","level":3,"title":"Exit Codes","text":"<ul> <li><code>0</code> - Success</li> <li><code>1</code> - General error</li> <li><code>2</code> - Font loading error</li> <li><code>3</code> - Backend unavailable</li> <li><code>4</code> - Invalid configuration</li> <li><code>5</code> - I/O error</li> </ul>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#error-messages","level":3,"title":"Error Messages","text":"<pre><code>$ typf render \"Test\" --font nonexistent.ttf\nError: Font loading failed: File not found: nonexistent.ttf\n\n$ typf render \"Test\" --font font.ttf --shaper nonexistent\nError: Backend unavailable: Shaper 'nonexistent' not compiled\n\n$ typf render \"Test\" --font font.ttf --output invalid.xyz\nError: Invalid configuration: Unsupported output format: xyz\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#troubleshooting","level":3,"title":"Troubleshooting","text":"<pre><code># Show debug information\ntypf render \"Debug\" --font font.ttf --verbose\n\n# Test backends\ntypf benchmark --test-backends\n\n# Check font support\ntypf font info font.ttf --verbose\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#integration-examples","level":2,"title":"Integration Examples","text":"","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#shell-scripts","level":3,"title":"Shell Scripts","text":"<pre><code>#!/bin/bash\n# Generate previews for all fonts\n\nfor font in ~/fonts/*.ttf; do\n    basename=$(basename \"$font\" .ttf)\n    typf quick \"$basename Sample\" --font \"$font\" --output \"previews/$basename.png\"\ndone\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#make-integration","level":3,"title":"Make Integration","text":"<pre><code># Makefile for text assets\n\nTEXTS = $(wildcard texts/*.txt)\nIMAGES = $(TEXTS:texts/%.txt=output/%.png)\n\noutput/%.png: texts/%.txt\n    typf render \"$$(cat $&lt;)\" --font Roboto.ttf --output $@\n\nall: $(IMAGES)\n\nclean:\n    rm -f output/*.png\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#cicd-pipeline","level":3,"title":"CI/CD Pipeline","text":"<pre><code># GitHub Actions example\n- name: Render text assets\n  run: |\n    typf batch \\\n      --input assets/texts.txt \\\n      --template \"generated/{line}.png\" \\\n      --config ci/typf-config.toml\n\n    typf benchmark \\\n      --font Roboto.ttf \\\n      --output performance.json\n\n- name: Upload artifacts\n  uses: actions/upload-artifact@v3\n  with:\n    name: text-assets\n    path: generated/\n</code></pre>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#migration-from-v1x","level":2,"title":"Migration from v1.x","text":"<p>If you're upgrading from TYPF v1.x, the CLI has changed significantly:</p>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#command-structure-changes","level":3,"title":"Command Structure Changes","text":"<p>Before (v1.x): <pre><code>typf \"Hello\" --font font.ttf --output hello.png --size 48\npython -m typfpy render \"Hello\" hello.png --font=/path/to/font.ttf\n</code></pre></p> <p>After (v2.0.0): <pre><code>typf render \"Hello\" -f font.ttf -o hello.png -s 48\ntypfpy render \"Hello\" -f /path/to/font.ttf -o hello.png\n</code></pre></p>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#key-changes","level":3,"title":"Key Changes","text":"<ul> <li>Subcommands: Now uses <code>info</code>, <code>render</code>, <code>batch</code> subcommands</li> <li>Option names: Shortened (<code>--output</code> → <code>-o</code>, <code>--font</code> → <code>-f</code>, <code>--size</code> → <code>-s</code>)</li> <li>Python CLI: Renamed from <code>python -m typfpy</code> to <code>typfpy</code></li> <li>Features: Enhanced with Unicode escapes, color parsing, font features</li> </ul>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"20-cli-interface/#new-features","level":3,"title":"New Features","text":"<ul> <li>Unicode escape sequences: <code>\\u{1F44B}</code> for emoji</li> <li>Color format: RRGGBBAA hex (e.g., <code>FF0000FF</code> for red)</li> <li>Font features: <code>-F \"liga,kern,dlig\"</code></li> <li>Better backend detection and selection</li> </ul> <p>For complete migration details, see the main repository's <code>CLI_MIGRATION.md</code> file.</p> <p>The CLI provides fast, scriptable text rendering from the command line. Use batch mode for bulk processing, benchmark for performance testing, and the REPL for interactive experimentation.</p>","path":["API Reference","CLI Interface"],"tags":[]},{"location":"21-webassembly-integration/","level":1,"title":"WebAssembly Integration","text":"<p>Run TypF in browsers and JavaScript environments with WebAssembly.</p>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#quick-start","level":2,"title":"Quick Start","text":"<pre><code>import { Typf } from '@typf/wasm';\n\n// Initialize TYPF\nconst typf = await Typf.create();\n\n// Render text\nconst result = await typf.renderText(\"Hello WASM\", {\n  fontSize: 32,\n  width: 400,\n  height: 100\n});\n\n// Get PNG data\nconst pngData = result.asPng();\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#installation","level":2,"title":"Installation","text":"","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#npm-package","level":3,"title":"NPM Package","text":"<pre><code>npm install @typf/wasm\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#cdn-usage","level":3,"title":"CDN Usage","text":"<pre><code>&lt;script src=\"https://unpkg.com/@typf/wasm/dist/typf.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  const typf = await Typf.create();\n&lt;/script&gt;\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#bundle-integration","level":3,"title":"Bundle Integration","text":"<pre><code>// Vite configuration\nexport default {\n  optimizeDeps: {\n    exclude: ['@typf/wasm']\n  },\n  server: {\n    fs: {\n      allow: ['.']\n    }\n  }\n};\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#core-api","level":2,"title":"Core API","text":"","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#initialization","level":3,"title":"Initialization","text":"<pre><code>// Basic initialization\nconst typf = await Typf.create();\n\n// With specific backends\nconst typf = await Typf.create({\n  shaper: 'harfbuzz',\n  renderer: 'orge'\n});\n\n// Preload fonts\nconst typf = await Typf.create({\n  fonts: ['Roboto.ttf', 'OpenSans.ttf']\n});\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#text-rendering","level":3,"title":"Text Rendering","text":"<pre><code>// Simple rendering\nconst result = await typf.renderText(\"Hello World\", {\n  fontSize: 24,\n  width: 300,\n  height: 80\n});\n\n// With font\nconst result = await typf.renderText(\"Custom Font\", {\n  font: await loadFont('Roboto.ttf'),\n  fontSize: 32,\n  width: 400,\n  height: 100\n});\n\n// Full options\nconst result = await typf.renderText(\"Advanced\", {\n  font: fontData,\n  fontSize: 48,\n  width: 600,\n  height: 200,\n  shaper: 'harfbuzz',\n  renderer: 'skia',\n  antialiasing: true,\n  color: { r: 0, g: 0, b: 0, a: 255 },\n  background: { r: 255, g: 255, b: 255, a: 0 }\n});\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#output-formats","level":3,"title":"Output Formats","text":"<pre><code>const result = await typf.renderText(\"Output\", options);\n\n// PNG (default)\nconst pngData = result.asPng();\nconst blob = new Blob([pngData], { type: 'image/png' });\n\n// SVG\nconst svgData = result.asSvg();\nconst svgString = new TextDecoder().decode(svgData);\n\n// JSON (debug)\nconst jsonData = result.asJson();\nconst info = JSON.parse(new TextDecoder().decode(jsonData));\n\n// Raw bitmap data\nconst bitmap = result.asBitmap();\nconst { width, height, data } = bitmap; // Uint8Array RGBA像素数据\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#font-loading","level":2,"title":"Font Loading","text":"","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#font-sources","level":3,"title":"Font Sources","text":"<pre><code>// From fetch\nconst fontBuffer = await fetch('Roboto.ttf').then(r =&gt; r.arrayBuffer());\nconst font = await typf.loadFont(fontBuffer);\n\n// From file input\ndocument.getElementById('font-file').addEventListener('change', async (e) =&gt; {\n  const file = e.target.files[0];\n  const fontBuffer = await file.arrayBuffer();\n  const font = await typf.loadFont(fontBuffer);\n});\n\n// From base64\nconst base64Font = atob(base64Data);\nconst fontBytes = new Uint8Array(base64Font.length);\nfor (let i = 0; i &lt; base64Font.length; i++) {\n  fontBytes[i] = base64Font.charCodeAt(i);\n}\nconst font = await typf.loadFont(fontBytes);\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#font-management","level":3,"title":"Font Management","text":"<pre><code>// Load multiple fonts\nconst fonts = [\n  await typf.loadFont(robotoBuffer, 'Roboto'),\n  await typf.loadFont(openSansBuffer, 'OpenSans'),\n  await typf.loadFont(arabicFont, 'Arabic')\n];\n\n// Font fallback testing\nconst availableFonts = await typf.listFonts();\nconst supportsArabic = availableFonts.some(font =&gt; font.supportsScript('Arabic'));\n\n// Font information\nconst fontInfo = await font.getInfo();\nconsole.log(fontInfo.family, fontInfo.style, fontInfo.supportsScripts);\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#canvas-integration","level":2,"title":"Canvas Integration","text":"","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#direct-canvas-rendering","level":3,"title":"Direct Canvas Rendering","text":"<pre><code>// Get canvas context\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\n// Render to ImageData\nconst result = await typf.renderText(\"Canvas Text\", {\n  fontSize: 48,\n  width: canvas.width,\n  height: canvas.height\n});\n\nconst bitmap = result.asBitmap();\nconst imageData = new ImageData(\n  new Uint8ClampedArray(bitmap.data),\n  bitmap.width,\n  bitmap.height\n);\n\nctx.putImageData(imageData, 0, 0);\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#responsive-rendering","level":3,"title":"Responsive Rendering","text":"<pre><code>function renderResponsive(text, container) {\n  const rect = container.getBoundingClientRect();\n  const dpr = window.devicePixelRatio || 1;\n\n  return typf.renderText(text, {\n    fontSize: Math.floor(16 * dpr),\n    width: Math.floor(rect.width * dpr),\n    height: Math.floor(rect.height * dpr),\n    renderer: 'skia' // Better for high DPI\n  });\n}\n\n// Handle resize\nwindow.addEventListener('resize', () =&gt; {\n  renderResponsive(\"Responsive Text\", container)\n    .then(result =&gt; updateCanvas(result));\n});\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#performance-optimization","level":2,"title":"Performance Optimization","text":"","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#memory-management","level":3,"title":"Memory Management","text":"<pre><code>// Reuse Typf instance\nconst typf = await Typf.create();\n\n// Clear font cache\nawait typf.clearFontCache();\n\n// Dispose of large results\nconst result = await typf.renderText(bigText, options);\nconst imageData = result.asBitmap();\n// Process imageData...\nresult.free(); // Free WASM memory\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#parallel-processing","level":3,"title":"Parallel Processing","text":"<pre><code>// Web Worker integration\n// worker.js\nimportScripts('https://unpkg.com/@typf/wasm/dist/typf.js');\n\nlet typf;\n\nself.addEventListener('message', async (e) =&gt; {\n  if (!typf) {\n    typf = await Typf.create();\n  }\n\n  const { text, options } = e.data;\n  const result = await typf.renderText(text, options);\n\n  self.postMessage({\n    id: e.data.id,\n    result: result.asPng()\n  });\n});\n\n// Main thread\nfunction renderInWorker(text, options) {\n  return new Promise((resolve) =&gt; {\n    const worker = new Worker('worker.js');\n    const id = Math.random();\n\n    worker.postMessage({ id, text, options });\n    worker.onmessage = (e) =&gt; {\n      if (e.data.id === id) {\n        resolve(e.data.result);\n        worker.terminate();\n      }\n    };\n  });\n}\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#streaming-large-texts","level":3,"title":"Streaming Large Texts","text":"<pre><code>// Chunked rendering for large documents\nasync function renderLargeText(text, options) {\n  const words = text.split(' ');\n  const lines = [];\n  let currentLine = '';\n\n  for (const word of words) {\n    const testLine = currentLine + (currentLine ? ' ' : '') + word;\n    const result = await typf.measureText(testLine, options);\n\n    if (result.width &lt;= options.width) {\n      currentLine = testLine;\n    } else {\n      if (currentLine) lines.push(currentLine);\n      currentLine = word;\n    }\n  }\n\n  if (currentLine) lines.push(currentLine);\n\n  // Render each line\n  const renderedLines = await Promise.all(\n    lines.map(line =&gt; typf.renderText(line, options))\n  );\n\n  return renderedLines;\n}\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#advanced-features","level":2,"title":"Advanced Features","text":"","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#text-shaping-analysis","level":3,"title":"Text Shaping Analysis","text":"<pre><code>// Get shaping information\nconst analysis = await typf.analyzeText(\"Complex text 😊\", {\n  font: fontData,\n  fontSize: 16\n});\n\nconsole.log(`\n  Glyphs: ${analysis.glyphs.length}\n  Scripts: ${analysis.scripts.join(', ')}\n  Direction: ${analysis.direction}\n  Cluster breaks: ${analysis.clusters.length}\n`);\n\n// Glyph-level information\nfor (const glyph of analysis.glyphs) {\n  console.log(`\n    ID: ${glyph.id}\n    Position: (${glyph.x}, ${glyph.y})\n    Advance: ${glyph.advance}\n    Cluster: ${glyph.cluster}\n  `);\n}\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#font-fallback","level":3,"title":"Font Fallback","text":"<pre><code>// Configure font fallback\nconst fallbackFonts = [\n  await loadFont('LatinFont.ttf'),\n  await loadFont('ArabicFont.ttf'),\n  await loadFont('EmojiFont.ttf')\n];\n\nawait typf.setFontFallback(fallbackFonts);\n\n// Text with mixed scripts\nconst result = await typf.renderText(\"Hello مرحبا 👋\", options);\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#variable-fonts","level":3,"title":"Variable Fonts","text":"<pre><code>// Load variable font\nconst varFont = await typf.loadFont(fontBuffer);\n\n// Set variation settings\nawait varFont.setVariation({\n  weight: 700,\n  width: 100,\n  slant: 0\n});\n\n// Render with variation\nconst result = await typf.renderText(\"Variable Font\", {\n  font: varFont,\n  fontSize: 48\n});\n\n// Adjust variations dynamically\nasync function animateWeight() {\n  for (let weight = 100; weight &lt;= 900; weight += 50) {\n    await varFont.setVariation({ weight });\n    const result = await typf.renderText(\"Animated\", options);\n    updateDisplay(result);\n    await new Promise(r =&gt; setTimeout(r, 50));\n  }\n}\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#framework-integration","level":2,"title":"Framework Integration","text":"","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#react-component","level":3,"title":"React Component","text":"<pre><code>import React, { useState, useEffect, useRef } from 'react';\nimport { Typf } from '@typf/wasm';\n\nfunction TextRenderer({ text, fontSize = 24, font }) {\n  const canvasRef = useRef(null);\n  const [typf, setTypf] = useState(null);\n\n  useEffect(() =&gt; {\n    Typf.create().then(setTypf);\n  }, []);\n\n  useEffect(() =&gt; {\n    if (!typf || !canvasRef.current) return;\n\n    const render = async () =&gt; {\n      const result = await typf.renderText(text, {\n        fontSize,\n        font,\n        width: canvasRef.current.width,\n        height: canvasRef.current.height\n      });\n\n      const bitmap = result.asBitmap();\n      const ctx = canvasRef.current.getContext('2d');\n      const imageData = new ImageData(\n        new Uint8ClampedArray(bitmap.data),\n        bitmap.width,\n        bitmap.height\n      );\n\n      ctx.putImageData(imageData, 0, 0);\n    };\n\n    render();\n  }, [typf, text, fontSize, font]);\n\n  return &lt;canvas ref={canvasRef} width={400} height={100} /&gt;;\n}\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#vue-component","level":3,"title":"Vue Component","text":"<pre><code>&lt;template&gt;\n  &lt;canvas ref=\"canvas\" :width=\"width\" :height=\"height\"&gt;&lt;/canvas&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { Typf } from '@typf/wasm';\n\nexport default {\n  props: ['text', 'fontSize', 'width', 'height'],\n  data: () =&gt; ({ typf: null }),\n\n  async mounted() {\n    this.typf = await Typf.create();\n    await this.render();\n  },\n\n  watch: {\n    text() { this.render(); },\n    fontSize() { this.render(); }\n  },\n\n  methods: {\n    async render() {\n      if (!this.typf) return;\n\n      const result = await this.typf.renderText(this.text, {\n        fontSize: this.fontSize,\n        width: this.width,\n        height: this.height\n      });\n\n      const bitmap = result.asBitmap();\n      const ctx = this.$refs.canvas.getContext('2d');\n      const imageData = new ImageData(\n        new Uint8ClampedArray(bitmap.data),\n        bitmap.width,\n        bitmap.height\n      );\n\n      ctx.putImageData(imageData, 0, 0);\n    }\n  }\n};\n&lt;/script&gt;\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#svelte-integration","level":3,"title":"Svelte Integration","text":"<pre><code>&lt;script&gt;\n  import { onMount } from 'svelte';\n  import { Typf } from '@typf/wasm';\n\n  export let text = 'Hello Svelte';\n  export let fontSize = 24;\n\n  let canvas;\n  let typf;\n\n  onMount(async () =&gt; {\n    typf = await Typf.create();\n    render();\n  });\n\n  async function render() {\n    if (!typf || !canvas) return;\n\n    const result = await typf.renderText(text, {\n      fontSize,\n      width: canvas.width,\n      height: canvas.height\n    });\n\n    const bitmap = result.asBitmap();\n    const ctx = canvas.getContext('2d');\n    const imageData = new ImageData(\n      new Uint8ClampedArray(bitmap.data),\n      bitmap.width,\n      bitmap.height\n    );\n\n    ctx.putImageData(imageData, 0, 0);\n  }\n\n  $: if (typf &amp;&amp; canvas) render();\n&lt;/script&gt;\n\n&lt;canvas bind:this={canvas} width={400} height={100}&gt;&lt;/canvas&gt;\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#error-handling","level":2,"title":"Error Handling","text":"","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#common-wasm-issues","level":3,"title":"Common WASM Issues","text":"<pre><code>try {\n  const typf = await Typf.create();\n  const result = await typf.renderText(\"Test\", options);\n} catch (error) {\n  if (error.message.includes('WASM')) {\n    console.error('WASM loading failed:', error);\n    // Fallback to server-side rendering\n  } else if (error.message.includes('Font')) {\n    console.error('Font loading failed:', error);\n    // Use default font\n  } else {\n    console.error('Rendering error:', error);\n  }\n}\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#memory-limits","level":3,"title":"Memory Limits","text":"<pre><code>// Monitor memory usage\nconst memoryUsage = typf.getMemoryUsage();\nconsole.log(`Used: ${memoryUsage.used} bytes`);\nconsole.log(`Available: ${memoryUsage.available} bytes`);\n\n// Handle memory pressure\nif (memoryUsage.used / memoryUsage.available &gt; 0.8) {\n  console.warn('High memory usage, clearing cache');\n  await typf.clearFontCache();\n}\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#browser-compatibility","level":2,"title":"Browser Compatibility","text":"","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#supported-browsers","level":3,"title":"Supported Browsers","text":"<ul> <li>Chrome 57+ (WebAssembly 1.0)</li> <li>Firefox 52+ (WebAssembly 1.0)</li> <li>Safari 11+ (WebAssembly 1.0)</li> <li>Edge 16+ (WebAssembly 1.0)</li> </ul>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#feature-detection","level":3,"title":"Feature Detection","text":"<pre><code>// Check WebAssembly support\nfunction supportsWasm() {\n  try {\n    if (typeof WebAssembly === 'object') {\n      const module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d));\n      if (module instanceof WebAssembly.Module) {\n        return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;\n      }\n    }\n  } catch (e) {}\n  return false;\n}\n\n// Check SharedArrayBuffer support (for performance)\nfunction supportsSharedMemory() {\n  return typeof SharedArrayBuffer !== 'undefined';\n}\n\n// Fallback handling\nif (!supportsWasm()) {\n  // Use server-side rendering or canvas 2D fallback\n}\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#security-considerations","level":2,"title":"Security Considerations","text":"","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#loading-safely","level":3,"title":"Loading Safely","text":"<pre><code>// Validate font data before loading\nasync function loadFontSafely(fontData) {\n  // Check file size (limit to 50MB)\n  if (fontData.byteLength &gt; 50 * 1024 * 1024) {\n    throw new Error('Font file too large');\n  }\n\n  // Validate font header\n  const header = new Uint32Array(fontData.slice(0, 12));\n  if (header[0] !== 0x10000 &amp;&amp; header[0] !== 0x74727565) {\n    throw new Error('Invalid font format');\n  }\n\n  return await typf.loadFont(fontData);\n}\n\n// Use CSP headers\n// Content-Security-Policy: script-src 'self' 'wasm-unsafe-eval';\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#sandboxing","level":3,"title":"Sandboxing","text":"<pre><code>// Run in Web Worker for isolation\nconst worker = new Worker('typf-worker.js', { \n  type: 'module',\n  credentials: 'omit'\n});\n\n// Use Transferable objects for efficiency\nworker.postMessage({\n  fontBuffer: fontData,\n  text: \"Sandboxed text\"\n}, [fontData]);\n</code></pre>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#performance-tips","level":2,"title":"Performance Tips","text":"","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#optimization-checklist","level":3,"title":"Optimization Checklist","text":"<ul> <li> Reuse Typf instances instead of recreating</li> <li> Preload commonly used fonts</li> <li> Use Web Workers for CPU-intensive tasks</li> <li> Clear font cache periodically</li> <li> Choose optimal renderers for target platforms</li> <li> Use appropriate output formats for use cases</li> <li> Implement progressive rendering for large texts</li> </ul>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"21-webassembly-integration/#benchmarking","level":3,"title":"Benchmarking","text":"<pre><code>// Performance measurement\nconst startTime = performance.now();\nconst result = await typf.renderText(\"Benchmark\", options);\nconst endTime = performance.now();\n\nconsole.log(`Render time: ${endTime - startTime}ms`);\n\n// Memory usage before/after\nconst memBefore = typf.getMemoryUsage();\nconst largeResult = await typf.renderText(hugeText, options);\nconst memAfter = typf.getMemoryUsage();\n\nconsole.log(`Memory delta: ${memAfter.used - memBefore.used} bytes`);\n</code></pre> <p>WebAssembly brings TYPF's text rendering to browsers with near-native performance. Use it for dynamic typography tools, real-time text effects, and font-intensive web applications.</p>","path":["Advanced Topics","WebAssembly Integration"],"tags":[]},{"location":"22-performance-optimization/","level":1,"title":"Performance Optimization","text":"<p>Make TypF fast through strategic optimization techniques.</p>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#performance-summary","level":2,"title":"Performance Summary","text":"Metric Target Current Simple Latin shaping &lt;10µs/100 chars ~5µs Complex Arabic shaping &lt;50µs/100 chars ~45µs Glyph rasterization (16px) &lt;1µs/glyph ~0.8µs RGBA blending (SIMD) &gt;10GB/s ~12GB/s L1 cache hit latency &lt;50ns ~40ns Binary size (minimal) &lt;500KB ~500KB Memory (1M chars) &lt;100MB ~85MB","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#backend-performance","level":2,"title":"Backend Performance","text":"Backend Performance Quality Use Case JSON Export 15,506-22,661 ops/sec Data only Analysis, debug CoreGraphics 3,805-4,583 ops/sec High quality macOS best Zeno 3,048-3,675 ops/sec High Vector quality Orge 1,959-2,302 ops/sec Medium Pure Rust, SIMD Skia 1,611-1,829 ops/sec High quality Cross-platform","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#quick-wins","level":2,"title":"Quick Wins","text":"","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#font-caching","level":3,"title":"Font Caching","text":"<pre><code>// Enable font caching (default)\nlet mut pipeline = PipelineBuilder::new()\n    .enable_font_cache(true)\n    .cache_size(100 * 1024 * 1024) // 100MB\n    .build()?;\n\n// Preload common fonts\npipeline.load_font(\"Roboto-Regular.ttf\")?;\npipeline.load_font(\"OpenSans-Regular.ttf\")?;\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#backend-selection","level":3,"title":"Backend Selection","text":"<pre><code>// Use platform backends for better performance\n#[cfg(target_os = \"macos\")]\nlet pipeline = PipelineBuilder::new()\n    .shaper(ShaperBackend::CoreText)\n    .renderer(RendererBackend::CoreGraphics)\n    .build()?;\n\n#[cfg(target_os = \"windows\")]\nlet pipeline = PipelineBuilder::new()\n    .shaper(ShaperBackend::DirectWrite)\n    .renderer(RendererBackend::DirectWrite)\n    .build()?;\n\n// Fallback for other platforms\nlet pipeline = PipelineBuilder::new()\n    .shaper(ShaperBackend::HarfBuzz)\n    .renderer(RendererBackend::Skia)\n    .build()?;\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#memory-efficiency","level":3,"title":"Memory Efficiency","text":"<pre><code>// Use appropriate buffer sizes\nlet render_options = RenderOptions {\n    width: 800,\n    height: 600,\n    // Match font size to avoid unnecessary scaling\n    pixel_size: font_size.round() as u32,\n    ..Default::default()\n};\n\n// Reuse buffers\nlet mut buffer = BitmapBuffer::new(800, 600)?;\npipeline.render_to_buffer(&amp;text, &amp;font, &amp;mut buffer)?;\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#measurement-profiling","level":2,"title":"Measurement &amp; Profiling","text":"","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#built-in-profiling","level":3,"title":"Built-in Profiling","text":"<pre><code>// Enable performance profiling\nlet pipeline = PipelineBuilder::new()\n    .enable_profiling(true)\n    .build()?;\n\nlet result = pipeline.render_text(\"Profiling test\", &amp;font, &amp;options);\nlet metrics = result.get_performance_metrics();\n\nprintln!(\"Shaping time: {}ms\", metrics.shaping_time);\nprintln!(\"Render time: {}ms\", metrics.render_time);\nprintln!(\"Total time: {}ms\", metrics.total_time);\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#benchmarking","level":3,"title":"Benchmarking","text":"<pre><code>use typf::benchmark::{BenchmarkSuite, BenchmarkConfig};\n\nlet config = BenchmarkConfig {\n    iterations: 1000,\n    warmup_iterations: 100,\n    text_samples: vec![\n        \"Hello World\".to_string(),\n        \"Lorem ipsum dolor sit amet\".to_string(),\n        \"Unicode test: 你好世界 🌍\".to_string(),\n    ],\n    font_sizes: vec![12, 16, 24, 48],\n};\n\nlet suite = BenchmarkSuite::new(config);\nlet results = suite.run_all_backends()?;\n\nprintln!(\"Fastest backend: {:?}\", results.fastest_backend());\nprintln!(\"Average time: {:.2}ms\", results.average_time());\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#custom-profiling","level":3,"title":"Custom Profiling","text":"<pre><code>use std::time::Instant;\n\nlet start = Instant::now();\nlet shaped = pipeline.shape_text(\"Performance test\", &amp;font)?;\nlet shaping_time = start.elapsed();\n\nlet start = Instant::now();\nlet rendered = pipeline.render_shaped(&amp;shaped, &amp;options)?;\nlet render_time = start.elapsed();\n\nlog::info!(\"Shaping: {:?}, Render: {:?}\", shaping_time, render_time);\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#memory-optimization","level":2,"title":"Memory Optimization","text":"","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#font-memory-management","level":3,"title":"Font Memory Management","text":"<pre><code>// Use memory-mapped fonts for large files\nlet font = Font::from_memory_mapped_file(\"LargeFont.ttf\")?;\n\n// Font will be unmapped when dropped\ndrop(font);\n\n// Cache management\nlet cache = pipeline.font_cache();\ncache.set_max_size(50 * 1024 * 1024); // 50MB limit\ncache.clear_expired(); // Remove unused fonts\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#efficient-text-processing","level":3,"title":"Efficient Text Processing","text":"<pre><code>// Process text in chunks for large documents\nfn render_large_document(text: &amp;str, pipeline: &amp;Pipeline) -&gt; Result&lt;Vec&lt;Bitmap&gt;&gt; {\n    let chunk_size = 1000; // characters per chunk\n    let mut results = Vec::new();\n\n    for chunk in text.as_bytes().chunks(chunk_size) {\n        let chunk_str = std::str::from_utf8(chunk)?;\n        let result = pipeline.render_text(chunk_str, &amp;font, &amp;options)?;\n        results.push(result);\n    }\n\n    Ok(results)\n}\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#buffer-pool-pattern","level":3,"title":"Buffer Pool Pattern","text":"<pre><code>struct BufferPool {\n    available: Vec&lt;BitmapBuffer&gt;,\n    created: usize,\n}\n\nimpl BufferPool {\n    fn get_buffer(&amp;mut self, width: u32, height: u32) -&gt; BitmapBuffer {\n        self.available.pop()\n            .map(|mut buf| {\n                buf.resize(width, height);\n                buf\n            })\n            .unwrap_or_else(|| {\n                self.created += 1;\n                BitmapBuffer::new(width, height)\n            })\n    }\n\n    fn return_buffer(&amp;mut self, buffer: BitmapBuffer) {\n        if self.available.len() &lt; 10 { // Keep max 10 buffers\n            self.available.push(buffer);\n        }\n    }\n}\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#shaping-performance","level":2,"title":"Shaping Performance","text":"","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#shaper-selection","level":3,"title":"Shaper Selection","text":"<pre><code>// Fastest to slowest shapers\nfn choose_shaper(text: &amp;str) -&gt; ShaperBackend {\n    if text.is_ascii() &amp;&amp; !text.contains_whitespace() {\n        ShaperBackend::None // Fastest for simple text\n    } else if is_latin_text(text) {\n        ShaperBackend::HarfBuzz // Good balance for Latin\n    } else if text.chars().any(|c| c.is_arabic()) {\n        ShaperBackend::ICUHarfBuzz // Best for complex scripts\n    } else {\n        ShaperBackend::HarfBuzz // Default choice\n    }\n}\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#shaping-caching","level":3,"title":"Shaping Caching","text":"<pre><code>// Cache shaped results\nlet mut shaping_cache = LruCache::new(1000);\n\nlet cache_key = (text.to_string(), font_hash, font_size);\nif let Some(cached) = shaping_cache.get(&amp;cache_key) {\n    return cached.clone();\n}\n\nlet shaped = pipeline.shape_text(text, &amp;font)?;\nshaping_cache.put(cache_key, shaped.clone());\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#text-segmentation","level":3,"title":"Text Segmentation","text":"<pre><code>// Break large text into paragraphs for better parallelization\nfn render_paragraphs(text: &amp;str, pipeline: &amp;Pipeline) -&gt; Result&lt;Vec&lt;Bitmap&gt;&gt; {\n    let paragraphs: Vec&lt;&amp;str&gt; = text.split(\"\\n\\n\").collect();\n    let mut results = Vec::new();\n\n    for paragraph in paragraphs {\n        if !paragraph.trim().is_empty() {\n            let result = pipeline.render_text(paragraph, &amp;font, &amp;options)?;\n            results.push(result);\n        }\n    }\n\n    Ok(results)\n}\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#rendering-performance","level":2,"title":"Rendering Performance","text":"","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#renderer-optimization","level":3,"title":"Renderer Optimization","text":"<pre><code>// Choose renderer based on use case\nfn choose_renderer(output_format: OutputFormat) -&gt; RendererBackend {\n    match output_format {\n        OutputFormat::PNG =&gt; RendererBackend::Skia, // Best quality\n        OutputFormat::SVG =&gt; RendererBackend::Zeno, // Vector output\n        OutputFormat::PDF =&gt; RendererBackend::Skia, // Print quality\n        OutputFormat::Debug =&gt; RendererBackend::Orge, // Fastest\n    }\n}\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#simd-optimization","level":3,"title":"SIMD Optimization","text":"<pre><code>// Enable SIMD when available (auto-detected)\nlet pipeline = PipelineBuilder::new()\n    .enable_simd(true) // Default: enabled if CPU supports it\n    .build()?;\n\n// Manual SIMD hinting\n#[cfg(target_arch = \"x86_64\")]\nif is_x86_feature_detected!(\"avx2\") {\n    // AVX2 optimized path will be used\n}\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#parallel-rendering","level":3,"title":"Parallel Rendering","text":"<pre><code>use rayon::prelude::*;\n\n// Render multiple texts in parallel\nfn batch_render(texts: &amp;[String], pipeline: &amp;Pipeline) -&gt; Result&lt;Vec&lt;Bitmap&gt;&gt; {\n    texts.par_iter()\n        .map(|text| pipeline.render_text(text, &amp;font, &amp;options))\n        .collect()\n}\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#gpu-acceleration","level":3,"title":"GPU Acceleration","text":"<pre><code>// Use GPU backends when available (Skia GPU)\n#[cfg(feature = \"render-skia-gpu\")]\nlet pipeline = PipelineBuilder::new()\n    .renderer(RendererBackend::SkiaGPU)\n    .build()?;\n\n// GPU context management\nlet gpu_context = pipeline.gpu_context()?;\ngpu_context.set_max_texture_size(4096);\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#caching-strategies","level":2,"title":"Caching Strategies","text":"","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#multi-level-caching","level":3,"title":"Multi-level Caching","text":"<pre><code>// Shaping cache\nlet shaping_cache = Arc::new(RwLock::new(LruCache::new(1000)));\n\n// Glyph cache (for rasterizers)\nlet glyph_cache = Arc::new(RwLock::new(LruCache::new(10000)));\n\n// Rendered image cache\nlet image_cache = Arc::new(RwLock::new(LruCache::new(100)));\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#cache-invalidation","level":3,"title":"Cache Invalidation","text":"<pre><code>// Smart cache keys that include relevant options\nfn cache_key(text: &amp;str, font: &amp;Font, options: &amp;RenderOptions) -&gt; CacheKey {\n    CacheKey {\n        text_hash: hash_string(text),\n        font_hash: font.hash(),\n        options_hash: hash_options(options),\n    }\n}\n\n// Time-based expiration\nlet mut cache = LruCache::new(1000);\ncache.set_ttl(Duration::from_secs(3600)); // 1 hour\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#disk-caching","level":3,"title":"Disk Caching","text":"<pre><code>// Persist shaped results to disk\nuse std::collections::HashMap;\n\nstruct DiskCache {\n    cache_dir: PathBuf,\n}\n\nimpl DiskCache {\n    fn get_cached(&amp;self, key: &amp;str) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {\n        let file_path = self.cache_dir.join(format!(\"{}.cache\", key));\n        std::fs::read(file_path).ok()\n    }\n\n    fn store_cached(&amp;self, key: &amp;str, data: &amp;[u8]) -&gt; Result&lt;()&gt; {\n        let file_path = self.cache_dir.join(format!(\"{}.cache\", key));\n        std::fs::write(file_path, data)?;\n        Ok(())\n    }\n}\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#platform-specific-optimizations","level":2,"title":"Platform-Specific Optimizations","text":"","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#windows","level":3,"title":"Windows","text":"<pre><code>#[cfg(target_os = \"windows\")]\nlet pipeline = PipelineBuilder::new()\n    .shaper(ShaperBackend::DirectWrite)\n    .renderer(RendererBackend::DirectWrite)\n    .enable_directwrite_caching(true)\n    .build()?;\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#macos","level":3,"title":"macOS","text":"<pre><code>#[cfg(target_os = \"macos\")]\nlet pipeline = PipelineBuilder::new()\n    .shaper(ShaperBackend::CoreText)\n    .renderer(RendererBackend::CoreGraphics)\n    .enable_coretext_optimization(true)\n    .build()?;\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#linux","level":3,"title":"Linux","text":"<pre><code>#[cfg(target_os = \"linux\")]\nlet pipeline = PipelineBuilder::new()\n    .shaper(ShaperBackend::HarfBuzz)\n    .renderer(RendererBackend::Skia)\n    .enable_fontconfig(true)\n    .build()?;\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#network-storage","level":2,"title":"Network &amp; Storage","text":"","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#efficient-font-loading","level":3,"title":"Efficient Font Loading","text":"<pre><code>// Stream fonts from network\nasync fn load_font_from_url(url: &amp;str) -&gt; Result&lt;Font&gt; {\n    let response = reqwest::get(url).await?;\n    let bytes = response.bytes().await?;\n    Font::from_bytes(&amp;bytes)\n}\n\n// Load fonts lazily\nstruct LazyFont {\n    url: String,\n    font: Option&lt;Font&gt;,\n}\n\nimpl LazyFont {\n    async fn get_font(&amp;mut self) -&gt; Result&lt;&amp;Font&gt; {\n        if self.font.is_none() {\n            self.font = Some(load_font_from_url(&amp;self.url).await?);\n        }\n        Ok(self.font.as_ref().unwrap())\n    }\n}\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#batch-processing","level":3,"title":"Batch Processing","text":"<pre><code>// Process multiple jobs efficiently\nasync fn process_batch(jobs: Vec&lt;RenderJob&gt;) -&gt; Result&lt;Vec&lt;RenderResult&gt;&gt; {\n    // Preload all fonts once\n    let mut fonts = HashMap::new();\n    for job in &amp;jobs {\n        if !fonts.contains_key(&amp;job.font_path) {\n            fonts.insert(job.font_path.clone(), load_font(&amp;job.font_path).await?);\n        }\n    }\n\n    // Process jobs in parallel\n    let results: Vec&lt;_&gt; = futures::future::join_all(\n        jobs.into_iter().map(|job| async move {\n            render_job(job, &amp;fonts).await\n        })\n    ).await;\n\n    Ok(results.into_iter().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?)\n}\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#performance-monitoring","level":2,"title":"Performance Monitoring","text":"","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#real-time-metrics","level":3,"title":"Real-time Metrics","text":"<pre><code>struct PerformanceMonitor {\n    render_times: VecDeque&lt;Duration&gt;,\n    memory_usage: VecDeque&lt;usize&gt;,\n    cache_hit_rates: VecDeque&lt;f64&gt;,\n}\n\nimpl PerformanceMonitor {\n    fn record_render(&amp;mut self, duration: Duration) {\n        self.render_times.push_back(duration);\n        if self.render_times.len() &gt; 1000 {\n            self.render_times.pop_front();\n        }\n    }\n\n    fn average_render_time(&amp;self) -&gt; Duration {\n        let total: Duration = self.render_times.iter().sum();\n        total / self.render_times.len() as u32\n    }\n\n    fn is_performance_degraded(&amp;self) -&gt; bool {\n        let avg = self.average_render_time();\n        let recent = self.render_times.back().unwrap();\n        *recent &gt; avg * 2 // 2x slower than average\n    }\n}\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#debug-tools","level":3,"title":"Debug Tools","text":"<pre><code>// Performance debugging utilities\npub fn debug_pipeline_performance(pipeline: &amp;Pipeline) {\n    println!(\"=== Pipeline Performance ===\");\n    println!(\"Font cache size: {} bytes\", pipeline.font_cache_size());\n    println!(\"Shaping cache hits: {}\", pipeline.shaping_cache_hits());\n    println!(\"Render cache hits: {}\", pipeline.render_cache_hits());\n    println!(\"Memory usage: {} bytes\", pipeline.memory_usage());\n\n    // Backend-specific info\n    if let Some(harfbuzz) = pipeline.harfbuzz_backend() {\n        println!(\"HarfBuzz cache size: {}\", harfbuzz.cache_size());\n    }\n}\n</code></pre>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#optimization-checklist","level":2,"title":"Optimization Checklist","text":"","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#before-optimization","level":3,"title":"Before Optimization","text":"<ul> <li> Profile current performance</li> <li> Identify bottlenecks (shaping vs rendering)</li> <li> Measure memory usage</li> <li> Check cache hit rates</li> </ul>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#quick-optimizations","level":3,"title":"Quick Optimizations","text":"<ul> <li> Enable appropriate platform backends</li> <li> Configure font caching</li> <li> Use output-specific renderers</li> <li> Preload frequently used fonts</li> </ul>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#advanced-optimizations","level":3,"title":"Advanced Optimizations","text":"<ul> <li> Implement custom caching strategies</li> <li> Use parallel processing for batches</li> <li> Enable GPU acceleration when available</li> <li> Optimize memory allocation patterns</li> </ul>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"22-performance-optimization/#monitoring","level":3,"title":"Monitoring","text":"<ul> <li> Set up performance metrics</li> <li> Monitor memory usage over time</li> <li> Track cache effectiveness</li> <li> Alert on performance regression</li> </ul> <p>Performance optimization starts with measurement. Profile first, then optimize the bottlenecks. Use platform-specific backends when available, implement smart caching, and monitor continuously to maintain speed.</p>","path":["Advanced Topics","Performance Optimization"],"tags":[]},{"location":"23-deployment-integration/","level":1,"title":"Deployment &amp; Integration","text":"<p>Deploy TypF in production environments and integrate with existing systems.</p>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#production-deployment","level":2,"title":"Production Deployment","text":"","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#server-architecture","level":3,"title":"Server Architecture","text":"<pre><code>// Production service with TYPF\nuse std::sync::Arc;\nuse tokio::sync::Semaphore;\n\nstruct TextRenderService {\n    pipeline: Arc&lt;Pipeline&gt;,\n    semaphore: Arc&lt;Semaphore&gt;, // Limit concurrent renders\n}\n\nimpl TextRenderService {\n    fn new() -&gt; Result&lt;Self&gt; {\n        let pipeline = Arc::new(\n            PipelineBuilder::new()\n                .shaper(ShaperBackend::HarfBuzz)\n                .renderer(RendererBackend::Skia)\n                .enable_font_cache(true)\n                .cache_size(500 * 1024 * 1024) // 500MB\n                .build()?\n        );\n\n        Ok(Self {\n            pipeline,\n            semaphore: Arc::new(Semaphore::new(100)), // Max 100 concurrent\n        })\n    }\n\n    async fn render_text(&amp;self, request: RenderRequest) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {\n        let _permit = self.semaphore.acquire().await?;\n\n        tokio::task::spawn_blocking(move || {\n            let result = self.pipeline.render_text(&amp;request.text, &amp;request.font, &amp;request.options)?;\n            result.as_png()\n        }).await?\n    }\n}\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#docker-deployment","level":3,"title":"Docker Deployment","text":"<pre><code># Dockerfile\nFROM rust:1.75-slim as builder\n\nWORKDIR /app\nCOPY . .\nRUN cargo build --release --features \"shaping-harfbuzz,render-skia\"\n\nFROM debian:bookworm-slim\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    libfontconfig1 \\\n    libharfbuzz0b \\\n    libskia0 \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\nCOPY --from=builder /app/target/release/typf-cli /usr/local/bin/\nCOPY --from=builder /app/examples/fonts/ /app/fonts/\n\nWORKDIR /app\nEXPOSE 8080\nCMD [\"typf-cli\", \"serve\", \"--host\", \"0.0.0.0\", \"--port\", \"8080\"]\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#kubernetes-configuration","level":3,"title":"Kubernetes Configuration","text":"<pre><code># k8s-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: typf-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: typf-service\n  template:\n    metadata:\n      labels:\n        app: typf-service\n    spec:\n      containers:\n      - name: typf\n        image: typf:latest\n        ports:\n        - containerPort: 8080\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"1Gi\"\n            cpu: \"1000m\"\n        env:\n        - name: TYPF_FONT_CACHE_SIZE\n          value: \"500MB\"\n        - name: TYPF_MAX_CONCURRENT\n          value: \"100\"\n        volumeMounts:\n        - name: fonts\n          mountPath: /app/fonts\n      volumes:\n      - name: fonts\n        configMap:\n          name: font-files\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#web-service-integration","level":2,"title":"Web Service Integration","text":"","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#http-api-server","level":3,"title":"HTTP API Server","text":"<pre><code>use axum::{extract::Query, http::StatusCode, response::Json};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize)]\nstruct RenderQuery {\n    text: String,\n    font: String,\n    size: Option&lt;u32&gt;,\n    width: Option&lt;u32&gt;,\n    height: Option&lt;u32&gt;,\n    format: Option&lt;String&gt;,\n}\n\n#[derive(Serialize)]\nstruct RenderResponse {\n    success: bool,\n    data: Option&lt;String&gt;, // Base64 encoded image\n    error: Option&lt;String&gt;,\n}\n\nasync fn render_endpoint(\n    Query(query): Query&lt;RenderQuery&gt;,\n    service: axum::extract::State&lt;Arc&lt;TextRenderService&gt;&gt;\n) -&gt; Result&lt;Json&lt;RenderResponse&gt;, StatusCode&gt; {\n    let font = service.load_font(&amp;query.font).await\n        .map_err(|_| StatusCode::BAD_REQUEST)?;\n\n    let options = RenderOptions {\n        font_size: query.size.unwrap_or(16),\n        width: query.width.unwrap_or(800),\n        height: query.height.unwrap_or(600),\n        ..Default::default()\n    };\n\n    let request = RenderRequest {\n        text: query.text,\n        font,\n        options,\n    };\n\n    match service.render_text(request).await {\n        Ok(png_data) =&gt; {\n            let base64 = base64::encode(png_data);\n            Ok(Json(RenderResponse {\n                success: true,\n                data: Some(format!(\"data:image/png;base64,{}\", base64)),\n                error: None,\n            }))\n        }\n        Err(e) =&gt; Ok(Json(RenderResponse {\n            success: false,\n            data: None,\n            error: Some(e.to_string()),\n        }))\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let service = Arc::new(TextRenderService::new().unwrap());\n\n    let app = axum::Router::new()\n        .route(\"/render\", axum::routing::get(render_endpoint))\n        .with_state(service)\n        .route(\"/health\", axum::routing::get(health_check));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:8080\").await.unwrap();\n    axum::serve(listener, app).await.unwrap();\n}\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#fastapi-integration-python","level":3,"title":"FastAPI Integration (Python)","text":"<pre><code>from fastapi import FastAPI, HTTPException, Query\nfrom fastapi.responses import Response\nimport base64\nimport typf\n\napp = FastAPI(title=\"TypF Render Service\")\n\n# Initialize TypF once\ntypf_instance = typf.Typf()\ntypf_instance.load_font(\"Roboto-Regular.ttf\")\n\n@app.get(\"/render\")\nasync def render_text(\n    text: str,\n    font: str = \"Roboto-Regular.ttf\",\n    size: int = 16,\n    width: int = 800,\n    height: int = 600,\n    format: str = \"png\"\n):\n    try:\n        result = typf_instance.render_text(\n            text=text,\n            font_path=font,\n            font_size=size,\n            width=width,\n            height=height\n        )\n\n        if format == \"png\":\n            png_data = result.as_png()\n            return Response(content=png_data, media_type=\"image/png\")\n        elif format == \"svg\":\n            svg_data = result.as_svg().decode('utf-8')\n            return Response(content=svg_data, media_type=\"image/svg+xml\")\n        elif format == \"base64\":\n            png_data = result.as_png()\n            base64_data = base64.b64encode(png_data).decode()\n            return {\"success\": True, \"data\": base64_data}\n        else:\n            raise HTTPException(status_code=400, detail=\"Unsupported format\")\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\", \"fonts_loaded\": len(typf_instance.list_fonts())}\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#database-integration","level":2,"title":"Database Integration","text":"","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#font-storage","level":3,"title":"Font Storage","text":"<pre><code>-- Font management schema\nCREATE TABLE fonts (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL UNIQUE,\n    family VARCHAR(255) NOT NULL,\n    style VARCHAR(100) NOT NULL,\n    file_data BYTEA NOT NULL,\n    file_hash VARCHAR(64) NOT NULL UNIQUE,\n    file_size INTEGER NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW(),\n    last_used TIMESTAMP\n);\n\n-- Render job tracking\nCREATE TABLE render_jobs (\n    id SERIAL PRIMARY KEY,\n    text TEXT NOT NULL,\n    font_id INTEGER REFERENCES fonts(id),\n    options JSONB NOT NULL,\n    status VARCHAR(50) NOT NULL DEFAULT 'pending',\n    result_data BYTEA,\n    created_at TIMESTAMP DEFAULT NOW(),\n    completed_at TIMESTAMP,\n    error_message TEXT\n);\n\n-- Indexes for performance\nCREATE INDEX idx_fonts_family ON fonts(family);\nCREATE INDEX idx_fonts_last_used ON fonts(last_used);\nCREATE INDEX idx_render_jobs_status ON render_jobs(status);\nCREATE INDEX idx_render_jobs_created ON render_jobs(created_at);\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#caching-layer","level":3,"title":"Caching Layer","text":"<pre><code>use redis::{Commands, RedisError};\n\nstruct RedisFontCache {\n    client: redis::Client,\n    ttl: u64, // Time to live in seconds\n}\n\nimpl RedisFontCache {\n    fn new(redis_url: &amp;str) -&gt; Result&lt;Self&gt; {\n        let client = redis::Client::open(redis_url)?;\n        Ok(Self { client, ttl: 3600 })\n    }\n\n    fn cache_render(&amp;self, key: &amp;str, data: &amp;[u8]) -&gt; Result&lt;()&gt; {\n        let mut con = self.client.get_connection()?;\n        con.set_ex(key, data, self.ttl)?;\n        Ok(())\n    }\n\n    fn get_cached_render(&amp;self, key: &amp;str) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {\n        let mut con = self.client.get_connection()?;\n        let result: Option&lt;Vec&lt;u8&gt;&gt; = con.get(key)?;\n        Ok(result)\n    }\n\n    fn cache_key(&amp;self, text: &amp;str, font_id: u32, options: &amp;RenderOptions) -&gt; String {\n        format!(\"render:{}:{}:{}\", \n                hash_string(text), \n                font_id, \n                hash_options(options))\n    }\n}\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#message-queue-integration","level":2,"title":"Message Queue Integration","text":"","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#background-processing","level":3,"title":"Background Processing","text":"<pre><code>use lapin::{Channel, Connection, ConnectionProperties, Queue};\nuse tokio-executor-trait::TokioExecutorTrait;\n\nstruct QueueWorker {\n    channel: Channel,\n    pipeline: Arc&lt;Pipeline&gt;,\n}\n\nimpl QueueWorker {\n    async fn new(amqp_url: &amp;str, pipeline: Arc&lt;Pipeline&gt;) -&gt; Result&lt;Self&gt; {\n        let conn = Connection::connect(amqp_url, ConnectionProperties::default().with_executor(Tokio)).await?;\n        let channel = conn.create_channel().await?;\n\n        let queue = channel.queue_declare(\n            \"render_jobs\",\n            lapin::options::QueueDeclareOptions::default(),\n            lapin::types::FieldTable::default()\n        ).await?;\n\n        Ok(Self { channel, pipeline })\n    }\n\n    async fn start_worker(&amp;self) -&gt; Result&lt;()&gt; {\n        let consumer = self.channel\n            .basic_consumer(\"render_jobs\", \"worker\", lapin::options::BasicConsumeOptions::default(), lapin::types::FieldTable::default())\n            .await?;\n\n        consumer.set_delegate(move |delivery| async move {\n            if let Some(delivery) = delivery {\n                let job: RenderJob = serde_json::from_slice(&amp;delivery.data)?;\n\n                match self.process_job(job).await {\n                    Ok(_) =&gt; {\n                        delivery.ack(lapin::options::BasicAckOptions::default()).await?;\n                    }\n                    Err(e) =&gt; {\n                        log::error!(\"Job failed: {}\", e);\n                        delivery.nack(lapin::options::BasicNackOptions::default()).await?;\n                    }\n                }\n            }\n        });\n\n        Ok(())\n    }\n\n    async fn process_job(&amp;self, job: RenderJob) -&gt; Result&lt;()&gt; {\n        let font = self.load_font_by_id(job.font_id).await?;\n        let result = self.pipeline.render_text(&amp;job.text, &amp;font, &amp;job.options)?;\n\n        // Store result or send to callback\n        self.store_result(job.id, &amp;result).await?;\n        Ok(())\n    }\n}\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#job-producer","level":3,"title":"Job Producer","text":"<pre><code>import pika\nimport json\nimport uuid\n\nclass RenderJobProducer:\n    def __init__(self, amqp_url: str):\n        self.connection = pika.BlockingConnection(pika.URLParameters(amqp_url))\n        self.channel = self.connection.channel()\n        self.channel.queue_declare(queue='render_jobs')\n\n    def submit_render_job(self, text: str, font_name: str, options: dict, callback_url: str = None):\n        job = {\n            'id': str(uuid.uuid4()),\n            'text': text,\n            'font_name': font_name,\n            'options': options,\n            'callback_url': callback_url,\n            'submitted_at': datetime.utcnow().isoformat()\n        }\n\n        self.channel.basic_publish(\n            exchange='',\n            routing_key='render_jobs',\n            body=json.dumps(job),\n            properties=pika.BasicProperties(\n                delivery_mode=2,  # make message persistent\n            )\n        )\n\n        return job['id']\n\n# Usage example\nproducer = RenderJobProducer('amqp://localhost')\njob_id = producer.submit_render_job(\n    text=\"Hello, World!\",\n    font_name=\"Roboto-Regular\",\n    options={'size': 24, 'width': 400, 'height': 100},\n    callback_url=\"https://api.example.com/render-complete\"\n)\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#monitoring-observability","level":2,"title":"Monitoring &amp; Observability","text":"","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#metrics-collection","level":3,"title":"Metrics Collection","text":"<pre><code>use prometheus::{Counter, Histogram, Gauge, IntGauge};\n\nstruct RenderMetrics {\n    // Request metrics\n    render_requests_total: Counter,\n    render_duration: Histogram,\n\n    // System metrics\n    active_fonts: IntGauge,\n    memory_usage: Gauge,\n    cache_hit_rate: Gauge,\n\n    // Error metrics\n    render_errors_total: Counter,\n    font_load_errors_total: Counter,\n}\n\nimpl RenderMetrics {\n    fn new() -&gt; Self {\n        Self {\n            render_requests_total: Counter::new(\"typf_render_requests_total\", \"Total render requests\").unwrap(),\n            render_duration: Histogram::new(\"typf_render_duration_seconds\", \"Render duration\").unwrap(),\n            active_fonts: IntGauge::new(\"typf_active_fonts\", \"Number of active fonts\").unwrap(),\n            memory_usage: Gauge::new(\"typf_memory_usage_bytes\", \"Memory usage in bytes\").unwrap(),\n            cache_hit_rate: Gauge::new(\"typf_cache_hit_rate\", \"Cache hit rate\").unwrap(),\n            render_errors_total: Counter::new(\"typf_render_errors_total\", \"Total render errors\").unwrap(),\n            font_load_errors_total: Counter::new(\"typf_font_load_errors_total\", \"Total font load errors\").unwrap(),\n        }\n    }\n\n    fn record_render(&amp;self, duration: Duration, success: bool) {\n        self.render_requests_total.inc();\n        self.render_duration.observe(duration.as_secs_f64());\n\n        if !success {\n            self.render_errors_total.inc();\n        }\n    }\n\n    fn update_system_metrics(&amp;self, pipeline: &amp;Pipeline) {\n        self.active_fonts.set(pipeline.font_count() as i64);\n        self.memory_usage.set(pipeline.memory_usage() as f64);\n        self.cache_hit_rate.set(pipeline.cache_hit_rate());\n    }\n}\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#health-checks","level":3,"title":"Health Checks","text":"<pre><code>use serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize)]\nstruct HealthStatus {\n    status: String,\n    version: String,\n    uptime_seconds: u64,\n    font_cache_size: usize,\n    memory_usage_mb: f64,\n    last_render_time: Option&lt;f64&gt;,\n    error_rate: f64,\n}\n\nimpl HealthStatus {\n    fn is_healthy(&amp;self) -&gt; bool {\n        self.status == \"healthy\" \n            &amp;&amp; self.memory_usage_mb &lt; 1000.0 // 1GB limit\n            &amp;&amp; self.error_rate &lt; 0.05 // 5% error rate limit\n    }\n}\n\nasync fn health_check(\n    metrics: axum::extract::State&lt;Arc&lt;RenderMetrics&gt;&gt;,\n    pipeline: axum::extract::State&lt;Arc&lt;Pipeline&gt;&gt;\n) -&gt; impl axum::response::IntoResponse {\n    let status = HealthStatus {\n        status: \"healthy\".to_string(),\n        version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        uptime_seconds: get_uptime_seconds(),\n        font_cache_size: pipeline.font_count(),\n        memory_usage_mb: pipeline.memory_usage() as f64 / (1024.0 * 1024.0),\n        last_render_time: metrics.last_render_duration(),\n        error_rate: metrics.error_rate(),\n    };\n\n    let status_code = if status.is_healthy() {\n        StatusCode::OK\n    } else {\n        StatusCode::SERVICE_UNAVAILABLE\n    };\n\n    (status_code, Json(status))\n}\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#scaling-strategies","level":2,"title":"Scaling Strategies","text":"","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#horizontal-scaling","level":3,"title":"Horizontal Scaling","text":"<pre><code># Docker Compose for scaling\nversion: '3.8'\nservices:\n  typf-service:\n    image: typf:latest\n    replicas: 3\n    deploy:\n      resources:\n        limits:\n          memory: 1G\n          cpus: '1.0'\n    environment:\n      - TYPF_REDIS_URL=redis://redis:6379\n      - TYPF_FONT_CACHE_SIZE=200MB\n    depends_on:\n      - redis\n      - postgres\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf\n    depends_on:\n      - typf-service\n\n  redis:\n    image: redis:alpine\n    volumes:\n      - redis_data:/data\n\n  postgres:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: typf\n      POSTGRES_USER: typf\n      POSTGRES_PASSWORD: password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#load-balancing","level":3,"title":"Load Balancing","text":"<pre><code># nginx.conf\nupstream typf_backend {\n    least_conn;\n    server typf-service-1:8080 max_fails=3 fail_timeout=30s;\n    server typf-service-2:8080 max_fails=3 fail_timeout=30s;\n    server typf-service-3:8080 max_fails=3 fail_timeout=30s;\n}\n\nserver {\n    listen 80;\n\n    location /render {\n        proxy_pass http://typf_backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_connect_timeout 5s;\n        proxy_send_timeout 30s;\n        proxy_read_timeout 30s;\n    }\n\n    location /health {\n        proxy_pass http://typf_backend;\n        access_log off;\n    }\n}\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#security-considerations","level":2,"title":"Security Considerations","text":"","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#authentication","level":3,"title":"Authentication","text":"<pre><code>use axum::extract::Request;\nuse axum::middleware::Next;\nuse axum::response::Response;\n\nasync fn auth_middleware(\n    request: Request,\n    next: Next,\n) -&gt; Result&lt;Response, StatusCode&gt; {\n    let auth_header = request.headers().get(\"Authorization\");\n\n    match auth_header {\n        Some(header) =&gt; {\n            if validate_api_token(header.to_str().unwrap()) {\n                Ok(next.run(request).await)\n            } else {\n                Err(StatusCode::UNAUTHORIZED)\n            }\n        }\n        None =&gt; Err(StatusCode::UNAUTHORIZED)\n    }\n}\n\nfn validate_api_token(token: &amp;str) -&gt; bool {\n    // Validate against database or config\n    token.starts_with(\"typf_\") &amp;&amp; token.len() == 32\n}\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#input-validation","level":3,"title":"Input Validation","text":"<pre><code>use validator::Validate;\n\n#[derive(Deserialize, Validate)]\nstruct ValidatedRenderRequest {\n    #[validate(length(min = 1, max = 10000))]\n    text: String,\n\n    #[validate(length(min = 1, max = 255))]\n    font: String,\n\n    #[validate(range(min = 8, max = 1024))]\n    size: u32,\n\n    #[validate(range(min = 64, max = 4096))]\n    width: u32,\n\n    #[validate(range(min = 64, max = 4096))]\n    height: u32,\n\n    #[validate(regex(path = \"^[a-zA-Z0-9_-]+$\"))]\n    format: String,\n}\n\nasync function validated_render_endpoint(Json(request): Json&lt;ValidatedRenderRequest&gt;) -&gt; Result&lt;Response, StatusCode&gt; {\n    if let Err(errors) = request.validate() {\n        return Err(StatusCode::BAD_REQUEST);\n    }\n\n    // Process validated request\n    process_render(request).await\n}\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#configuration-management","level":2,"title":"Configuration Management","text":"","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#environment-configuration","level":3,"title":"Environment Configuration","text":"<pre><code># production.toml\n[server]\nhost = \"0.0.0.0\"\nport = 8080\nworkers = 4\n\n[cache]\nfont_cache_size = \"500MB\"\nrender_cache_size = \"1GB\"\nredis_url = \"redis://localhost:6379\"\n\n[database]\nurl = \"postgresql://typf:password@localhost/typf\"\nmax_connections = 20\n\n[security]\napi_token_required = true\nrate_limit = 100 # requests per minute\nmax_text_length = 10000\n\n[fonts]\ndefault_font = \"Roboto-Regular.ttf\"\nfont_directory = \"/app/fonts\"\npreload_fonts = [\"Roboto-Regular.ttf\", \"OpenSans-Regular.ttf\"]\n</code></pre>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"23-deployment-integration/#dynamic-configuration","level":3,"title":"Dynamic Configuration","text":"<pre><code>use config::{Config, File, Environment};\n\nstruct AppConfig {\n    server: ServerConfig,\n    cache: CacheConfig,\n    database: DatabaseConfig,\n    security: SecurityConfig,\n    fonts: FontConfig,\n}\n\nimpl AppConfig {\n    fn from_env() -&gt; Result&lt;Self&gt; {\n        let config = Config::builder()\n            .add_source(File::with_name(\"config/default\"))\n            .add_source(File::with_name(\"config/production\").required(false))\n            .add_source(Environment::with_prefix(\"TYPF\"))\n            .build()?;\n\n        config.try_deserialize()\n    }\n\n    fn reload(&amp;mut self) -&gt; Result&lt;()&gt; {\n        let new_config = Self::from_env()?;\n        *self = new_config;\n        Ok(())\n    }\n}\n</code></pre> <p>Deploy TypF as a scalable web service with proper monitoring, caching, and security. Use container orchestration for production scaling and implement comprehensive observability to maintain performance.</p>","path":["Advanced Topics","Deployment &amp; Integration"],"tags":[]},{"location":"24-troubleshooting-best-practices/","level":1,"title":"Troubleshooting &amp; Best Practices","text":"<p>Solve common TypF problems and avoid pitfalls.</p>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#common-issues","level":2,"title":"Common Issues","text":"","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#font-loading-problems","level":3,"title":"Font Loading Problems","text":"<p>Problem: \"Font file not found\" error <pre><code>// Wrong: Relative path\nlet font = Font::from_file(\"Roboto.ttf\")?; \n\n// Right: Absolute or well-known path\nlet font = Font::from_file(\"/usr/share/fonts/Roboto.ttf\")?;\n// Or use the font database\nlet font = fontdb.load_font_by_name(\"Roboto\")?;\n</code></pre></p> <p>Problem: Corrupted font data <pre><code>// Validate font before loading\nfn safe_font_load(path: &amp;Path) -&gt; Result&lt;Font&gt; {\n    let data = std::fs::read(path)?;\n\n    // Check font magic bytes\n    if data.len() &lt; 12 {\n        return Err(TypfError::InvalidFont(\"File too small\"));\n    }\n\n    let magic = &amp;data[0:4];\n    if magic != b\"\\x00\\x01\\x00\\x00\" &amp;&amp; magic != b\"OTTO\" {\n        return Err(TypfError::InvalidFont(\"Invalid font format\"));\n    }\n\n    Font::from_bytes(&amp;data)\n}\n</code></pre></p>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#text-rendering-issues","level":3,"title":"Text Rendering Issues","text":"<p>Problem: Text appears upside down <pre><code>// Check coordinate system match\nlet mut options = RenderOptions::default();\noptions.transform = Transform::identity();\n// Don't set flip_y unless your coordinate system needs it\n\n// For web canvases (Y-down):\noptions.flip_y = true;\n\n// For PDF/printing (Y-up):\noptions.flip_y = false;\n</code></pre></p> <p>Problem: Wrong text size <pre><code>// Points vs pixels confusion\nlet options = RenderOptions {\n    // Use pixels for screen rendering\n    font_size: 16.0, // pixels\n    // Use points for print (72 points = 1 inch)\n    font_size: points_to_pixels(12.0), // 12pt = 16px at 96 DPI\n    dpi: 96.0,\n    ..Default::default()\n};\n</code></pre></p> <p>Problem: Text gets cut off <pre><code>// Ensure sufficient bounds\nlet text_bounds = measure_text(&amp;text, &amp;font, font_size)?;\nlet options = RenderOptions {\n    width: (text_bounds.width + padding) as u32,\n    height: (text_bounds.height + padding) as u32,\n    ..Default::default()\n};\n</code></pre></p>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#backend-selection-issues","level":3,"title":"Backend Selection Issues","text":"<p>Problem: Backend not available <pre><code>// Check availability before using\nfn choose_best_renderer() -&gt; RendererBackend {\n    if RendererBackend::Skia.is_available() {\n        RendererBackend::Skia\n    } else if RendererBackend::Orge.is_available() {\n        RendererBackend::Orge\n    } else {\n        panic!(\"No renderer available\");\n    }\n}\n\n// Or handle gracefully\nmatch pipeline.set_renderer(RendererBackend::Skia) {\n    Ok(_) =&gt; println!(\"Using Skia renderer\"),\n    Err(e) =&gt; {\n        println!(\"Skia not available, falling back to Orge: {}\", e);\n        pipeline.set_renderer(RendererBackend::Orge)?;\n    }\n}\n</code></pre></p> <p>Problem: Performance slower than expected <pre><code>// Profile to find the bottleneck\nlet start = std::time::Instant::now();\nlet shaped = pipeline.shape_text(text, &amp;font)?;\nlet shaping_time = start.elapsed();\n\nlet start = std::time::Instant::now();\nlet rendered = pipeline.render_shaped(&amp;shaped, &amp;options)?;\nlet render_time = start.elapsed();\n\nprintln!(\"Shaping: {:?}, Rendering: {:?}\", shaping_time, render_time);\n\n// If shaping is slow, try a different shaper\n// If rendering is slow, try GPU acceleration\n</code></pre></p>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#debugging-tools","level":2,"title":"Debugging Tools","text":"","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#built-in-diagnostics","level":3,"title":"Built-in Diagnostics","text":"<pre><code>// Enable debug mode\nlet pipeline = PipelineBuilder::new()\n    .debug_mode(true)\n    .enable_profiling(true)\n    .build()?;\n\n// Get detailed error information\nmatch pipeline.render_text(\"test\", &amp;font, &amp;options) {\n    Ok(result) =&gt; println!(\"Success\"),\n    Err(TypfError::ShapingError { source, details }) =&gt; {\n        eprintln!(\"Shaping failed: {}\", source);\n        eprintln!(\"Details: {}\", details);\n\n        // Try with simpler text\n        pipeline.render_text(\"simple\", &amp;font, &amp;options)?;\n    }\n    Err(e) =&gt; eprintln!(\"Other error: {}\", e),\n}\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#font-inspector","level":3,"title":"Font Inspector","text":"<pre><code>fn debug_font(font: &amp;Font) {\n    println!(\"Font Information:\");\n    println!(\"  Family: {}\", font.family_name());\n    println!(\"  Style: {}\", font.style_name());\n    println!(\"  Units per EM: {}\", font.units_per_em());\n    println!(\"  Ascender: {}\", font.ascender());\n    println!(\"  Descender: {}\", font.descender());\n    println!(\"  Line Gap: {}\", font.line_gap());\n\n    // Check glyph coverage\n    let test_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    for c in test_chars.chars() {\n        if let Some(glyph_id) = font.glyph_index(c) {\n            println!(\"  '{}' -&gt; glyph {}\", c, glyph_id);\n        } else {\n            println!(\"  '{}' -&gt; MISSING\", c);\n        }\n    }\n}\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#text-analysis","level":3,"title":"Text Analysis","text":"<pre><code>fn analyze_text(text: &amp;str) {\n    println!(\"Text Analysis:\");\n    println!(\"  Length: {} characters\", text.len());\n    println!(\"  Unicode: {} code points\", text.chars().count());\n\n    // Script detection\n    let scripts: HashSet&lt;_&gt; = text.chars()\n        .filter_map(|c| unicode_script::UnicodeScript::script(c))\n        .collect();\n\n    println!(\"  Scripts: {:?}\", scripts);\n\n    // Direction detection\n    let has_rtl = text.chars().any(|c| c.is_right_to_left());\n    println!(\"  Direction: {}\", if has_rtl { \"RTL\" } else { \"LTR\" });\n\n    // Complex characters\n    let complex_chars: Vec&lt;_&gt; = text.chars()\n        .filter(|c| !c.is_ascii() &amp;&amp; !c.is_alphanumeric())\n        .collect();\n\n    if !complex_chars.is_empty() {\n        println!(\"  Complex characters: {:?}\", complex_chars);\n    }\n}\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#performance-debugging","level":2,"title":"Performance Debugging","text":"","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#memory-leaks","level":3,"title":"Memory Leaks","text":"<pre><code>// Track font usage\nstruct FontTracker {\n    loaded_fonts: HashMap&lt;String, Weak&lt;Font&gt;&gt;,\n}\n\nimpl FontTracker {\n    fn load_font(&amp;mut self, path: &amp;str) -&gt; Result&lt;Font&gt; {\n        // Clean up stale references first\n        self.loaded_fonts.retain(|_, weak| weak.strong_count() &gt; 0);\n\n        if let Some(weak_font) = self.loaded_fonts.get(path) {\n            if let Some(font) = weak_font.upgrade() {\n                return Ok(font);\n            }\n        }\n\n        let font = Font::from_file(path)?;\n        self.loaded_fonts.insert(path.to_string(), Arc::downgrade(&amp;font));\n        Ok(font)\n    }\n}\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#cache-effectiveness","level":3,"title":"Cache Effectiveness","text":"<pre><code>fn monitor_cache_performance(cache: &amp;LRUCache&lt;String, Vec&lt;u8&gt;&gt;) {\n    let stats = cache.stats();\n    println!(\"Cache Statistics:\");\n    println!(\"  Hits: {}\", stats.hits());\n    println!(\"  Misses: {}\", stats.misses());\n    println!(\"  Hit rate: {:.2}%\", stats.hit_rate() * 100.0);\n\n    if stats.hit_rate() &lt; 0.8 {\n        eprintln!(\"Warning: Low cache hit rate. Consider increasing cache size.\");\n    }\n}\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#render-bottlenecks","level":3,"title":"Render Bottlenecks","text":"<pre><code>// Benchmark different approaches\nfn benchmark_approaches(text: &amp;str, font: &amp;Font) {\n    let iterations = 1000;\n\n    // Approach 1: Direct render\n    let start = Instant::now();\n    for _ in 0..iterations {\n        pipeline.render_text(text, font, &amp;options)?;\n    }\n    let direct_time = start.elapsed();\n\n    // Approach 2: Shape then render\n    let start = Instant::now();\n    let shaped = pipeline.shape_text(text, font)?;\n    for _ in 0..iterations {\n        pipeline.render_shaped(&amp;shaped, &amp;options)?;\n    }\n    let shaped_time = start.elapsed();\n\n    println!(\"Direct render: {:?}\", direct_time / iterations);\n    println!(\"Shape + render: {:?}\", shaped_time / iterations);\n\n    if shaped_time &lt; direct_time {\n        println!(\"Recommendation: Cache shaped results for repeated renders\");\n    }\n}\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#best-practices","level":2,"title":"Best Practices","text":"","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#font-management","level":3,"title":"Font Management","text":"<pre><code>// DO: Use a font database\nlet fontdb = FontDatabase::new();\nfontdb.load_system_fonts()?; // Load once\nfontdb.add_font_dir(\"./custom_fonts\")?;\n\n// DON'T: Load fonts repeatedly\nfor text in texts {\n    let font = Font::from_file(\"Roboto.ttf\")?; // Slow!\n    pipeline.render_text(text, &amp;font, &amp;options)?;\n}\n\n// DO: Reuse font handles\nlet font = fontdb.load_font_by_name(\"Roboto\")?;\nfor text in texts {\n    pipeline.render_text(text, &amp;font, &amp;options)?;\n}\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#error-handling","level":3,"title":"Error Handling","text":"<pre><code>// DO: Handle specific errors\nfn safe_render(pipeline: &amp;Pipeline, text: &amp;str, font: &amp;Font) -&gt; Option&lt;Bitmap&gt; {\n    match pipeline.render_text(text, font, &amp;options) {\n        Ok(bitmap) =&gt; Some(bitmap),\n        Err(TypfError::UnsupportedGlyph(c)) =&gt; {\n            // Replace unsupported characters\n            let safe_text = text.replace(c, \"�\");\n            pipeline.render_text(&amp;safe_text, font, &amp;options).ok()\n        }\n        Err(TypfError::FontNotLoaded) =&gt; {\n            eprintln!(\"Font not loaded, using fallback\");\n            fallback_pipeline.render_text(text, &amp;fallback_font, &amp;options).ok()\n        }\n        Err(e) =&gt; {\n            eprintln!(\"Render failed: {}\", e);\n            None\n        }\n    }\n}\n\n// DON'T: Use unwrap() in production code\nlet result = pipeline.render_text(text, font, &amp;options).unwrap(); // Crashes!\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#resource-management","level":3,"title":"Resource Management","text":"<pre><code>// DO: Use RAII for cleanup\nstruct RenderContext {\n    pipeline: Pipeline,\n    font_cache: FontCache,\n}\n\nimpl Drop for RenderContext {\n    fn drop(&amp;mut self) {\n        self.font_cache.clear(); // Free memory\n    }\n}\n\n// DO: Limit concurrent operations\nlet semaphore = Semaphore::new(10); // Max 10 renders\nasync def render_with_limit(text: &amp;str) -&gt; Result&lt;Bitmap&gt; {\n    let _permit = semaphore.acquire().await?;\n    pipeline.render_text(text, &amp;font, &amp;options)\n}\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#testing-strategies","level":3,"title":"Testing Strategies","text":"<pre><code>// DO: Test with diverse text samples\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_unicode_samples() {\n        let samples = [\n            \"Hello World\",                    // ASCII\n            \"Café résumé\",                    // Latin accents  \n            \"Москва\",                        // Cyrillic\n            \"北京\",                          // Chinese\n            \"تحية العالم\",                    // Arabic\n            \"🌍🚀💻\",                        // Emoji\n            \"Mixed: Hello تحية 🌍\",          // Mixed scripts\n        ];\n\n        for sample in samples {\n            let result = pipeline.render_text(sample, &amp;font, &amp;options);\n            assert!(result.is_ok(), \"Failed to render: {}\", sample);\n        }\n    }\n\n    #[test]\n    fn test_edge_cases() {\n        let edge_cases = [\n            \"\",              // Empty string\n            \" \",             // Space only\n            \"\\n\\t\\r\",       // Whitespace only\n            \"A\".repeat(10000), // Very long text\n            \"a\".repeat(1),   // Single character\n        ];\n\n        for case in edge_cases {\n            let result = pipeline.render_text(&amp;case, &amp;font, &amp;options);\n            assert!(result.is_ok(), \"Failed edge case: {:?}\", case);\n        }\n    }\n}\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#configuration-guidelines","level":2,"title":"Configuration Guidelines","text":"","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#production-settings","level":3,"title":"Production Settings","text":"<pre><code># production.toml\n[cache]\nfont_cache_size = \"500MB\"      # Balance memory and performance\nrender_cache_size = \"1GB\"\ncache_ttl = 3600              # 1 hour\n\n[performance]\nmax_concurrent_renders = 100   # Prevent overload\nenable_simd = true             # Use CPU optimizations\ngpu_acceleration = true        # Use GPU when available\n\n[fonts]\npreload_common = [\"Roboto\", \"OpenSans\", \"NotoSans\"]\nfont_search_paths = [\"/usr/share/fonts\", \"/app/fonts\"]\n\n[security]\nvalidate_fonts = true         # Check font integrity\nmax_font_size = \"50MB\"         # Prevent DoS\nmax_text_length = 10000       # Reasonable limits\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#development-settings","level":3,"title":"Development Settings","text":"<pre><code># development.toml\n[cache]\nfont_cache_size = \"100MB\"      # Smaller for dev\nenable_debug = true           # More logging\n\n[performance]\nmax_concurrent_renders = 4    # Don't overwhelm dev machine\nprofiling_mode = true         # Detailed metrics\n\n[debug]\nsave_intermediate = true      # For debugging\nvisualize_glyphs = true       # Visual debugging\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#security-considerations","level":2,"title":"Security Considerations","text":"","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#input-validation","level":3,"title":"Input Validation","text":"<pre><code>// DO: Validate all inputs\nfn validate_render_input(text: &amp;str, font_size: f32, bounds: (u32, u32)) -&gt; Result&lt;()&gt; {\n    if text.len() &gt; 10000 {\n        return Err(TypfError::InvalidInput(\"Text too long\"));\n    }\n\n    if font_size &lt; 1.0 || font_size &gt; 1000.0 {\n        return Err(TypfError::InvalidInput(\"Invalid font size\"));\n    }\n\n    if bounds.0 &gt; 10000 || bounds.1 &gt; 10000 {\n        return Err(TypfError::InvalidInput(\"Image dimensions too large\"));\n    }\n\n    // Check for potentially malicious content\n    if text.chars().any(|c| c.is_control() &amp;&amp; c != '\\n' &amp;&amp; c != '\\t') {\n        return Err(TypfError::InvalidInput(\"Contains control characters\"));\n    }\n\n    Ok(())\n}\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#resource-limits","level":3,"title":"Resource Limits","text":"<pre><code>// DO: Implement resource quotas\nstruct ResourceMonitor {\n    memory_used: AtomicUsize,\n    renders_per_second: AtomicU64,\n    last_reset: AtomicU64,\n}\n\nimpl ResourceMonitor {\n    fn check_limits(&amp;self) -&gt; Result&lt;()&gt; {\n        let memory_mb = self.memory_used.load(Ordering::Relaxed) / (1024 * 1024);\n        if memory_mb &gt; 1024 {\n            return Err(TypfError::ResourceLimit(\"Memory usage too high\"));\n        }\n\n        let now = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)?\n            .as_secs();\n\n        let last_reset = self.last_reset.load(Ordering::Relaxed);\n        if now - last_reset &gt; 60 {\n            // Reset counter every minute\n            self.renders_per_second.store(0, Ordering::Relaxed);\n            self.last_reset.store(now, Ordering::Relaxed);\n        }\n\n        let rps = self.renders_per_second.load(Ordering::Relaxed);\n        if rps &gt; 1000 {\n            return Err(TypfError::RateLimit(\"Too many requests per second\"));\n        }\n\n        Ok(())\n    }\n}\n</code></pre>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#monitoring-checklist","level":2,"title":"Monitoring Checklist","text":"","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#health-indicators","level":3,"title":"Health Indicators","text":"<ul> <li> Render Success Rate: Should be &gt;95%</li> <li> Average Render Time: Should be &lt;100ms for typical text</li> <li> Memory Usage: Stable, not growing continuously</li> <li> Cache Hit Rate: Should be &gt;80% for repeated workloads</li> <li> Error Distribution: No single error type dominating</li> </ul>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"24-troubleshooting-best-practices/#alert-conditions","level":3,"title":"Alert Conditions","text":"<pre><code># Example monitoring script\ncheck_typf_health() {\n    local success_rate=$(curl -s http://typf-service/metrics | grep render_success_rate | awk '{print $2}')\n    local avg_time=$(curl -s http://typf-service/metrics | grep render_duration_avg | awk '{print $2}')\n    local memory_mb=$(curl -s http://typf-service/metrics | grep memory_usage_bytes | awk '{print $2/1024/1024}')\n\n    if (( $(echo \"$success_rate &lt; 0.95\" | bc -l) )); then\n        alert \"Low success rate: $success_rate\"\n    fi\n\n    if (( $(echo \"$avg_time &gt; 0.1\" | bc -l) )); then\n        alert \"Slow renders: ${avg_time}s\"\n    fi\n\n    if (( $(echo \"$memory_mb &gt; 1024\" | bc -l) )); then\n        alert \"High memory usage: ${memory_mb}MB\"\n    fi\n}\n</code></pre> <p>Debug systematically: isolate the problem, check inputs, verify backend availability, and measure performance. Always handle errors gracefully and monitor key health indicators in production.</p>","path":["Advanced Topics","Troubleshooting &amp; Best Practices"],"tags":[]},{"location":"INDEX/","level":1,"title":"TypF Documentation","text":"<p>TypF turns text into pixels, fast. </p> <p>Note: TypF is a community project by FontLab and is currently published under an evaluation license.</p>","path":["TypF Documentation"],"tags":[]},{"location":"INDEX/#quick-start","level":2,"title":"Quick Start","text":"<pre><code># Build everything\n./build.sh\n\n# Render text now\ntypf-cli render --text \"Hello 世界\" --font font.ttf\n\n# Python version\npython -m typf render --text \"Hello 世界\" --font font.ttf\n</code></pre>","path":["TypF Documentation"],"tags":[]},{"location":"INDEX/#what-this-is","level":2,"title":"What This Is","text":"<p>TypF turns text into pixels, fast. Six stages: Input → Unicode → Font → Shape → Render → Export. Each stage has multiple backends. You pick what works for your system.</p> <p>Performance: ~50ns per glyph with SIMD, multi-level caching, zero-copy font loading.</p>","path":["TypF Documentation"],"tags":[]},{"location":"INDEX/#documentation","level":1,"title":"Documentation","text":"","path":["TypF Documentation"],"tags":[]},{"location":"INDEX/#getting-started","level":2,"title":"Getting Started","text":"<ul> <li>01 - Introduction - Why TypF exists</li> <li>02 - Quick Start - Running in minutes</li> <li>03 - Architecture - How it works</li> <li>04 - Installation - Setup details</li> </ul>","path":["TypF Documentation"],"tags":[]},{"location":"INDEX/#core-system","level":2,"title":"Core System","text":"<ul> <li>05 - Pipeline - The six stages explained</li> <li>06 - Backends - Mixing and matching components</li> <li>07 - Memory - Font caching without leaks</li> <li>08 - Performance - Speed basics</li> </ul>","path":["TypF Documentation"],"tags":[]},{"location":"INDEX/#shaping-text","level":2,"title":"Shaping Text","text":"<ul> <li>09 - HarfBuzz - Cross-platform Unicode shaping</li> <li>10 - Platform Shapers - CoreText and DirectWrite</li> <li>11 - ICU+HarfBuzz - Complex text processing</li> <li>12 - None Shaper - Testing and debugging</li> </ul>","path":["TypF Documentation"],"tags":[]},{"location":"INDEX/#rendering-pixels","level":2,"title":"Rendering Pixels","text":"<ul> <li>13 - Skia - Hardware-accelerated rendering</li> <li>14 - Platform Renderers - CoreGraphics and Direct2D</li> <li>15 - Orge - Pure Rust foundation</li> <li>16 - Zeno - Vector quality output</li> </ul>","path":["TypF Documentation"],"tags":[]},{"location":"INDEX/#using-typf","level":2,"title":"Using TYPF","text":"<ul> <li>17 - Rust API - The core Rust library</li> <li>18 - Python API - Python bindings</li> <li>19 - CLI - Command-line tools</li> <li>20 - WebAssembly - Browser rendering</li> </ul>","path":["TypF Documentation"],"tags":[]},{"location":"INDEX/#production","level":2,"title":"Production","text":"<ul> <li>21 - Export Formats - PNG, SVG, PNM, JSON</li> <li>22 - Performance - Production tuning</li> <li>23 - Deployment - Production patterns</li> <li>24 - Troubleshooting - Problem solving</li> </ul>","path":["TypF Documentation"],"tags":[]},{"location":"INDEX/#how-to-read-this","level":2,"title":"How to Read This","text":"<p>New to TYPF? Start with Getting Started.</p> <p>Understanding core concepts? Read Core System.</p> <p>Need specific backend info? Jump to Shaping or Rendering sections.</p> <p>Building applications? Check the Using TypF section.</p> <p>Deploying to production? Read the Production section.</p> <p>Each chapter builds on previous ones, but you can jump to what you need.</p>","path":["TypF Documentation"],"tags":[]},{"location":"INDEX/#code-examples","level":2,"title":"Code Examples","text":"<p>Every chapter includes working code examples. Rust and Python side by side. Copy, paste, run. No toy examples—real code you can use.</p>","path":["TypF Documentation"],"tags":[]},{"location":"INDEX/#get-help","level":2,"title":"Get Help","text":"<p>Stuck? Check the relevant chapter first. Each section has troubleshooting examples. File GitHub issues for bugs you find.</p> <p>TypF: Fast text rendering that works.</p>","path":["TypF Documentation"],"tags":[]}]}