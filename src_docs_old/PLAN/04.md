# Part 04: API Design & Compatibility

## Overview

This document defines TypF's public API design, including the core Rust API, compatibility layers for major text layout libraries, and the overall developer experience strategy.

**Reference Implementation in old-typf:**
- `old-typf/crates/typf-api/src/session.rs` – Current Session API, Session::render() pattern
- `old-typf/crates/typf-api/src/backend.rs` – Backend factory and selection logic
- Study how SessionBuilder currently validates and delegates to backends
- Note: v2.0 refactors this into a Pipeline-based architecture (cleaner separation)

## 4.1 Core Public API

### Main Entry Point

```rust
// typf/src/lib.rs

/// The main entry point for TypF
pub struct Typf {
    pipeline: Arc<Pipeline>,
    config: TypfConfig,
}

impl Typf {
    /// Create a new TypF instance with default configuration
    pub fn new() -> Result<Self, TypfError> {
        Self::with_config(TypfConfig::default())
    }

    /// Create with custom configuration
    pub fn with_config(config: TypfConfig) -> Result<Self, TypfError> {
        let pipeline = Pipeline::from_config(&config)?;
        Ok(Self {
            pipeline: Arc::new(pipeline),
            config,
        })
    }

    /// Render text with default options
    pub fn render(&self, text: &str) -> Result<RenderOutput, TypfError> {
        self.render_with_options(text, RenderOptions::default())
    }

    /// Render text with custom options
    pub fn render_with_options(
        &self,
        text: &str,
        options: RenderOptions
    ) -> Result<RenderOutput, TypfError> {
        let request = InputSpec::builder()
            .text(text)
            .options(options)
            .build()?;

        self.pipeline.execute(request)
    }

    /// Shape text without rendering
    pub fn shape(&self, text: &str) -> Result<ShapingResult, TypfError> {
        self.shape_with_options(text, ShapingOptions::default())
    }

    /// Shape text with custom options
    pub fn shape_with_options(
        &self,
        text: &str,
        options: ShapingOptions
    ) -> Result<ShapingResult, TypfError> {
        let request = InputSpec::builder()
            .text(text)
            .shaping_only()
            .options(options)
            .build()?;

        let output = self.pipeline.execute(request)?;
        match output {
            RenderOutput::Shaped(result) => Ok(result),
            _ => Err(TypfError::UnexpectedOutput),
        }
    }
}
```

### Configuration API

```rust
// typf/src/config.rs

#[derive(Debug, Clone, Builder)]
pub struct TypfConfig {
    /// Shaping backend to use
    #[builder(default = "ShapingBackend::Auto")]
    pub shaping_backend: ShapingBackend,

    /// Rendering backend to use
    #[builder(default = "RenderBackend::Auto")]
    pub render_backend: RenderBackend,

    /// Cache configuration
    #[builder(default)]
    pub cache: CacheConfig,

    /// Thread pool configuration
    #[builder(default)]
    pub threading: ThreadingConfig,

    /// Font database configuration
    #[builder(default)]
    pub font_db: FontDbConfig,
}

#[derive(Debug, Clone, Builder)]
pub struct CacheConfig {
    /// Maximum number of cached fonts
    #[builder(default = "128")]
    pub max_fonts: usize,

    /// Maximum number of cached glyphs
    #[builder(default = "4096")]
    pub max_glyphs: usize,

    /// Enable memory mapping for fonts
    #[builder(default = "true")]
    pub mmap_fonts: bool,
}

#[derive(Debug, Clone, Builder)]
pub struct ThreadingConfig {
    /// Number of worker threads (0 = number of CPUs)
    #[builder(default = "0")]
    pub num_threads: usize,

    /// Enable parallel rendering
    #[builder(default = "true")]
    pub parallel: bool,
}

#[derive(Debug, Clone, Builder)]
pub struct FontDbConfig {
    /// Load system fonts on initialization
    #[builder(default = "true")]
    pub load_system_fonts: bool,

    /// Custom font directories
    #[builder(default)]
    pub font_dirs: Vec<PathBuf>,

    /// Font fallback chain
    #[builder(default)]
    pub fallbacks: Vec<String>,
}
```

### Render Options API

```rust
// typf/src/options.rs

#[derive(Debug, Clone, Builder)]
pub struct RenderOptions {
    // Font specification
    #[builder(setter(into))]
    pub font: FontSpec,

    // Typography
    #[builder(default = "16.0")]
    pub size: f32,

    #[builder(default)]
    pub letter_spacing: Option<f32>,

    #[builder(default)]
    pub word_spacing: Option<f32>,

    #[builder(default = "1.2")]
    pub line_height: f32,

    // Language and script
    #[builder(default, setter(into, strip_option))]
    pub language: Option<String>,

    #[builder(default)]
    pub script: Option<Script>,

    // OpenType features
    #[builder(default)]
    pub features: HashMap<Tag, u32>,

    // Variable font settings
    #[builder(default)]
    pub variations: HashMap<Tag, f32>,

    // Colors
    #[builder(default = "Color::BLACK")]
    pub foreground: Color,

    #[builder(default)]
    pub background: Option<Color>,

    // Output format
    #[builder(default = "OutputFormat::Png")]
    pub format: OutputFormat,

    // Rendering hints
    #[builder(default = "HintingMode::Full")]
    pub hinting: HintingMode,

    #[builder(default = "true")]
    pub antialiasing: bool,

    #[builder(default = "SubpixelMode::None")]
    pub subpixel: SubpixelMode,
}
```

### Font Specification API

```rust
// typf/src/font.rs

#[derive(Debug, Clone)]
pub enum FontSpec {
    /// System font by family name
    System(String),
    /// Font file path
    Path(PathBuf),
    /// Font from memory
    Memory(Arc<Vec<u8>>),
    /// Detailed font query
    Query(FontQuery),
}

#[derive(Debug, Clone, Builder)]
pub struct FontQuery {
    #[builder(setter(into))]
    pub family: String,

    #[builder(default = "400")]
    pub weight: u16,

    #[builder(default = "FontStyle::Normal")]
    pub style: FontStyle,

    #[builder(default = "FontStretch::Normal")]
    pub stretch: FontStretch,

    #[builder(default)]
    pub fallbacks: Vec<String>,
}

impl From<&str> for FontSpec {
    fn from(s: &str) -> Self {
        if s.ends_with(".ttf") || s.ends_with(".otf") || s.ends_with(".ttc") {
            FontSpec::Path(PathBuf::from(s))
        } else {
            FontSpec::System(s.to_string())
        }
    }
}
```

## 4.2 Fluent Builder Pattern

### Complete Usage Example

```rust
use typf::prelude::*;

// Simple usage
let result = Typf::new()?
    .render("Hello, World!")?;

// Advanced usage with builder pattern
let result = Typf::builder()
    .shaping_backend(ShapingBackend::HarfBuzz)
    .render_backend(RenderBackend::Skia)
    .cache(CacheConfig::builder()
        .max_fonts(256)
        .max_glyphs(8192)
        .build())
    .build()?
    .render_with_options(
        "مرحبا بالعالم",
        RenderOptions::builder()
            .font("Noto Sans Arabic")
            .size(48.0)
            .language("ar")
            .script(Script::Arabic)
            .features(hashmap! {
                tag!(b"liga") => 1,
                tag!(b"kern") => 1,
            })
            .foreground(Color::rgb(0x34, 0x98, 0xdb))
            .background(Color::WHITE)
            .format(OutputFormat::Svg)
            .build()
    )?;

// Batch rendering
let texts = vec!["First", "Second", "Third"];
let results: Vec<_> = texts
    .par_iter()
    .map(|text| typf.render(text))
    .collect::<Result<_, _>>()?;
```

## 4.3 Cosmic-Text Compatibility Layer

### Implementation

```rust
// typf-compat-cosmic/src/lib.rs

use cosmic_text::{Attrs, Family, Weight, Style, Stretch};
use typf::prelude::*;

/// Drop-in replacement for cosmic_text::FontSystem
pub struct FontSystem {
    inner: Arc<Typf>,
    db: Arc<FontDatabase>,
}

impl FontSystem {
    pub fn new() -> Self {
        let typf = Typf::builder()
            .shaping_backend(ShapingBackend::HarfBuzz)
            .build()
            .expect("Failed to initialize TYPF");

        Self {
            inner: Arc::new(typf),
            db: Arc::new(FontDatabase::new()),
        }
    }

    pub fn db(&self) -> &FontDatabase {
        &self.db
    }

    pub fn db_mut(&mut self) -> &mut FontDatabase {
        Arc::get_mut(&mut self.db).unwrap()
    }
}

/// Drop-in replacement for cosmic_text::Buffer
pub struct Buffer {
    text: String,
    attrs: Attrs,
    shaped: Option<ShapingResult>,
    metrics: Metrics,
    width_constraint: Option<f32>,
}

impl Buffer {
    pub fn new(font_system: &mut FontSystem, metrics: Metrics) -> Self {
        Self {
            text: String::new(),
            attrs: Attrs::new(),
            shaped: None,
            metrics,
            width_constraint: None,
        }
    }

    pub fn set_text(
        &mut self,
        font_system: &mut FontSystem,
        text: &str,
        attrs: Attrs,
        shaping: Shaping
    ) {
        self.text = text.to_string();
        self.attrs = attrs;

        // Convert cosmic-text attrs to TypF options
        let options = self.convert_attrs_to_options(&attrs, shaping);

        // Shape with TYPF
        self.shaped = font_system.inner
            .shape_with_options(&self.text, options)
            .ok();
    }

    pub fn set_size(&mut self, font_system: &mut FontSystem, size: f32) {
        self.metrics.font_size = size;
        // Re-shape if needed
        if !self.text.is_empty() {
            self.reshape(font_system);
        }
    }

    pub fn set_wrap(&mut self, font_system: &mut FontSystem, wrap: Wrap) {
        match wrap {
            Wrap::None => self.width_constraint = None,
            Wrap::Word(width) | Wrap::Glyph(width) => {
                self.width_constraint = Some(width);
            }
        }
        self.reshape(font_system);
    }

    fn convert_attrs_to_options(&self, attrs: &Attrs, shaping: Shaping) -> ShapingOptions {
        ShapingOptions::builder()
            .size(self.metrics.font_size)
            .font(self.attrs_to_font_spec(attrs))
            .features(if shaping == Shaping::Advanced {
                hashmap! {
                    tag!(b"kern") => 1,
                    tag!(b"liga") => 1,
                    tag!(b"calt") => 1,
                }
            } else {
                HashMap::new()
            })
            .build()
    }

    fn attrs_to_font_spec(&self, attrs: &Attrs) -> FontSpec {
        FontSpec::Query(FontQuery::builder()
            .family(match attrs.family {
                Family::Name(ref name) => name.clone(),
                Family::Serif => "serif".to_string(),
                Family::SansSerif => "sans-serif".to_string(),
                Family::Monospace => "monospace".to_string(),
                _ => "sans-serif".to_string(),
            })
            .weight(attrs.weight.0)
            .style(match attrs.style {
                Style::Normal => FontStyle::Normal,
                Style::Italic => FontStyle::Italic,
                Style::Oblique => FontStyle::Oblique,
            })
            .stretch(match attrs.stretch {
                Stretch::UltraCondensed => FontStretch::UltraCondensed,
                Stretch::ExtraCondensed => FontStretch::ExtraCondensed,
                Stretch::Condensed => FontStretch::Condensed,
                Stretch::SemiCondensed => FontStretch::SemiCondensed,
                Stretch::Normal => FontStretch::Normal,
                Stretch::SemiExpanded => FontStretch::SemiExpanded,
                Stretch::Expanded => FontStretch::Expanded,
                Stretch::ExtraExpanded => FontStretch::ExtraExpanded,
                Stretch::UltraExpanded => FontStretch::UltraExpanded,
            })
            .build())
    }

    pub fn layout_runs(&self) -> LayoutRunIter {
        LayoutRunIter::new(self.shaped.as_ref())
    }
}

/// Iterator over layout runs
pub struct LayoutRunIter<'a> {
    shaped: Option<&'a ShapingResult>,
    index: usize,
}

impl<'a> Iterator for LayoutRunIter<'a> {
    type Item = LayoutRun<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        let shaped = self.shaped?;
        if self.index >= shaped.runs.len() {
            return None;
        }

        let run = &shaped.runs[self.index];
        self.index += 1;

        Some(LayoutRun {
            glyphs: run.glyphs.iter().map(|g| LayoutGlyph {
                start: g.cluster as usize,
                end: g.cluster as usize + 1,
                w: g.x_advance,
                x: g.x_offset,
                y: g.y_offset,
                glyph_id: g.glyph_id as u16,
                color: Color::rgb(0, 0, 0),
            }).collect(),
            line_y: 0.0,
            line_w: run.advance_width,
        })
    }
}
```

### Usage Example

```rust
// Using typf-compat-cosmic exactly like cosmic-text

use typf_compat_cosmic::{FontSystem, Buffer, Metrics, Attrs, Shaping};

let mut font_system = FontSystem::new();
let mut buffer = Buffer::new(&mut font_system, Metrics::new(16.0, 20.0));

buffer.set_text(
    &mut font_system,
    "Hello cosmic-text compatibility!",
    Attrs::new(),
    Shaping::Advanced
);

for run in buffer.layout_runs() {
    for glyph in run.glyphs {
        println!("Glyph {} at ({}, {})", glyph.glyph_id, glyph.x, glyph.y);
    }
}
```

## 4.4 Parley Compatibility Layer

### Implementation

```rust
// typf-compat-parley/src/lib.rs

use parley::{FontContext, LayoutContext, Layout, Style};
use typf::prelude::*;

/// Drop-in replacement for parley::FontContext
pub struct TypfFontContext {
    typf: Arc<Typf>,
    font_db: Arc<FontDatabase>,
}

impl TypfFontContext {
    pub fn new() -> Self {
        Self {
            typf: Arc::new(Typf::new().unwrap()),
            font_db: Arc::new(FontDatabase::new()),
        }
    }
}

impl FontContext for TypfFontContext {
    type Font = TypfFont;

    fn resolve_font(&mut self, style: &Style) -> Option<Self::Font> {
        let spec = FontSpec::Query(FontQuery::builder()
            .family(style.font_family.clone())
            .weight(style.font_weight)
            .style(if style.font_style == "italic" {
                FontStyle::Italic
            } else {
                FontStyle::Normal
            })
            .build());

        self.font_db.load_font(&spec).ok().map(|font| TypfFont {
            inner: font,
        })
    }

    fn font_metrics(&self, font: &Self::Font) -> FontMetrics {
        let metrics = font.inner.metrics();
        FontMetrics {
            units_per_em: font.inner.upem() as u32,
            ascent: metrics.ascent,
            descent: metrics.descent,
            line_gap: metrics.line_gap,
        }
    }
}

/// Drop-in replacement for parley::LayoutContext
pub struct TypfLayoutContext {
    font_ctx: TypfFontContext,
    typf: Arc<Typf>,
}

impl TypfLayoutContext {
    pub fn new(font_ctx: TypfFontContext) -> Self {
        Self {
            typf: font_ctx.typf.clone(),
            font_ctx,
        }
    }
}

impl LayoutContext for TypfLayoutContext {
    type Layout = TypfLayout;

    fn create_layout(&mut self, text: &str, style: &Style) -> Self::Layout {
        let options = RenderOptions::builder()
            .font(FontSpec::System(style.font_family.clone()))
            .size(style.font_size)
            .letter_spacing(style.letter_spacing)
            .word_spacing(style.word_spacing)
            .language(style.language.clone())
            .build();

        let shaped = self.typf
            .shape_with_options(text, options.into())
            .unwrap();

        TypfLayout {
            text: text.to_string(),
            shaped,
            style: style.clone(),
        }
    }

    fn break_lines(&mut self, layout: &mut Self::Layout, max_width: f32) {
        // Implement line breaking using TYPF's line breaking
        // This would use typf-unicode's line breaking capabilities
        // For now, simplified implementation
        layout.max_width = Some(max_width);
    }
}

pub struct TypfLayout {
    text: String,
    shaped: ShapingResult,
    style: Style,
    max_width: Option<f32>,
}

impl Layout for TypfLayout {
    fn width(&self) -> f32 {
        self.shaped.advance_width
    }

    fn height(&self) -> f32 {
        self.style.font_size * 1.2 // Simplified
    }

    fn baseline(&self) -> f32 {
        self.style.font_size * 0.8 // Simplified
    }
}
```

## 4.5 Piet Text Compatibility Layer

### Implementation

```rust
// typf-compat-piet/src/lib.rs

use piet::{Text, TextLayout, TextLayoutBuilder, FontFamily};
use typf::prelude::*;

/// Drop-in replacement for piet text backend
pub struct TypfText {
    typf: Arc<Typf>,
    default_font: String,
}

impl TypfText {
    pub fn new() -> Self {
        Self {
            typf: Arc::new(Typf::new().unwrap()),
            default_font: "sans-serif".to_string(),
        }
    }
}

impl Text for TypfText {
    type Font = TypfFont;
    type FontBuilder = TypfFontBuilder;
    type TextLayout = TypfTextLayout;
    type TextLayoutBuilder = TypfTextLayoutBuilder;

    fn font_family(&mut self, family_name: &str) -> Option<FontFamily> {
        Some(FontFamily::new_unchecked(family_name))
    }

    fn new_font_by_name(
        &mut self,
        name: &str,
        size: impl Into<f64>
    ) -> Self::FontBuilder {
        TypfFontBuilder {
            family: name.to_string(),
            size: size.into() as f32,
            weight: 400,
            style: FontStyle::Normal,
        }
    }

    fn new_text_layout(&mut self, text: impl Into<String>) -> Self::TextLayoutBuilder {
        TypfTextLayoutBuilder {
            typf: self.typf.clone(),
            text: text.into(),
            font: None,
            width: None,
            options: RenderOptions::default(),
        }
    }
}

pub struct TypfFontBuilder {
    family: String,
    size: f32,
    weight: u16,
    style: FontStyle,
}

impl piet::FontBuilder for TypfFontBuilder {
    type Out = TypfFont;

    fn build(self) -> Result<Self::Out, piet::Error> {
        Ok(TypfFont {
            spec: FontSpec::Query(FontQuery::builder()
                .family(self.family)
                .weight(self.weight)
                .style(self.style)
                .build()),
            size: self.size,
        })
    }
}

pub struct TypfFont {
    spec: FontSpec,
    size: f32,
}

pub struct TypfTextLayoutBuilder {
    typf: Arc<Typf>,
    text: String,
    font: Option<TypfFont>,
    width: Option<f64>,
    options: RenderOptions,
}

impl TextLayoutBuilder for TypfTextLayoutBuilder {
    type Out = TypfTextLayout;

    fn max_width(mut self, width: f64) -> Self {
        self.width = Some(width);
        self
    }

    fn alignment(mut self, _alignment: piet::TextAlignment) -> Self {
        // Store alignment in options
        self
    }

    fn font(mut self, font: impl Into<FontFamily>, size: impl Into<f64>) -> Self {
        self.font = Some(TypfFont {
            spec: FontSpec::System(font.into().name().to_string()),
            size: size.into() as f32,
        });
        self
    }

    fn text_color(mut self, color: piet::Color) -> Self {
        self.options.foreground = Color::rgba(
            (color.as_rgba_u32() >> 24) as u8,
            (color.as_rgba_u32() >> 16) as u8,
            (color.as_rgba_u32() >> 8) as u8,
            (color.as_rgba_u32()) as u8,
        );
        self
    }

    fn build(self) -> Result<Self::Out, piet::Error> {
        let mut options = self.options;
        if let Some(font) = self.font {
            options.font = font.spec;
            options.size = font.size;
        }

        let shaped = self.typf
            .shape_with_options(&self.text, options.into())
            .map_err(|e| piet::Error::BackendError(Box::new(e)))?;

        Ok(TypfTextLayout {
            text: self.text,
            shaped,
            width: self.width,
        })
    }
}

pub struct TypfTextLayout {
    text: String,
    shaped: ShapingResult,
    width: Option<f64>,
}

impl TextLayout for TypfTextLayout {
    fn size(&self) -> piet::kurbo::Size {
        piet::kurbo::Size::new(
            self.shaped.advance_width as f64,
            self.shaped.bounding_box.height() as f64
        )
    }

    fn trailing_whitespace_width(&self) -> f64 {
        // Calculate trailing whitespace
        0.0
    }

    fn image_bounds(&self) -> piet::kurbo::Rect {
        piet::kurbo::Rect::new(
            self.shaped.bounding_box.x_min as f64,
            self.shaped.bounding_box.y_min as f64,
            self.shaped.bounding_box.x_max as f64,
            self.shaped.bounding_box.y_max as f64,
        )
    }

    fn text(&self) -> &str {
        &self.text
    }

    fn line_text(&self, _line_number: usize) -> Option<&str> {
        Some(&self.text) // Simplified single-line
    }

    fn line_metric(&self, _line_number: usize) -> Option<piet::LineMetric> {
        Some(piet::LineMetric {
            start_offset: 0,
            end_offset: self.text.len(),
            trailing_whitespace: 0,
            baseline: self.shaped.bounding_box.y_max as f64,
            height: self.shaped.bounding_box.height() as f64,
        })
    }

    fn line_count(&self) -> usize {
        1 // Simplified single-line
    }

    fn hit_test_point(&self, point: piet::kurbo::Point) -> piet::HitTestPoint {
        // Implement hit testing
        piet::HitTestPoint::default()
    }

    fn hit_test_text_position(&self, idx: usize) -> piet::HitTestPosition {
        // Implement position testing
        piet::HitTestPosition::default()
    }
}
```

## 4.6 GlyphBrush Compatibility Layer

### Implementation

```rust
// typf-compat-glyph-brush/src/lib.rs

use glyph_brush_layout::{
    GlyphPositioner, Layout, SectionGeometry, SectionText,
    GlyphPosition, PositionedGlyph,
};
use typf::prelude::*;

/// Drop-in replacement for glyph_brush GlyphPositioner
pub struct TypfPositioner {
    typf: Arc<Typf>,
}

impl TypfPositioner {
    pub fn new() -> Self {
        Self {
            typf: Arc::new(Typf::new().unwrap()),
        }
    }
}

impl GlyphPositioner for TypfPositioner {
    type Font = TypfFont;

    fn calculate_glyphs(
        &self,
        fonts: &[Self::Font],
        geometry: &SectionGeometry,
        sections: &[SectionText],
    ) -> Vec<PositionedGlyph> {
        let mut all_glyphs = Vec::new();
        let mut y_offset = 0.0;

        for section in sections {
            let font = &fonts[section.font_id];

            let options = RenderOptions::builder()
                .font(font.spec.clone())
                .size(section.scale.y)
                .foreground(Color::rgba(
                    (section.color[0] * 255.0) as u8,
                    (section.color[1] * 255.0) as u8,
                    (section.color[2] * 255.0) as u8,
                    (section.color[3] * 255.0) as u8,
                ))
                .build();

            let shaped = self.typf
                .shape_with_options(section.text, options.into())
                .unwrap();

            // Convert TypF glyphs to glyph_brush format
            for glyph in &shaped.glyphs {
                all_glyphs.push(PositionedGlyph {
                    glyph: rusttype::GlyphId(glyph.glyph_id as u32),
                    font_id: section.font_id,
                    section_index: sections.iter().position(|s| s == section).unwrap(),
                    byte_index: glyph.cluster as usize,
                    position: rusttype::Point {
                        x: glyph.x_offset,
                        y: y_offset + glyph.y_offset,
                    },
                    scale: rusttype::Scale {
                        x: section.scale.x,
                        y: section.scale.y,
                    },
                });
            }

            y_offset += shaped.advance_height;
        }

        self.apply_layout(all_glyphs, section.layout, geometry)
    }

    fn bounds_rect(&self, geometry: &SectionGeometry) -> Rect<f32> {
        Rect {
            min: Point { x: 0.0, y: 0.0 },
            max: Point {
                x: geometry.bounds.0,
                y: geometry.bounds.1,
            },
        }
    }

    fn recalculate_glyphs(
        &self,
        previous: GlyphPositions,
        change: GlyphChange,
        fonts: &[Self::Font],
        geometry: &SectionGeometry,
        sections: &[SectionText],
    ) -> Vec<PositionedGlyph> {
        // For simplicity, recalculate all
        self.calculate_glyphs(fonts, geometry, sections)
    }
}

impl TypfPositioner {
    fn apply_layout(
        &self,
        mut glyphs: Vec<PositionedGlyph>,
        layout: Layout,
        geometry: &SectionGeometry,
    ) -> Vec<PositionedGlyph> {
        use glyph_brush_layout::Layout;

        match layout {
            Layout::SingleLine(h_align) => {
                // Apply horizontal alignment
                let width = glyphs.iter()
                    .map(|g| g.position.x)
                    .max_by(|a, b| a.partial_cmp(b).unwrap())
                    .unwrap_or(0.0);

                let offset = match h_align {
                    glyph_brush_layout::HorizontalAlign::Left => 0.0,
                    glyph_brush_layout::HorizontalAlign::Center => {
                        (geometry.bounds.0 - width) / 2.0
                    }
                    glyph_brush_layout::HorizontalAlign::Right => {
                        geometry.bounds.0 - width
                    }
                };

                for glyph in &mut glyphs {
                    glyph.position.x += offset;
                }
            }
            Layout::Wrap(wrap) => {
                // Implement word wrapping
                // This would use typf-unicode's line breaking
            }
        }

        glyphs
    }
}

pub struct TypfFont {
    spec: FontSpec,
}

impl TypfFont {
    pub fn from_bytes(data: Vec<u8>) -> Result<Self, FontError> {
        Ok(Self {
            spec: FontSpec::Memory(Arc::new(data)),
        })
    }

    pub fn from_file(path: impl AsRef<Path>) -> Result<Self, FontError> {
        Ok(Self {
            spec: FontSpec::Path(path.as_ref().to_path_buf()),
        })
    }
}
```

## 4.7 Migration Guide

### From cosmic-text

```rust
// Before (cosmic-text)
use cosmic_text::{FontSystem, Buffer, Attrs, Metrics};

let mut font_system = FontSystem::new();
let mut buffer = Buffer::new(&mut font_system, Metrics::new(16.0, 20.0));
buffer.set_text(&mut font_system, "Hello", Attrs::new(), Shaping::Advanced);

// After (typf-compat-cosmic)
use typf_compat_cosmic::{FontSystem, Buffer, Attrs, Metrics};

let mut font_system = FontSystem::new();  // Same API!
let mut buffer = Buffer::new(&mut font_system, Metrics::new(16.0, 20.0));
buffer.set_text(&mut font_system, "Hello", Attrs::new(), Shaping::Advanced);
```

### From raw TYPF

```rust
// Direct TypF API (if you want full control)
use typf::prelude::*;

let typf = Typf::builder()
    .shaping_backend(ShapingBackend::HarfBuzz)
    .render_backend(RenderBackend::Skia)
    .build()?;

let result = typf.render_with_options(
    "Hello, TYPF!",
    RenderOptions::builder()
        .font("Inter")
        .size(48.0)
        .format(OutputFormat::Png)
        .build()
)?;
```

## 4.8 Error Handling and Diagnostics

### Rich Error Types

```rust
// typf/src/error.rs

#[derive(Debug, Error)]
pub enum TypfError {
    #[error("Font not found: {0}")]
    FontNotFound(String),

    #[error("Feature not compiled: {feature}. Enable it with: cargo build --features {feature}")]
    FeatureNotCompiled { feature: String },

    #[error("Backend combination not supported: shaping={shaping:?}, render={render:?}")]
    UnsupportedBackendCombination {
        shaping: ShapingBackend,
        render: RenderBackend,
    },

    #[error("Shaping failed: {0}")]
    ShapingFailed(#[source] ShapingError),

    #[error("Rendering failed: {0}")]
    RenderingFailed(#[source] RenderError),

    #[error(transparent)]
    Io(#[from] std::io::Error),

    #[error(transparent)]
    Other(#[from] anyhow::Error),
}

// Provide helpful recovery suggestions
impl TypfError {
    pub fn recovery_suggestion(&self) -> Option<String> {
        match self {
            Self::FontNotFound(name) => Some(format!(
                "Try installing the font or use a fallback: \
                RenderOptions::builder().font_fallbacks(vec![\"Arial\", \"sans-serif\"])"
            )),
            Self::FeatureNotCompiled { feature } => Some(format!(
                "Rebuild with: cargo build --features {}", feature
            )),
            Self::UnsupportedBackendCombination { shaping, render } => Some(format!(
                "Try using compatible backends: \
                ({:?}, {:?}) or ({:?}, {:?})",
                ShapingBackend::HarfBuzz, RenderBackend::Orge,
                ShapingBackend::Auto, RenderBackend::Auto
            )),
            _ => None,
        }
    }
}
```

## 4.9 Performance Monitoring API

```rust
// typf/src/metrics.rs

#[derive(Debug, Clone, Default)]
pub struct PerformanceMetrics {
    pub unicode_processing_ns: u64,
    pub font_loading_ns: u64,
    pub shaping_ns: u64,
    pub rendering_ns: u64,
    pub export_ns: u64,
    pub total_ns: u64,
    pub cache_hits: u64,
    pub cache_misses: u64,
}

impl Typf {
    /// Render with performance metrics
    pub fn render_with_metrics(
        &self,
        text: &str,
        options: RenderOptions
    ) -> Result<(RenderOutput, PerformanceMetrics), TypfError> {
        let start = std::time::Instant::now();
        let mut metrics = PerformanceMetrics::default();

        // Execute pipeline with timing
        // ...

        metrics.total_ns = start.elapsed().as_nanos() as u64;
        Ok((output, metrics))
    }
}
```

## Next Steps

Part 05 will detail the build system and feature flag configuration for selective compilation and optimized builds.
