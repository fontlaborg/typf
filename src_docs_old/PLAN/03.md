# Part 03: Font Handling & Dependencies

## Overview

This document details TypF's font handling architecture, built exclusively on read-fonts and skrifa, with zero-copy loading, intelligent caching, and complete removal of ttf-parser dependencies.

## 3.1 Dependency Strategy

### Core Font Dependencies

| Purpose | Library | Version | Justification |
|---------|---------|---------|---------------|
| Font Parsing | `read-fonts` | 0.36+ | Modern, zero-alloc parser with full OpenType support |
| Font Metrics | `skrifa` | 0.39+ | High-level API for metrics, outlines, variations |
| Font Discovery | `fontdb` | 0.21+ | System font enumeration (optional) |
| Memory Mapping | `memmap2` | 0.9+ | Zero-copy font loading |
| Caching | `lru` | 0.12+ | LRU cache for font instances |
| | `dashmap` | 6.1+ | Concurrent hash map for glyph cache |

### Removed Dependencies

```toml
# NEVER use these in TypF:
# ttf-parser - replaced by read-fonts
# rustybuzz - replaced by harfbuzz-rs
# fontdue - incompatible goals
# font-kit - replaced by custom implementation
# swash - replaced by skrifa
```

## 3.2 Zero-Copy Font Architecture

### Memory-Mapped Font Loading

**Reference Implementation in old-typf:**
- `old-typf/crates/typf-fontdb/src/lib.rs`: FontDatabase with mmap + fontdb integration
- `old-typf/crates/typf-fontdb/src/font_cache.rs`: FontLoader with zero-copy patterns
- System font discovery via `fontdb::Database`
- Multi-threaded font instance caching with LRU eviction
- **KEY PATTERN**: Static lifetime management via Box::leak() (intentional, cached globally)

```rust
// typf-fontdb/src/loader.rs
// NOTE: Base implementation on old-typf/crates/typf-fontdb/src/font_cache.rs

use memmap2::{Mmap, MmapOptions};
use read_fonts::{FontRef, TableProvider};
use skrifa::Font as SkrifaFont;

/// Zero-copy font data holder
pub struct FontData {
    /// Memory-mapped font file
    mmap: Option<Mmap>,
    /// Raw font bytes (for embedded fonts)
    bytes: Option<Vec<u8>>,
    /// Pointer to actual data
    data: &'static [u8],
}

impl FontData {
    /// Load font from file system with memory mapping
    pub fn from_file(path: &Path) -> Result<Self, FontLoadError> {
        let file = File::open(path)
            .map_err(|e| FontLoadError::IoError(e))?;

        // Memory map the file
        let mmap = unsafe {
            MmapOptions::new()
                .map(&file)
                .map_err(|e| FontLoadError::MmapError(e))?
        };

        // Convert to 'static lifetime
        // Safe because we keep the mmap alive
        let data: &'static [u8] = unsafe {
            std::slice::from_raw_parts(
                mmap.as_ptr(),
                mmap.len()
            )
        };

        Ok(FontData {
            mmap: Some(mmap),
            bytes: None,
            data,
        })
    }

    /// Load font from memory
    pub fn from_bytes(bytes: Vec<u8>) -> Self {
        // Leak the bytes to get 'static lifetime
        let leaked = Box::leak(bytes.into_boxed_slice());

        FontData {
            mmap: None,
            bytes: None,
            data: leaked,
        }
    }

    /// Get raw font data
    pub fn as_bytes(&self) -> &'static [u8] {
        self.data
    }
}
```

### Font Instance Management

```rust
// typf-fontdb/src/instance.rs

/// A loaded and parsed font instance
pub struct FontInstance {
    /// Underlying font data
    data: Arc<FontData>,
    /// read-fonts font reference
    font_ref: FontRef<'static>,
    /// skrifa font instance
    skrifa_font: SkrifaFont<'static>,
    /// Font metadata
    metadata: FontMetadata,
    /// Normalized variation coordinates
    variations: VariationCoordinates,
}

impl FontInstance {
    pub fn new(data: Arc<FontData>, index: u32) -> Result<Self, FontLoadError> {
        // Parse with read-fonts
        let font_ref = FontRef::new(data.as_bytes())
            .map_err(|e| FontLoadError::ParseError(e))?;

        // Create skrifa instance
        let skrifa_font = SkrifaFont::new(font_ref.clone())
            .map_err(|e| FontLoadError::SkrifaError(e))?;

        // Extract metadata
        let metadata = Self::extract_metadata(&font_ref, &skrifa_font)?;

        Ok(FontInstance {
            data,
            font_ref,
            skrifa_font,
            metadata,
            variations: VariationCoordinates::default(),
        })
    }

    fn extract_metadata(
        font_ref: &FontRef,
        skrifa_font: &SkrifaFont
    ) -> Result<FontMetadata, FontLoadError> {
        use read_fonts::tables::{head::Head, name::Name, os2::Os2};

        let head = font_ref.head()
            .map_err(|_| FontLoadError::MissingTable("head"))?;
        let name = font_ref.name()
            .ok(); // Name table is optional
        let os2 = font_ref.os2()
            .ok(); // OS/2 table is optional

        let metrics = skrifa_font.metrics();

        Ok(FontMetadata {
            family_name: Self::extract_name(&name, 1)
                .unwrap_or_else(|| "Unknown".to_string()),
            style_name: Self::extract_name(&name, 2)
                .unwrap_or_else(|| "Regular".to_string()),
            upem: head.units_per_em(),
            ascent: metrics.ascent,
            descent: metrics.descent,
            line_gap: metrics.line_gap,
            weight: os2.as_ref().map(|t| t.weight()).unwrap_or(400),
            width: os2.as_ref().map(|t| t.width()).unwrap_or(5),
            is_variable: !skrifa_font.variation_axes().is_empty(),
            variation_axes: Self::extract_variation_axes(skrifa_font),
            supported_scripts: Self::extract_supported_scripts(font_ref),
            available_features: Self::extract_available_features(font_ref),
        })
    }

    /// Apply variation settings
    pub fn set_variations(&mut self, settings: &HashMap<Tag, f32>) -> Result<(), FontLoadError> {
        let axes = self.skrifa_font.variation_axes();

        // Validate and normalize coordinates
        let mut coords = Vec::new();
        for axis in axes {
            let value = settings
                .get(&axis.tag)
                .copied()
                .unwrap_or(axis.default);

            // Clamp to axis range
            let normalized = value.clamp(axis.min, axis.max);
            coords.push((axis.tag, normalized));
        }

        self.variations = VariationCoordinates::from_user_coords(&coords);

        // Re-instantiate skrifa font with variations
        self.skrifa_font = self.skrifa_font
            .with_variations(&self.variations)
            .map_err(|e| FontLoadError::VariationError(e))?;

        Ok(())
    }
}
```

## 3.3 Font Database and Discovery

### System Font Discovery

```rust
// typf-fontdb/src/database.rs

use fontdb::Database as SystemFontDb;

pub struct FontDatabase {
    /// System font database (optional)
    system_db: Option<SystemFontDb>,
    /// Custom font registry
    custom_fonts: DashMap<FontKey, Arc<FontInstance>>,
    /// Font file cache (path -> data)
    file_cache: DashMap<PathBuf, Arc<FontData>>,
    /// Font family lookup
    family_map: DashMap<String, Vec<FontKey>>,
    /// LRU cache for frequently used fonts
    lru_cache: Mutex<LruCache<FontKey, Arc<FontInstance>>>,
}

impl FontDatabase {
    pub fn new() -> Self {
        let mut db = Self {
            system_db: None,
            custom_fonts: DashMap::new(),
            file_cache: DashMap::new(),
            family_map: DashMap::new(),
            lru_cache: Mutex::new(LruCache::new(NonZeroUsize::new(128).unwrap())),
        };

        // Initialize system font database
        db.load_system_fonts();
        db
    }

    fn load_system_fonts(&mut self) {
        let mut system_db = SystemFontDb::new();
        system_db.load_system_fonts();

        // Index all system fonts
        for face in system_db.faces() {
            let key = FontKey {
                source: FontSource::System,
                family: face.family.clone(),
                weight: face.weight.0,
                style: face.style,
                stretch: face.stretch,
                index: face.index,
            };

            self.family_map
                .entry(face.family.clone())
                .or_default()
                .push(key);
        }

        self.system_db = Some(system_db);
    }

    /// Load a font by specification
    pub fn load_font(&self, spec: &FontSpec) -> Result<Arc<FontInstance>, FontLoadError> {
        // Check LRU cache first
        let key = FontKey::from_spec(spec);
        if let Some(cached) = self.lru_cache.lock().get(&key) {
            return Ok(cached.clone());
        }

        // Load font data
        let font_data = match &spec.source {
            FontSource::Path(path) => {
                // Check file cache
                if let Some(cached) = self.file_cache.get(path) {
                    cached.clone()
                } else {
                    // Load and cache
                    let data = Arc::new(FontData::from_file(path)?);
                    self.file_cache.insert(path.clone(), data.clone());
                    data
                }
            }
            FontSource::SystemFamily(family) => {
                // Resolve from system database
                self.resolve_system_font(family, &spec.attributes)?
            }
            FontSource::Memory(bytes) => {
                Arc::new(FontData::from_bytes(bytes.clone()))
            }
        };

        // Create font instance
        let instance = Arc::new(FontInstance::new(font_data, spec.index)?);

        // Apply variations if specified
        if !spec.variations.is_empty() {
            let mut mutable_instance = (*instance).clone();
            mutable_instance.set_variations(&spec.variations)?;
            let instance = Arc::new(mutable_instance);
        }

        // Cache the instance
        self.lru_cache.lock().put(key, instance.clone());
        self.custom_fonts.insert(key, instance.clone());

        Ok(instance)
    }

    fn resolve_system_font(
        &self,
        family: &str,
        attributes: &FontAttributes
    ) -> Result<Arc<FontData>, FontLoadError> {
        let system_db = self.system_db.as_ref()
            .ok_or(FontLoadError::SystemFontsNotLoaded)?;

        // Find best matching face
        let face_id = system_db
            .query(&fontdb::Query {
                families: &[fontdb::Family::Name(family)],
                weight: fontdb::Weight(attributes.weight),
                stretch: fontdb::Stretch::from(attributes.width),
                style: if attributes.italic {
                    fontdb::Style::Italic
                } else {
                    fontdb::Style::Normal
                },
            })
            .ok_or(FontLoadError::FontNotFound(family.to_string()))?;

        let face = system_db.face(face_id)
            .ok_or(FontLoadError::FontNotFound(family.to_string()))?;

        // Load font file
        let path = face.source.as_ref()
            .and_then(|s| s.as_path())
            .ok_or(FontLoadError::FontNotFound(family.to_string()))?;

        Ok(Arc::new(FontData::from_file(path)?))
    }
}
```

### Font Fallback Chain

```rust
// typf-fontdb/src/fallback.rs

pub struct FontFallbackChain {
    /// Primary font
    primary: Arc<FontInstance>,
    /// Fallback fonts by script
    fallbacks: HashMap<Script, Vec<Arc<FontInstance>>>,
    /// Generic fallback fonts
    generic_fallbacks: Vec<Arc<FontInstance>>,
}

impl FontFallbackChain {
    pub fn new(primary: Arc<FontInstance>) -> Self {
        Self {
            primary,
            fallbacks: HashMap::new(),
            generic_fallbacks: Vec::new(),
        }
    }

    pub fn add_fallback_for_script(
        &mut self,
        script: Script,
        font: Arc<FontInstance>
    ) {
        self.fallbacks
            .entry(script)
            .or_default()
            .push(font);
    }

    pub fn add_generic_fallback(&mut self, font: Arc<FontInstance>) {
        self.generic_fallbacks.push(font);
    }

    /// Find font that can render a character
    pub fn find_font_for_char(&self, ch: char, script: Script) -> Option<Arc<FontInstance>> {
        // Try primary font first
        if self.primary.skrifa_font.charmap().map(ch).is_some() {
            return Some(self.primary.clone());
        }

        // Try script-specific fallbacks
        if let Some(fallbacks) = self.fallbacks.get(&script) {
            for font in fallbacks {
                if font.skrifa_font.charmap().map(ch).is_some() {
                    return Some(font.clone());
                }
            }
        }

        // Try generic fallbacks
        for font in &self.generic_fallbacks {
            if font.skrifa_font.charmap().map(ch).is_some() {
                return Some(font.clone());
            }
        }

        None
    }
}
```

## 3.4 Glyph Caching

### Multi-Level Glyph Cache

```rust
// typf-fontdb/src/cache.rs

/// Key for glyph cache lookup
#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub struct GlyphCacheKey {
    pub font_key: FontKey,
    pub glyph_id: u32,
    pub size: OrderedFloat<f32>,
    pub variations: Vec<(Tag, OrderedFloat<f32>)>,
    pub hinting: HintingMode,
    pub subpixel_position: SubpixelPosition,
}

/// Cached glyph data
pub struct CachedGlyph {
    /// Glyph metrics
    pub metrics: GlyphMetrics,
    /// Rasterized bitmap (optional)
    pub bitmap: Option<GlyphBitmap>,
    /// Vector outline (optional)
    pub outline: Option<GlyphOutline>,
    /// Shaping information
    pub shaping_data: Option<GlyphShapingData>,
}

pub struct GlyphCache {
    /// L1 cache: Recently used glyphs (small, fast)
    l1_cache: DashMap<GlyphCacheKey, Arc<CachedGlyph>>,
    /// L2 cache: All glyphs (larger, slower)
    l2_cache: DashMap<GlyphCacheKey, Arc<CachedGlyph>>,
    /// Cache statistics
    stats: CacheStats,
}

impl GlyphCache {
    const L1_SIZE: usize = 256;
    const L2_SIZE: usize = 4096;

    pub fn new() -> Self {
        Self {
            l1_cache: DashMap::with_capacity(Self::L1_SIZE),
            l2_cache: DashMap::with_capacity(Self::L2_SIZE),
            stats: CacheStats::default(),
        }
    }

    pub fn get(&self, key: &GlyphCacheKey) -> Option<Arc<CachedGlyph>> {
        // Try L1 first
        if let Some(glyph) = self.l1_cache.get(key) {
            self.stats.l1_hits.fetch_add(1, Ordering::Relaxed);
            return Some(glyph.clone());
        }

        // Try L2
        if let Some(glyph) = self.l2_cache.get(key) {
            self.stats.l2_hits.fetch_add(1, Ordering::Relaxed);
            // Promote to L1
            self.promote_to_l1(key, glyph.clone());
            return Some(glyph.clone());
        }

        self.stats.misses.fetch_add(1, Ordering::Relaxed);
        None
    }

    pub fn insert(&self, key: GlyphCacheKey, glyph: Arc<CachedGlyph>) {
        // Insert into L1
        if self.l1_cache.len() >= Self::L1_SIZE {
            // Evict oldest entry (simple strategy, could use LRU)
            if let Some(entry) = self.l1_cache.iter().next() {
                let evicted_key = entry.key().clone();
                self.l1_cache.remove(&evicted_key);
                // Move to L2
                self.l2_cache.insert(evicted_key, entry.value().clone());
            }
        }
        self.l1_cache.insert(key.clone(), glyph.clone());

        // Also insert into L2
        if self.l2_cache.len() >= Self::L2_SIZE {
            // Evict oldest entry
            if let Some(entry) = self.l2_cache.iter().next() {
                self.l2_cache.remove(entry.key());
            }
        }
        self.l2_cache.insert(key, glyph);
    }

    fn promote_to_l1(&self, key: &GlyphCacheKey, glyph: Arc<CachedGlyph>) {
        if self.l1_cache.len() >= Self::L1_SIZE {
            // Evict from L1 to make room
            if let Some(entry) = self.l1_cache.iter().next() {
                self.l1_cache.remove(entry.key());
            }
        }
        self.l1_cache.insert(key.clone(), glyph);
    }

    pub fn clear(&self) {
        self.l1_cache.clear();
        self.l2_cache.clear();
        self.stats.reset();
    }

    pub fn stats(&self) -> CacheStats {
        self.stats.clone()
    }
}
```

## 3.5 Font Metrics and Outlines

### Extracting Metrics with skrifa

```rust
// typf-fontdb/src/metrics.rs

use skrifa::{Font, GlyphId, Metrics, OutlineGlyph};

pub struct FontMetricsProvider<'a> {
    font: &'a SkrifaFont<'a>,
    size: f32,
    variations: &'a VariationCoordinates,
}

impl<'a> FontMetricsProvider<'a> {
    pub fn new(
        font: &'a SkrifaFont<'a>,
        size: f32,
        variations: &'a VariationCoordinates
    ) -> Self {
        Self { font, size, variations }
    }

    /// Get glyph metrics
    pub fn glyph_metrics(&self, glyph_id: GlyphId) -> GlyphMetrics {
        let metrics = self.font
            .metrics()
            .with_variations(self.variations);

        let advance_width = metrics
            .advance_width(glyph_id)
            .unwrap_or(0.0);

        let bounds = metrics
            .bounds(glyph_id)
            .unwrap_or_default();

        let scale = self.size / self.font.upem() as f32;

        GlyphMetrics {
            advance_width: advance_width * scale,
            advance_height: 0.0, // Horizontal layout
            left_side_bearing: bounds.x_min * scale,
            top_side_bearing: bounds.y_max * scale,
            width: (bounds.x_max - bounds.x_min) * scale,
            height: (bounds.y_max - bounds.y_min) * scale,
        }
    }

    /// Get font-wide metrics
    pub fn font_metrics(&self) -> FontMetrics {
        let metrics = self.font
            .metrics()
            .with_variations(self.variations);

        let scale = self.size / self.font.upem() as f32;

        FontMetrics {
            ascent: metrics.ascent * scale,
            descent: metrics.descent * scale,
            line_gap: metrics.line_gap * scale,
            cap_height: metrics.cap_height.unwrap_or(metrics.ascent * 0.7) * scale,
            x_height: metrics.x_height.unwrap_or(metrics.ascent * 0.5) * scale,
            underline_position: metrics.underline_position * scale,
            underline_thickness: metrics.underline_thickness * scale,
        }
    }

    /// Get kerning value between two glyphs
    pub fn kern(&self, left: GlyphId, right: GlyphId) -> f32 {
        self.font
            .kerning()
            .and_then(|k| k.kern(left, right))
            .unwrap_or(0.0)
            * self.size / self.font.upem() as f32
    }
}
```

### Extracting Outlines with skrifa

```rust
// typf-fontdb/src/outline.rs

use skrifa::outline::{OutlinePen, DrawError};

/// Adapter to extract glyph outlines
pub struct OutlineExtractor {
    commands: Vec<PathCommand>,
    current_point: Option<(f32, f32)>,
}

impl OutlineExtractor {
    pub fn new() -> Self {
        Self {
            commands: Vec::new(),
            current_point: None,
        }
    }

    pub fn extract(
        font: &SkrifaFont,
        glyph_id: GlyphId,
        size: f32
    ) -> Result<Vec<PathCommand>, DrawError> {
        let mut extractor = Self::new();

        let outline_glyph = font
            .outline_glyphs()
            .get(glyph_id)
            .ok_or(DrawError::GlyphNotFound)?;

        let scale = size / font.upem() as f32;
        outline_glyph.draw_scaled(scale, &mut extractor)?;

        Ok(extractor.commands)
    }
}

impl OutlinePen for OutlineExtractor {
    type Error = std::convert::Infallible;

    fn move_to(&mut self, x: f32, y: f32) -> Result<(), Self::Error> {
        self.commands.push(PathCommand::MoveTo { x, y });
        self.current_point = Some((x, y));
        Ok(())
    }

    fn line_to(&mut self, x: f32, y: f32) -> Result<(), Self::Error> {
        self.commands.push(PathCommand::LineTo { x, y });
        self.current_point = Some((x, y));
        Ok(())
    }

    fn quad_to(
        &mut self,
        cx: f32, cy: f32,
        x: f32, y: f32
    ) -> Result<(), Self::Error> {
        self.commands.push(PathCommand::QuadTo { cx, cy, x, y });
        self.current_point = Some((x, y));
        Ok(())
    }

    fn curve_to(
        &mut self,
        c1x: f32, c1y: f32,
        c2x: f32, c2y: f32,
        x: f32, y: f32
    ) -> Result<(), Self::Error> {
        self.commands.push(PathCommand::CubicTo {
            c1x, c1y, c2x, c2y, x, y
        });
        self.current_point = Some((x, y));
        Ok(())
    }

    fn close(&mut self) -> Result<(), Self::Error> {
        self.commands.push(PathCommand::Close);
        Ok(())
    }
}

#[derive(Debug, Clone, Copy)]
pub enum PathCommand {
    MoveTo { x: f32, y: f32 },
    LineTo { x: f32, y: f32 },
    QuadTo { cx: f32, cy: f32, x: f32, y: f32 },
    CubicTo { c1x: f32, c1y: f32, c2x: f32, c2y: f32, x: f32, y: f32 },
    Close,
}
```

## 3.6 Variable Font Support

### Variation Axis Management

```rust
// typf-fontdb/src/variations.rs

use skrifa::variation::{Axis, AxisInfo};

pub struct VariationManager {
    axes: Vec<AxisInfo>,
    current_coords: VariationCoordinates,
    named_instances: Vec<NamedInstance>,
}

impl VariationManager {
    pub fn from_font(font: &SkrifaFont) -> Self {
        let axes: Vec<AxisInfo> = font
            .variation_axes()
            .map(|axis| AxisInfo {
                tag: axis.tag,
                name: axis.name.to_string(),
                min: axis.min,
                default: axis.default,
                max: axis.max,
                hidden: axis.hidden,
            })
            .collect();

        let named_instances = font
            .named_instances()
            .map(|instance| NamedInstance {
                name: instance.name.to_string(),
                coords: instance.coords.to_vec(),
            })
            .collect();

        Self {
            axes,
            current_coords: VariationCoordinates::default(),
            named_instances,
        }
    }

    pub fn set_axis(&mut self, tag: Tag, value: f32) -> Result<(), VariationError> {
        let axis = self.axes
            .iter()
            .find(|a| a.tag == tag)
            .ok_or(VariationError::AxisNotFound(tag))?;

        // Clamp to valid range
        let clamped = value.clamp(axis.min, axis.max);

        self.current_coords.set(tag, clamped);
        Ok(())
    }

    pub fn apply_named_instance(&mut self, name: &str) -> Result<(), VariationError> {
        let instance = self.named_instances
            .iter()
            .find(|i| i.name == name)
            .ok_or(VariationError::InstanceNotFound(name.to_string()))?;

        self.current_coords = VariationCoordinates::from_coords(&instance.coords);
        Ok(())
    }

    pub fn normalize_coordinates(&self, user_coords: &HashMap<Tag, f32>) -> VariationCoordinates {
        let mut normalized = VariationCoordinates::default();

        for axis in &self.axes {
            let value = user_coords
                .get(&axis.tag)
                .copied()
                .unwrap_or(axis.default);

            let clamped = value.clamp(axis.min, axis.max);
            normalized.set(axis.tag, clamped);
        }

        normalized
    }
}
```

## 3.7 Font Features

### OpenType Feature Management

```rust
// typf-fontdb/src/features.rs

use skrifa::raw::tables::gsub::Gsub;
use skrifa::raw::tables::gpos::Gpos;

pub struct FeatureManager {
    available_features: HashSet<Tag>,
    enabled_features: HashMap<Tag, u32>,
    script: Script,
    language: Language,
}

impl FeatureManager {
    pub fn from_font(font: &FontRef) -> Self {
        let mut available = HashSet::new();

        // Extract features from GSUB table
        if let Ok(gsub) = font.gsub() {
            for feature in gsub.features() {
                available.insert(feature.tag());
            }
        }

        // Extract features from GPOS table
        if let Ok(gpos) = font.gpos() {
            for feature in gpos.features() {
                available.insert(feature.tag());
            }
        }

        Self {
            available_features: available,
            enabled_features: HashMap::new(),
            script: Script::default(),
            language: Language::default(),
        }
    }

    pub fn enable_feature(&mut self, tag: Tag, value: u32) -> Result<(), FeatureError> {
        if !self.available_features.contains(&tag) {
            return Err(FeatureError::FeatureNotAvailable(tag));
        }

        self.enabled_features.insert(tag, value);
        Ok(())
    }

    pub fn disable_feature(&mut self, tag: Tag) {
        self.enabled_features.remove(&tag);
    }

    pub fn set_script_language(&mut self, script: Script, language: Language) {
        self.script = script;
        self.language = language;
    }

    pub fn get_enabled_features(&self) -> Vec<(Tag, u32)> {
        self.enabled_features
            .iter()
            .map(|(&tag, &value)| (tag, value))
            .collect()
    }

    pub fn is_feature_available(&self, tag: Tag) -> bool {
        self.available_features.contains(&tag)
    }
}
```

## 3.8 Migration from ttf-parser

### Compatibility Layer

For projects still using ttf-parser, provide a migration guide:

```rust
// typf-compat/src/ttf_parser_compat.rs

/// Compatibility wrapper for ttf-parser Face
pub struct TtfParserCompat {
    font: FontInstance,
}

impl TtfParserCompat {
    pub fn from_slice(data: &[u8], index: u32) -> Result<Self, CompatError> {
        let font_data = FontData::from_bytes(data.to_vec());
        let font = FontInstance::new(Arc::new(font_data), index)?;
        Ok(Self { font })
    }

    // Implement ttf-parser-like API using skrifa
    pub fn units_per_em(&self) -> u16 {
        self.font.metadata.upem
    }

    pub fn ascender(&self) -> i16 {
        self.font.metadata.ascent as i16
    }

    pub fn descender(&self) -> i16 {
        self.font.metadata.descent as i16
    }

    pub fn glyph_index(&self, c: char) -> Option<GlyphId> {
        self.font.skrifa_font.charmap().map(c)
    }

    pub fn glyph_hor_advance(&self, glyph_id: GlyphId) -> Option<u16> {
        self.font.skrifa_font
            .metrics()
            .advance_width(glyph_id)
            .map(|v| v as u16)
    }

    // ... more compatibility methods
}
```

### Migration Guide

```markdown
# Migrating from ttf-parser to read-fonts/skrifa

## Step 1: Update Dependencies

```toml
# Remove
# ttf-parser = "0.20"

# Add
read-fonts = "0.36"
skrifa = "0.39"
```

## Step 2: Replace Font Loading

```rust
// Old (ttf-parser)
let face = ttf_parser::Face::from_slice(data, 0)?;

// New (read-fonts/skrifa)
let font_ref = read_fonts::FontRef::new(data)?;
let skrifa_font = skrifa::Font::new(font_ref)?;
```

## Step 3: Update Metric Access

```rust
// Old
let upem = face.units_per_em();
let ascent = face.ascender();

// New
let upem = skrifa_font.upem();
let metrics = skrifa_font.metrics();
let ascent = metrics.ascent;
```

## Step 4: Update Glyph Access

```rust
// Old
let glyph_id = face.glyph_index('A')?;
let advance = face.glyph_hor_advance(glyph_id)?;

// New
let glyph_id = skrifa_font.charmap().map('A')?;
let advance = skrifa_font.metrics().advance_width(glyph_id)?;
```
```

## Next Steps

Part 04 will detail the API design and compatibility layers for integration with major Rust text layout libraries like cosmic-text, parley, and piet.
