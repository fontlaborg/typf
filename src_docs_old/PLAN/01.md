# Part 01: Core Architecture & Pipeline Design

## Executive Summary

This document outlines the foundational architecture for TYPF v2.0, establishing a strict six-stage processing pipeline that enables complete separation between text shaping and rasterization backends. The architecture prioritizes zero-copy operations, cache efficiency, and explicit failure modes over silent fallbacks.

## 1.1 Six-Stage Processing Pipeline

The core innovation of TYPF v2.0 is the strict separation of concerns into six sequential stages, each with well-defined inputs, outputs, and responsibilities:

```mermaid
graph LR
    A[1. Input Parsing] --> B[2. Unicode Processing]
    B --> C[3. Font Selection]
    C --> D[4. Shaping]
    D --> E[5. Rendering]
    E --> F[6. Export]
```

### Stage 1: Input Parsing & Validation

**Location:** `typf-input` crate (new; reference old-typf components)
**Responsibility:** Parse and validate all user parameters before processing begins

**Reference Implementation in old-typf:**
- `old-typf/crates/typf-api/src/session.rs`: SessionBuilder validation patterns
- `old-typf/crates/typf-api/src/backend.rs`: Backend option validation
- `old-typf/crates/typf-core/src/types.rs`: Type and option definitions
- `old-typf/backends/typf-core/src/lib.rs`: Backend capability checking

```rust
pub struct InputSpec {
    // Text content
    pub text: String,

    // Font specification
    pub font_spec: FontSpec,

    // Typography parameters
    pub font_size: f32,                          // pt
    pub letter_spacing: Option<f32>,             // em units
    pub word_spacing: Option<f32>,               // em units
    pub line_height: Option<f32>,                // multiplier

    // Language & features
    pub lang: Option<String>,                    // BCP 47 tag
    pub script: Option<Script>,                  // ISO 15924
    pub font_variation_settings: HashMap<Tag, f32>,
    pub font_feature_settings: HashMap<Tag, u32>,
    pub font_optical_sizing: bool,

    // Colors (with transparency)
    pub foreground: Color,                       // RGBA
    pub background: Option<Color>,               // RGBA or transparent

    // Backend selection
    pub backend_shaping: ShapingBackend,
    pub backend_render: RenderBackend,

    // Output format
    pub output_format: OutputFormat,
}

impl InputSpec {
    pub fn validate(&self) -> Result<(), InputError> {
        // Validate text not empty
        if self.text.is_empty() {
            return Err(InputError::InvalidText("empty text".into()));
        }

        // Validate font size
        if self.font_size <= 0.0 || !self.font_size.is_finite() {
            return Err(InputError::InvalidFontSize(self.font_size));
        }

        // Validate backend availability at compile time
        #[cfg(not(feature = "shaping-icu-hb"))]
        if matches!(self.backend_shaping, ShapingBackend::IcuHb) {
            return Err(InputError::FeatureNotEnabled("shaping-icu-hb".into()));
        }

        Ok(())
    }
}
```

### Stage 2: Unicode Processing

**Location:** `typf-unicode` crate (REUSE existing old-typf implementation)
**Responsibility:** Normalize text and segment into runs by script, direction, and language

**Existing Implementation in old-typf:**
- `old-typf/crates/typf-unicode/src/lib.rs`: Complete implementation with script detection, bidi analysis, normalization
- Uses `icu_segmenter`, `unicode_bidi`, and ICU properties for full Unicode support
- Already handles BCP 47 language tags and ISO 15924 script codes
- **OPPORTUNITY**: This module is production-ready; copy it directly to new v2.0 with minimal changes

```rust
pub struct UnicodeProcessor {
    normalizer: icu::normalizer::ComposingNormalizer,
    segmenter: icu::segmenter::LineSegmenter,
    bidi: unicode_bidi::BidiInfo,
}

pub struct TextRun {
    pub text: String,
    pub range: Range<usize>,      // Byte range in normalized text
    pub script: Script,            // ISO 15924
    pub direction: Direction,      // LTR/RTL/TTB/BTT
    pub language: Option<String>,  // BCP 47
}

impl UnicodeProcessor {
    pub fn process(&self, input: &InputSpec) -> Result<PreprocessedText> {
        // 1. Normalize (NFC by default)
        let normalized = self.normalize_unicode(&input.text)?;

        // 2. Script detection and itemization
        let script_runs = self.detect_script_runs(&normalized)?;

        // 3. Bidi analysis (UAX #9)
        let bidi_info = unicode_bidi::BidiInfo::new(&normalized, None);

        // 4. Combine into runs
        let runs = self.create_runs(
            &normalized,
            script_runs,
            bidi_info,
            input.lang.as_deref(),
        )?;

        Ok(PreprocessedText {
            original: input.text.clone(),
            normalized,
            runs,
        })
    }
}
```

### Stage 3: Font Selection & Loading

**Location:** `typf-fontdb` crate (ENHANCE existing old-typf implementation)
**Responsibility:** Load fonts and select appropriate faces for each text run

**Existing Implementation in old-typf:**
- `old-typf/crates/typf-fontdb/src/lib.rs`: FontDatabase with fontdb integration
- `old-typf/crates/typf-fontdb/src/font_cache.rs`: FontLoader and FontInstance caching
- Uses `memmap2` for zero-copy loading, `fontdb` for system font discovery
- Uses `lru` crate for LRU eviction and `dashmap` for concurrent access
- Already proven to handle face indices, feature availability checking
- **KEY REFERENCE**: `FontCache::resolve()` and `FontLoader::load()` methods show proven patterns

```rust
use read_fonts::{FontRef, ReadError};
use skrifa::{MetadataProvider, Font as SkrifaFont};

pub struct FontLoader {
    cache: Arc<RwLock<LruCache<FontKey, Arc<LoadedFont>>>>,
    font_data_store: Arc<RwLock<HashMap<FontKey, &'static [u8]>>>,
}

pub struct LoadedFont {
    pub font_ref: FontRef<'static>,  // read-fonts reference
    pub skrifa_font: SkrifaFont<'static>, // skrifa instance
    pub key: FontKey,
    pub face_index: u32,
    pub metadata: FontMetadata,
    pub variations: NormalizedVariations,
}

impl FontLoader {
    pub fn load(&self, spec: &FontSpec, input: &InputSpec)
        -> Result<Arc<LoadedFont>, FontLoadError>
    {
        // 1. Load raw font data (zero-copy via mmap)
        let font_data = self.load_font_data(&spec.source)?;

        // 2. Parse with read-fonts
        let font_ref = FontRef::new(font_data)
            .map_err(FontLoadError::ParseError)?;

        // 3. Create skrifa instance
        let skrifa_font = SkrifaFont::new(font_ref.clone())?;

        // 4. Extract metadata
        let metadata = self.extract_metadata(&skrifa_font)?;

        // 5. Normalize variations
        let variations = self.normalize_variations(
            &input.font_variation_settings,
            &metadata.variation_axes,
        )?;

        // 6. Validate capabilities (NO SILENT FALLBACKS)
        self.validate_capabilities(&metadata, input)?;

        Ok(Arc::new(LoadedFont {
            font_ref,
            skrifa_font,
            key: FontKey::from_spec(spec),
            face_index: spec.index,
            metadata,
            variations,
        }))
    }

    fn load_font_data(&self, source: &FontSource) -> Result<&'static [u8]> {
        match source {
            FontSource::Path(path) => {
                // Memory-map the font file for zero-copy access
                let file = std::fs::File::open(path)?;
                let mmap = unsafe { memmap2::Mmap::map(&file)? };

                // Leak to get 'static lifetime (cached)
                let leaked: &'static [u8] = Box::leak(
                    mmap.to_vec().into_boxed_slice()
                );
                Ok(leaked)
            }
            FontSource::Memory(arc) => {
                // Already in memory
                let leaked: &'static [u8] = Box::leak(
                    arc.to_vec().into_boxed_slice()
                );
                Ok(leaked)
            }
            FontSource::SystemFamily(family) => {
                // Use fontdb to resolve system font (see old-typf/crates/typf-fontdb/src/lib.rs:resolve_system_font)
                let resolved = self.resolve_system_font(family)?;
                self.load_font_data(&FontSource::Path(resolved))
            }
        }
    }
}
```

### Stage 4: Shaping

**Location:** Backend-specific crates
**Responsibility:** Convert text runs to positioned glyphs

```rust
pub trait Shaper: Send + Sync {
    fn name(&self) -> &'static str;

    fn shape(
        &self,
        run: &TextRun,
        font: &LoadedFont,
        options: &ShapingOptions
    ) -> Result<ShapingResult, ShapingError>;

    fn supports_script(&self, script: Script) -> bool;

    fn clear_cache(&self);
}

pub struct ShapingResult {
    pub run: TextRun,
    pub glyphs: Vec<ShapedGlyph>,
    pub advance_width: f32,
    pub advance_height: f32,
    pub bounding_box: BoundingBox,
}

pub struct ShapedGlyph {
    pub glyph_id: u32,
    pub cluster: u32,     // Byte offset in original text
    pub x_offset: f32,    // In design units
    pub y_offset: f32,
    pub x_advance: f32,
    pub y_advance: f32,
}
```

### Stage 5: Rendering

**Location:** Backend-specific crates
**Responsibility:** Rasterize or vectorize shaped glyphs

```rust
pub trait Renderer: Send + Sync {
    fn name(&self) -> &'static str;

    fn render(
        &self,
        shaped: &[ShapingResult],
        font: &LoadedFont,
        options: &RenderOptions
    ) -> Result<RenderOutput, RenderError>;

    fn supports_format(&self, format: OutputFormat) -> bool;

    /// Optimization hook for combined shaping and rendering
    fn optimized_shape_and_render(
        &self,
        run: &TextRun,
        font: &LoadedFont,
        shaping_options: &ShapingOptions,
        render_options: &RenderOptions,
        shaper_name: &str
    ) -> Result<Option<RenderOutput>, RenderError> {
        Ok(None) // Default: Not optimized
    }
}

pub enum RenderOutput {
    Bitmap(BitmapData),
    Vector(VectorData),
    Json(JsonData),
}

pub struct BitmapData {
    pub width: u32,
    pub height: u32,
    pub data: Vec<u8>,     // RGBA8
    pub format: PixelFormat,
}
```

### Stage 6: Export

**Location:** `typf-export` crate
**Responsibility:** Convert render output to final format

```rust
pub trait Exporter {
    fn export(
        &self,
        result: RenderOutput,
        output: &mut dyn Write
    ) -> Result<(), ExportError>;
}

pub struct PngExporter;

impl Exporter for PngExporter {
    fn export(&self, result: RenderOutput, output: &mut dyn Write)
        -> Result<(), ExportError>
    {
        let bitmap = match result {
            RenderOutput::Bitmap(b) => b,
            _ => return Err(ExportError::IncompatibleFormat),
        };

        let mut encoder = png::Encoder::new(
            output,
            bitmap.width,
            bitmap.height
        );
        encoder.set_color(png::ColorType::Rgba);
        encoder.set_depth(png::BitDepth::Eight);

        let mut writer = encoder.write_header()?;
        writer.write_image_data(&bitmap.data)?;

        Ok(())
    }
}
```

## 1.2 Core Trait Hierarchy

The architecture is built on a hierarchy of traits that allow backend implementations to be swapped at compile-time or runtime:

```rust
// In typf-core/src/traits.rs

/// Core trait for all TYPF components
pub trait Component: Send + Sync {
    fn name(&self) -> &'static str;
    fn version(&self) -> Version;
}

/// Trait for components that can be cached
pub trait Cacheable: Component {
    type Key: Hash + Eq;
    type Value: Clone;

    fn cache_key(&self) -> Self::Key;
    fn cache_value(&self) -> Self::Value;
}

/// Trait for components that support benchmarking
pub trait Benchmarkable: Component {
    fn benchmark_name(&self) -> String;
    fn benchmark_iterations(&self) -> u32 { 1000 }
}
```

## 1.3 Error Handling Philosophy

TYPF v2.0 adopts a **fail-fast** approach with explicit error types:

```rust
#[derive(Debug, Error)]
pub enum TypfError {
    #[error("Input error: {0}")]
    Input(#[from] InputError),

    #[error("Font loading error: {0}")]
    FontLoad(#[from] FontLoadError),

    #[error("Shaping error: {0}")]
    Shaping(#[from] ShapingError),

    #[error("Rendering error: {0}")]
    Rendering(#[from] RenderError),

    #[error("Feature not implemented: {0}")]
    NotImplemented(String),

    #[error("Feature not compiled: {0}")]
    FeatureNotCompiled(String),

    #[error("Backend combination not supported: shaping={0}, render={1}")]
    UnsupportedBackendCombination(String, String),
}
```

**Key Principles:**

1. **No Silent Fallbacks:** If a requested feature isn't available, fail immediately
2. **Explicit Feature Gates:** Compile-time checks for backend availability
3. **Rich Error Context:** Include enough information for debugging
4. **Recovery Strategies:** Document how users can recover from each error type

## 1.4 Memory Management Strategy

### Zero-Copy Font Loading

All font data is memory-mapped and shared via `Arc`:

```rust
pub struct FontDataCache {
    /// Memory-mapped font files
    mmap_cache: DashMap<PathBuf, Arc<memmap2::Mmap>>,

    /// Parsed font references (never copied)
    font_cache: DashMap<FontKey, Arc<FontRef<'static>>>,

    /// LRU eviction for memory management
    lru: Mutex<LruCache<FontKey, ()>>,
}
```

### Cache-Aware Data Layout

Critical data structures are aligned to cache lines:

```rust
#[repr(C, align(64))]  // 64-byte cache line
pub struct CachedGlyph {
    pub id: u32,           // 4 bytes
    pub width: u16,        // 2 bytes
    pub height: u16,       // 2 bytes
    pub left: i16,         // 2 bytes
    pub top: i16,          // 2 bytes
    pub advance_x: f32,    // 4 bytes
    pub advance_y: f32,    // 4 bytes
    _padding: [u8; 44],    // Pad to 64 bytes
}
```

## 1.5 Pipeline Orchestration

The `Pipeline` struct coordinates all six stages:

```rust
pub struct Pipeline {
    input_parser: Arc<InputParser>,
    unicode_processor: Arc<UnicodeProcessor>,
    font_loader: Arc<FontLoader>,
    shaper: Arc<dyn Shaper>,
    renderer: Arc<dyn Renderer>,
    exporter: Arc<dyn Exporter>,

    /// Optional fused backend for optimized paths
    fused: Option<Arc<dyn FusedEngine>>,
}

impl Pipeline {
    pub fn execute(&self, request: InputSpec) -> Result<Vec<u8>, TypfError> {
        // Check for optimized fused path
        if let Some(fused) = &self.fused {
            if fused.can_handle(&request) {
                return fused.execute(request);
            }
        }

        // Standard pipeline execution
        let validated = self.input_parser.parse(request)?;
        let preprocessed = self.unicode_processor.process(&validated)?;
        let font_runs = self.font_loader.resolve_runs(&preprocessed)?;

        let mut shaped_runs = Vec::new();
        for run in font_runs {
            let shaped = self.shaper.shape(&run.text, &run.font, &validated)?;
            shaped_runs.push(shaped);
        }

        let rendered = self.renderer.render(&shaped_runs, &validated)?;
        let exported = self.exporter.export(rendered, validated.output_format)?;

        Ok(exported)
    }
}
```

## 1.6 Configuration and Builder Pattern

All components use the builder pattern for configuration:

```rust
let pipeline = Pipeline::builder()
    .shaping_backend(ShapingBackend::HarfBuzz)
    .render_backend(RenderBackend::Orge)
    .output_format(OutputFormat::Png)
    .cache_size(1024)
    .worker_threads(4)
    .build()?;

let result = pipeline.execute(
    InputSpec::builder()
        .text("Hello, TYPF v2!")
        .font_family("Inter")
        .size(48.0)
        .foreground(Color::BLACK)
        .build()?
)?;
```

## 1.7 Thread Safety and Parallelism

All pipeline components are thread-safe and support parallel execution:

```rust
use rayon::prelude::*;

pub fn batch_render(requests: Vec<InputSpec>) -> Vec<Result<Vec<u8>, TypfError>> {
    let pipeline = Arc::new(Pipeline::default());

    requests
        .par_iter()
        .map(|req| pipeline.execute(req.clone()))
        .collect()
}
```

## Next Steps

With the core architecture defined, Part 02 will detail the implementation of specific shaping and rendering backends, including the optimization paths for native platforms.