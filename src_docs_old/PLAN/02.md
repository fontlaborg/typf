# Part 02: Backend Architecture Implementation

## Overview

This document details the implementation of shaping and rendering backends, their optimization paths, and the composable backend matrix that enables any valid combination of shaping and rendering engines.

## 2.1 Backend Selection Model

### Shaping Backends

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ShapingBackend {
    /// Automatic selection based on platform
    Auto,
    /// CoreText on macOS
    Mac,
    /// DirectWrite on Windows
    Win,
    /// ICU + HarfBuzz (full complex text support)
    IcuHb,
    /// HarfBuzz only (no ICU preprocessing)
    Hb,
    /// Simple LTR advancement (no shaping)
    None,
}

impl ShapingBackend {
    pub fn resolve_auto() -> Self {
        #[cfg(target_os = "macos")]
        return Self::Mac;

        #[cfg(target_os = "windows")]
        return Self::Win;

        #[cfg(not(any(target_os = "macos", target_os = "windows")))]
        return Self::IcuHb;
    }

    pub fn is_available(&self) -> bool {
        match self {
            Self::Auto => true,
            Self::Mac => cfg!(all(target_os = "macos", feature = "shaping-mac")),
            Self::Win => cfg!(all(target_os = "windows", feature = "shaping-win")),
            Self::IcuHb => cfg!(feature = "shaping-icu-hb"),
            Self::Hb => cfg!(feature = "shaping-hb"),
            Self::None => true, // Always available (pure Rust)
        }
    }
}
```

### Rendering Backends

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RenderBackend {
    /// JSON output (shaping results only)
    Json,
    /// CoreGraphics on macOS
    Mac,
    /// Direct2D/DirectWrite on Windows
    Win,
    /// Custom F26.6 rasterizer
    Orge,
    /// tiny-skia bitmap output
    Skia,
    /// tiny-skia SVG output
    SkiaSvg,
    /// Zeno bitmap output
    Zeno,
    /// Zeno SVG output
    ZenoSvg,
}

impl RenderBackend {
    pub fn is_available(&self) -> bool {
        match self {
            Self::Json => true, // Always available
            Self::Mac => cfg!(all(target_os = "macos", feature = "render-mac")),
            Self::Win => cfg!(all(target_os = "windows", feature = "render-win")),
            Self::Orge => cfg!(feature = "render-orge"),
            Self::Skia => cfg!(feature = "render-skia"),
            Self::SkiaSvg => cfg!(feature = "render-skia-svg"),
            Self::Zeno => cfg!(feature = "render-zeno"),
            Self::ZenoSvg => cfg!(feature = "render-zeno-svg"),
        }
    }
}
```

## 2.2 Backend Combination Matrix

### Valid Combinations and Optimization Paths

| Shaping \ Rendering | Json | Mac | Win | Orge | Skia | SkiaSvg | Zeno | ZenoSvg |
|-------------------|------|-----|-----|------|------|---------|------|---------|
| **Mac**           | ✓    | ✓*  | ✗   | ✓    | ✓    | ✓       | ✓    | ✓       |
| **Win**           | ✓    | ✗   | ✓*  | ✓    | ✓    | ✓       | ✓    | ✓       |
| **IcuHb**         | ✓    | ✓   | ✓   | ✓    | ✓    | ✓       | ✓    | ✓       |
| **Hb**            | ✓    | ✓   | ✓   | ✓    | ✓    | ✓       | ✓    | ✓       |
| **None**          | ✓    | ✗   | ✗   | ✓    | ✓    | ✓       | ✓    | ✓       |

\* = Optimized fused path available

### Fused Engine Interface

```rust
/// Trait for backends that can perform shaping and rendering in a single pass
pub trait FusedEngine: Send + Sync {
    fn can_handle(&self, shaping: ShapingBackend, render: RenderBackend) -> bool;

    fn execute_fused(
        &self,
        text: &str,
        font: &LoadedFont,
        options: &RenderOptions
    ) -> Result<RenderOutput, TypfError>;
}
```

## 2.3 Shaping Backend Implementations

### 2.3.1 None Backend (Minimal Shaping)

```rust
// backends/typf-shape-none/src/lib.rs

pub struct NoneShaper;

impl Shaper for NoneShaper {
    fn name(&self) -> &'static str { "none" }

    fn shape(
        &self,
        run: &TextRun,
        font: &LoadedFont,
        options: &ShapingOptions
    ) -> Result<ShapingResult, ShapingError> {
        let mut glyphs = Vec::new();
        let mut x_advance = 0.0;
        let scale = options.size / font.metadata.upem as f32;

        // Simple left-to-right, one glyph per character
        for (cluster, ch) in run.text.char_indices() {
            // Use skrifa for glyph mapping
            let glyph_id = font.skrifa_font
                .charmap()
                .map(ch)
                .unwrap_or(0); // .notdef

            // Get horizontal advance from skrifa
            let advance_width = font.skrifa_font
                .metrics()
                .advance_width(glyph_id)
                .unwrap_or(0.0) * scale;

            glyphs.push(ShapedGlyph {
                glyph_id: glyph_id as u32,
                cluster: cluster as u32,
                x_offset: 0.0,
                y_offset: 0.0,
                x_advance: advance_width,
                y_advance: 0.0,
            });

            x_advance += advance_width;

            // Apply letter spacing if specified
            if let Some(spacing) = options.letter_spacing {
                x_advance += spacing * options.size;
            }
        }

        Ok(ShapingResult {
            run: run.clone(),
            glyphs,
            advance_width: x_advance,
            advance_height: 0.0,
            bounding_box: self.calculate_bbox(&glyphs, font, scale),
        })
    }

    fn supports_script(&self, script: Script) -> bool {
        // Only supports Latin and simple scripts
        matches!(script, Script::Latin | Script::Common)
    }
}
```

### 2.3.2 HarfBuzz Backend

**Reference Implementation in old-typf:**
- Shaping layer patterns exist in old-typf backends; composition model proven
- `old-typf/backends/typf-icu-hb/src/lib.rs`: Shows ICU+HarfBuzz composition pattern
- Buffer pool, caching, and feature handling already demonstrated

```rust
// backends/typf-shape-hb/src/lib.rs
// NOTE: Adapt patterns from old-typf/backends/typf-icu-hb/

use harfbuzz_rs as hb;

pub struct HarfBuzzShaper {
    buffer_pool: ObjectPool<hb::Buffer>,
    cache: Arc<DashMap<ShapingKey, Arc<ShapingResult>>>,
}

impl Shaper for HarfBuzzShaper {
    fn name(&self) -> &'static str { "harfbuzz" }

    fn shape(
        &self,
        run: &TextRun,
        font: &LoadedFont,
        options: &ShapingOptions
    ) -> Result<ShapingResult, ShapingError> {
        // Check cache
        let cache_key = ShapingKey::new(run, font, options);
        if let Some(cached) = self.cache.get(&cache_key) {
            return Ok((**cached).clone());
        }

        // Create HarfBuzz font from skrifa data
        let hb_face = hb::Face::from_bytes(
            font.font_ref.data(),
            font.face_index
        );
        let mut hb_font = hb::Font::new(hb_face);

        // Set font size and variations
        hb_font.set_scale(
            (options.size * 64.0) as i32,  // 26.6 fixed point
            (options.size * 64.0) as i32,
        );

        // Apply font variations
        for (tag, value) in &font.variations.coords {
            hb_font.set_variation(*tag, *value);
        }

        // Get buffer from pool
        let mut buffer = self.buffer_pool.get();
        buffer.clear();

        // Add text and set properties
        buffer.add_str(&run.text);
        buffer.set_direction(self.convert_direction(run.direction));
        buffer.set_script(self.convert_script(run.script));
        if let Some(ref lang) = run.language {
            buffer.set_language(hb::Language::from_str(lang)?);
        }

        // Apply OpenType features
        let features: Vec<hb::Feature> = options.features
            .iter()
            .map(|(tag, value)| hb::Feature::new(*tag, *value, 0, std::u32::MAX))
            .collect();

        // Shape!
        hb::shape(&hb_font, &mut buffer, &features);

        // Extract results
        let result = self.extract_shaping_result(&buffer, run, font, options)?;

        // Cache the result
        self.cache.insert(cache_key, Arc::new(result.clone()));

        Ok(result)
    }

    fn supports_script(&self, _script: Script) -> bool {
        true // HarfBuzz supports all scripts
    }
}
```

### 2.3.3 ICU + HarfBuzz Backend

```rust
// backends/typf-shape-icu-hb/src/lib.rs

pub struct IcuHarfBuzzShaper {
    harfbuzz: HarfBuzzShaper,
    icu_segmenter: icu::segmenter::LineSegmenter,
    normalizer: icu::normalizer::ComposingNormalizer,
}

impl Shaper for IcuHarfBuzzShaper {
    fn name(&self) -> &'static str { "icu-harfbuzz" }

    fn shape(
        &self,
        run: &TextRun,
        font: &LoadedFont,
        options: &ShapingOptions
    ) -> Result<ShapingResult, ShapingError> {
        // ICU preprocessing
        let normalized = self.normalizer.normalize(&run.text)?;

        // ICU line breaking and segmentation
        let segments = self.icu_segmenter.segment_str(&normalized)?;

        let mut all_glyphs = Vec::new();
        let mut total_advance = 0.0;

        // Shape each segment with HarfBuzz
        for segment in segments {
            let segment_run = TextRun {
                text: segment.to_string(),
                range: run.range.clone(),
                script: run.script,
                direction: run.direction,
                language: run.language.clone(),
            };

            let shaped = self.harfbuzz.shape(&segment_run, font, options)?;

            // Offset glyphs by current advance
            for mut glyph in shaped.glyphs {
                glyph.x_offset += total_advance;
                all_glyphs.push(glyph);
            }

            total_advance += shaped.advance_width;
        }

        Ok(ShapingResult {
            run: run.clone(),
            glyphs: all_glyphs,
            advance_width: total_advance,
            advance_height: 0.0,
            bounding_box: self.calculate_bbox(&all_glyphs, font, options.size),
        })
    }
}
```

### 2.3.4 CoreText Backend (macOS)

```rust
// backends/typf-shape-mac/src/lib.rs

#[cfg(target_os = "macos")]
use core_text::{font::CTFont, string_attributes::*};
use core_foundation::string::CFString;

#[cfg(target_os = "macos")]
pub struct CoreTextShaper {
    cache: Arc<DashMap<ShapingKey, Arc<ShapingResult>>>,
}

#[cfg(target_os = "macos")]
impl Shaper for CoreTextShaper {
    fn name(&self) -> &'static str { "coretext" }

    fn shape(
        &self,
        run: &TextRun,
        font: &LoadedFont,
        options: &ShapingOptions
    ) -> Result<ShapingResult, ShapingError> {
        // Create CTFont from loaded font data
        let ct_font = self.create_ct_font(font, options.size)?;

        // Create attributed string
        let cf_string = CFString::new(&run.text);
        let mut attrs = CFMutableDictionary::new();
        attrs.set(kCTFontAttributeName, ct_font);

        // Apply features and variations
        self.apply_features(&mut attrs, &options.features)?;
        self.apply_variations(&mut attrs, &font.variations)?;

        let attr_string = CFAttributedString::create(cf_string, attrs);

        // Create CTLine for shaping
        let line = CTLine::create_with_attributed_string(attr_string);

        // Extract glyph runs
        let ct_runs = line.glyph_runs();
        let mut glyphs = Vec::new();

        for ct_run in ct_runs {
            let glyph_count = ct_run.glyph_count();
            let ct_glyphs = ct_run.glyphs();
            let positions = ct_run.positions();
            let indices = ct_run.string_indices();

            for i in 0..glyph_count {
                glyphs.push(ShapedGlyph {
                    glyph_id: ct_glyphs[i] as u32,
                    cluster: indices[i] as u32,
                    x_offset: positions[i].x as f32,
                    y_offset: positions[i].y as f32,
                    x_advance: if i + 1 < glyph_count {
                        (positions[i + 1].x - positions[i].x) as f32
                    } else {
                        ct_run.typographic_bounds().width as f32
                    },
                    y_advance: 0.0,
                });
            }
        }

        Ok(ShapingResult {
            run: run.clone(),
            glyphs,
            advance_width: line.typographic_bounds().width as f32,
            advance_height: 0.0,
            bounding_box: self.calculate_bbox_from_line(&line),
        })
    }
}
```

### 2.3.5 DirectWrite Backend (Windows)

```rust
// backends/typf-shape-win/src/lib.rs

#[cfg(target_os = "windows")]
use windows::Win32::Graphics::DirectWrite::*;

#[cfg(target_os = "windows")]
pub struct DirectWriteShaper {
    factory: IDWriteFactory7,
    cache: Arc<DashMap<ShapingKey, Arc<ShapingResult>>>,
}

#[cfg(target_os = "windows")]
impl Shaper for DirectWriteShaper {
    fn name(&self) -> &'static str { "directwrite" }

    fn shape(
        &self,
        run: &TextRun,
        font: &LoadedFont,
        options: &ShapingOptions
    ) -> Result<ShapingResult, ShapingError> {
        // Create DirectWrite font from loaded font data
        let dw_font = self.create_dw_font(font)?;

        // Create text format
        let text_format = self.factory.CreateTextFormat(
            &HSTRING::from(&font.metadata.family_name),
            None,
            dw_font.GetWeight(),
            dw_font.GetStyle(),
            dw_font.GetStretch(),
            options.size,
            &HSTRING::from("en-US"),
        )?;

        // Create text layout
        let text_layout = self.factory.CreateTextLayout(
            &run.text,
            &text_format,
            f32::MAX, // Max width
            f32::MAX, // Max height
        )?;

        // Apply features
        self.apply_features(&text_layout, &options.features)?;

        // Get glyph runs
        let analyzer = self.factory.CreateTextAnalyzer()?;
        let mut glyphs = Vec::new();

        // Extract shaped glyphs
        // (DirectWrite specific implementation)

        Ok(ShapingResult {
            run: run.clone(),
            glyphs,
            advance_width: text_layout.GetMetrics()?.width,
            advance_height: 0.0,
            bounding_box: self.calculate_bbox_from_layout(&text_layout),
        })
    }
}
```

## 2.4 Rendering Backend Implementations

### 2.4.1 JSON Renderer

```rust
// backends/typf-render-json/src/lib.rs

use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct JsonOutput {
    pub text: String,
    pub font: FontInfo,
    pub glyphs: Vec<JsonGlyph>,
    pub metrics: JsonMetrics,
}

#[derive(Serialize, Deserialize)]
pub struct JsonGlyph {
    pub g: u32,        // glyph ID
    pub cl: u32,       // cluster
    pub dx: i32,       // x offset (26.6 fixed)
    pub dy: i32,       // y offset (26.6 fixed)
    pub ax: i32,       // x advance (26.6 fixed)
    pub ay: i32,       // y advance (26.6 fixed)
}

pub struct JsonRenderer;

impl Renderer for JsonRenderer {
    fn name(&self) -> &'static str { "json" }

    fn render(
        &self,
        shaped: &[ShapingResult],
        _font: &LoadedFont,
        options: &RenderOptions
    ) -> Result<RenderOutput, RenderError> {
        let json_output = JsonOutput {
            text: shaped.iter()
                .map(|s| &s.run.text)
                .collect::<String>(),
            font: FontInfo {
                family: options.font_family.clone(),
                size: options.size,
            },
            glyphs: shaped.iter()
                .flat_map(|s| &s.glyphs)
                .map(|g| JsonGlyph {
                    g: g.glyph_id,
                    cl: g.cluster,
                    dx: (g.x_offset * 64.0) as i32,
                    dy: (g.y_offset * 64.0) as i32,
                    ax: (g.x_advance * 64.0) as i32,
                    ay: (g.y_advance * 64.0) as i32,
                })
                .collect(),
            metrics: JsonMetrics {
                advance: shaped.iter().map(|s| s.advance_width).sum(),
                height: options.size * 1.2, // Line height
            },
        };

        let json_string = serde_json::to_string_pretty(&json_output)?;
        Ok(RenderOutput::Json(JsonData(json_string)))
    }

    fn supports_format(&self, format: OutputFormat) -> bool {
        matches!(format, OutputFormat::Json)
    }
}
```

### 2.4.2 Orge Renderer (Custom Rasterizer)

**Reference Implementation in old-typf:**
- `old-typf/backends/typf-orge/src/lib.rs`: Complete Orge rasterizer implementation
- Proven glyph caching with DashMap and pool management
- Canvas compositing and blending operations already implemented
- Custom F26.6 scan converter (made by FontLab)
- **KEY REFERENCE**: Study `old-typf/backends/typf-orge/src/renderer.rs` for rasterization patterns

```rust
// backends/typf-render-orge/src/lib.rs
// NOTE: Adapt from old-typf/backends/typf-orge/src/

pub struct OrgeRenderer {
    rasterizer_pool: ObjectPool<OrgeRasterizer>,
    glyph_cache: Arc<DashMap<GlyphCacheKey, Arc<RasterizedGlyph>>>,
}

impl Renderer for OrgeRenderer {
    fn name(&self) -> &'static str { "orge" }

    fn render(
        &self,
        shaped: &[ShapingResult],
        font: &LoadedFont,
        options: &RenderOptions
    ) -> Result<RenderOutput, RenderError> {
        // Calculate canvas dimensions
        let bbox = self.calculate_combined_bbox(shaped);
        let width = bbox.width.ceil() as u32;
        let height = bbox.height.ceil() as u32;

        // Create canvas
        let mut canvas = OrgeCanvas::new(width, height);

        // Fill background if specified
        if let Some(bg) = options.background {
            canvas.fill(bg);
        }

        // Rasterize each glyph
        let mut rasterizer = self.rasterizer_pool.get();

        for result in shaped {
            for glyph in &result.glyphs {
                let cache_key = GlyphCacheKey {
                    glyph_id: glyph.glyph_id,
                    font_key: font.key.clone(),
                    size: options.size,
                };

                // Check cache or rasterize
                let rasterized = if let Some(cached) = self.glyph_cache.get(&cache_key) {
                    cached.clone()
                } else {
                    let rasterized = self.rasterize_glyph(
                        &mut rasterizer,
                        glyph.glyph_id,
                        font,
                        options.size
                    )?;
                    let arc = Arc::new(rasterized);
                    self.glyph_cache.insert(cache_key, arc.clone());
                    arc
                };

                // Composite onto canvas
                canvas.composite_glyph(
                    &rasterized,
                    glyph.x_offset as i32,
                    glyph.y_offset as i32,
                    options.foreground,
                );
            }
        }

        Ok(RenderOutput::Bitmap(BitmapData {
            width,
            height,
            data: canvas.into_rgba8(),
            format: PixelFormat::Rgba8,
        }))
    }

    fn rasterize_glyph(
        &self,
        rasterizer: &mut OrgeRasterizer,
        glyph_id: u32,
        font: &LoadedFont,
        size: f32
    ) -> Result<RasterizedGlyph, RenderError> {
        // Get glyph outline from skrifa
        let glyph = font.skrifa_font
            .outline_glyphs()
            .get(GlyphId::new(glyph_id as u16))
            .ok_or(RenderError::GlyphNotFound(glyph_id))?;

        // Clear rasterizer
        rasterizer.reset();

        // Scale factor
        let scale = size / font.metadata.upem as f32;

        // Draw outline to rasterizer
        glyph.draw(OrgeOutlineSink {
            rasterizer,
            scale,
        })?;

        // Rasterize to grayscale bitmap
        let coverage = rasterizer.render_grayscale(16); // 16x supersampling

        Ok(RasterizedGlyph {
            width: coverage.width,
            height: coverage.height,
            left: coverage.left,
            top: coverage.top,
            data: coverage.data,
        })
    }
}
```

### 2.4.3 Skia Renderer

```rust
// backends/typf-render-skia/src/lib.rs

use tiny_skia::*;

pub struct SkiaRenderer {
    output_svg: bool,
}

impl Renderer for SkiaRenderer {
    fn name(&self) -> &'static str {
        if self.output_svg { "skia-svg" } else { "skia" }
    }

    fn render(
        &self,
        shaped: &[ShapingResult],
        font: &LoadedFont,
        options: &RenderOptions
    ) -> Result<RenderOutput, RenderError> {
        if self.output_svg {
            self.render_svg(shaped, font, options)
        } else {
            self.render_bitmap(shaped, font, options)
        }
    }

    fn render_bitmap(
        &self,
        shaped: &[ShapingResult],
        font: &LoadedFont,
        options: &RenderOptions
    ) -> Result<RenderOutput, RenderError> {
        // Calculate dimensions
        let bbox = self.calculate_combined_bbox(shaped);
        let width = bbox.width.ceil() as u32;
        let height = bbox.height.ceil() as u32;

        // Create pixmap
        let mut pixmap = Pixmap::new(width, height)
            .ok_or(RenderError::AllocationFailed)?;

        // Fill background
        if let Some(bg) = options.background {
            pixmap.fill(self.color_to_skia(bg));
        }

        // Setup paint
        let mut paint = Paint::default();
        paint.set_color(self.color_to_skia(options.foreground));
        paint.anti_alias = true;

        // Render each glyph
        for result in shaped {
            for glyph in &result.glyphs {
                let path = self.glyph_to_path(glyph.glyph_id, font)?;

                let transform = Transform::from_translate(
                    glyph.x_offset,
                    glyph.y_offset
                );

                pixmap.fill_path(
                    &path,
                    &paint,
                    FillRule::Winding,
                    transform,
                    None
                );
            }
        }

        Ok(RenderOutput::Bitmap(BitmapData {
            width,
            height,
            data: pixmap.data().to_vec(),
            format: PixelFormat::Rgba8,
        }))
    }

    fn render_svg(
        &self,
        shaped: &[ShapingResult],
        font: &LoadedFont,
        options: &RenderOptions
    ) -> Result<RenderOutput, RenderError> {
        let mut svg = String::new();

        // SVG header
        let bbox = self.calculate_combined_bbox(shaped);
        svg.push_str(&format!(
            r#"<svg viewBox="0 0 {} {}" xmlns="http://www.w3.org/2000/svg">"#,
            bbox.width, bbox.height
        ));

        // Background rect if specified
        if let Some(bg) = options.background {
            svg.push_str(&format!(
                r#"<rect width="{}" height="{}" fill="{}"/>"#,
                bbox.width, bbox.height,
                self.color_to_css(bg)
            ));
        }

        // Render glyphs as paths
        svg.push_str(&format!(
            r#"<g fill="{}">"#,
            self.color_to_css(options.foreground)
        ));

        for result in shaped {
            for glyph in &result.glyphs {
                let path_data = self.glyph_to_svg_path(glyph.glyph_id, font)?;
                svg.push_str(&format!(
                    r#"<path d="{}" transform="translate({}, {})"/>"#,
                    path_data, glyph.x_offset, glyph.y_offset
                ));
            }
        }

        svg.push_str("</g></svg>");

        Ok(RenderOutput::Vector(VectorData::Svg(svg)))
    }
}
```

## 2.5 Optimized Fused Paths

### CoreText Fused Engine (macOS)

```rust
// backends/typf-fused-mac/src/lib.rs

#[cfg(target_os = "macos")]
pub struct CoreTextFusedEngine;

#[cfg(target_os = "macos")]
impl FusedEngine for CoreTextFusedEngine {
    fn can_handle(&self, shaping: ShapingBackend, render: RenderBackend) -> bool {
        matches!((shaping, render), (ShapingBackend::Mac, RenderBackend::Mac))
    }

    fn execute_fused(
        &self,
        text: &str,
        font: &LoadedFont,
        options: &RenderOptions
    ) -> Result<RenderOutput, TypfError> {
        // Create CTFont and attributed string
        let ct_font = self.create_ct_font(font, options.size)?;
        let cf_string = CFString::new(text);

        let mut attrs = CFMutableDictionary::new();
        attrs.set(kCTFontAttributeName, ct_font);
        attrs.set(kCTForegroundColorAttributeName,
                 self.color_to_cgcolor(options.foreground));

        let attr_string = CFAttributedString::create(cf_string, attrs);

        // Create framesetter and frame
        let framesetter = CTFramesetter::create_with_attributed_string(attr_string);
        let path = CGPath::from_rect(CGRect {
            origin: CGPoint::zero(),
            size: CGSize { width: f32::MAX, height: f32::MAX },
        });
        let frame = framesetter.create_frame(CFRange::init(0, 0), &path, None);

        // Render to bitmap context
        let suggested_size = framesetter.suggest_frame_size(
            CFRange::init(0, text.len() as isize),
            None,
            CGSize { width: f32::MAX, height: f32::MAX }
        );

        let width = suggested_size.width.ceil() as u32;
        let height = suggested_size.height.ceil() as u32;

        let context = CGContext::create_bitmap_context(
            None,
            width as usize,
            height as usize,
            8,
            0,
            &CGColorSpace::create_device_rgb(),
            kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big
        );

        // Fill background if specified
        if let Some(bg) = options.background {
            context.set_fill_color(&self.color_to_cgcolor(bg));
            context.fill_rect(CGRect {
                origin: CGPoint::zero(),
                size: CGSize { width: width as f32, height: height as f32 },
            });
        }

        // Draw the frame
        CTFrameDraw(frame, context);

        // Extract bitmap data
        let data = context.data().to_vec();

        Ok(RenderOutput::Bitmap(BitmapData {
            width,
            height,
            data,
            format: PixelFormat::Rgba8,
        }))
    }
}
```

### DirectWrite Fused Engine (Windows)

```rust
// backends/typf-fused-win/src/lib.rs

#[cfg(target_os = "windows")]
pub struct DirectWriteFusedEngine {
    factory: IDWriteFactory7,
    d2d_factory: ID2D1Factory7,
}

#[cfg(target_os = "windows")]
impl FusedEngine for DirectWriteFusedEngine {
    fn can_handle(&self, shaping: ShapingBackend, render: RenderBackend) -> bool {
        matches!((shaping, render), (ShapingBackend::Win, RenderBackend::Win))
    }

    fn execute_fused(
        &self,
        text: &str,
        font: &LoadedFont,
        options: &RenderOptions
    ) -> Result<RenderOutput, TypfError> {
        // Create DirectWrite text format and layout
        let text_format = self.create_text_format(font, options)?;
        let text_layout = self.factory.CreateTextLayout(
            text,
            &text_format,
            f32::MAX,
            f32::MAX,
        )?;

        // Get metrics
        let metrics = text_layout.GetMetrics()?;
        let width = metrics.width.ceil() as u32;
        let height = metrics.height.ceil() as u32;

        // Create D2D render target
        let render_target = self.create_bitmap_render_target(width, height)?;

        // Clear background
        render_target.BeginDraw();
        if let Some(bg) = options.background {
            render_target.Clear(&self.color_to_d2d(bg));
        }

        // Create brush for text
        let brush = render_target.CreateSolidColorBrush(
            &self.color_to_d2d(options.foreground),
            None
        )?;

        // Draw text
        render_target.DrawTextLayout(
            D2D1_POINT_2F { x: 0.0, y: 0.0 },
            &text_layout,
            &brush,
            D2D1_DRAW_TEXT_OPTIONS_NONE
        );

        render_target.EndDraw()?;

        // Get bitmap
        let bitmap = render_target.GetBitmap()?;
        let data = self.extract_bitmap_data(&bitmap)?;

        Ok(RenderOutput::Bitmap(BitmapData {
            width,
            height,
            data,
            format: PixelFormat::Bgra8, // DirectWrite uses BGRA
        }))
    }
}
```

## 2.6 Backend Registration and Factory

```rust
// typf-core/src/backend_registry.rs

pub struct BackendRegistry {
    shapers: HashMap<ShapingBackend, Arc<dyn Shaper>>,
    renderers: HashMap<RenderBackend, Arc<dyn Renderer>>,
    fused_engines: Vec<Arc<dyn FusedEngine>>,
}

impl BackendRegistry {
    pub fn new() -> Self {
        let mut registry = Self {
            shapers: HashMap::new(),
            renderers: HashMap::new(),
            fused_engines: Vec::new(),
        };

        // Register compiled backends
        #[cfg(feature = "shaping-none")]
        registry.register_shaper(ShapingBackend::None, Arc::new(NoneShaper));

        #[cfg(feature = "shaping-hb")]
        registry.register_shaper(ShapingBackend::Hb, Arc::new(HarfBuzzShaper::new()));

        #[cfg(feature = "shaping-icu-hb")]
        registry.register_shaper(ShapingBackend::IcuHb, Arc::new(IcuHarfBuzzShaper::new()));

        #[cfg(all(target_os = "macos", feature = "shaping-mac"))]
        registry.register_shaper(ShapingBackend::Mac, Arc::new(CoreTextShaper::new()));

        #[cfg(all(target_os = "windows", feature = "shaping-win"))]
        registry.register_shaper(ShapingBackend::Win, Arc::new(DirectWriteShaper::new()));

        // Register renderers
        #[cfg(feature = "render-json")]
        registry.register_renderer(RenderBackend::Json, Arc::new(JsonRenderer));

        #[cfg(feature = "render-orge")]
        registry.register_renderer(RenderBackend::Orge, Arc::new(OrgeRenderer::new()));

        #[cfg(feature = "render-skia")]
        registry.register_renderer(RenderBackend::Skia, Arc::new(SkiaRenderer::new(false)));

        #[cfg(feature = "render-skia-svg")]
        registry.register_renderer(RenderBackend::SkiaSvg, Arc::new(SkiaRenderer::new(true)));

        // Register fused engines
        #[cfg(all(target_os = "macos", feature = "shaping-mac", feature = "render-mac"))]
        registry.register_fused(Arc::new(CoreTextFusedEngine));

        #[cfg(all(target_os = "windows", feature = "shaping-win", feature = "render-win"))]
        registry.register_fused(Arc::new(DirectWriteFusedEngine::new()));

        registry
    }

    pub fn get_shaper(&self, backend: ShapingBackend) -> Result<Arc<dyn Shaper>, TypfError> {
        let backend = if backend == ShapingBackend::Auto {
            ShapingBackend::resolve_auto()
        } else {
            backend
        };

        self.shapers
            .get(&backend)
            .cloned()
            .ok_or_else(|| TypfError::FeatureNotCompiled(format!("shaping-{:?}", backend)))
    }

    pub fn get_renderer(&self, backend: RenderBackend) -> Result<Arc<dyn Renderer>, TypfError> {
        self.renderers
            .get(&backend)
            .cloned()
            .ok_or_else(|| TypfError::FeatureNotCompiled(format!("render-{:?}", backend)))
    }

    pub fn get_fused(&self, shaping: ShapingBackend, render: RenderBackend)
        -> Option<Arc<dyn FusedEngine>>
    {
        self.fused_engines
            .iter()
            .find(|engine| engine.can_handle(shaping, render))
            .cloned()
    }
}
```

## Next Steps

Part 03 will detail the font handling system, including zero-copy loading with read-fonts and skrifa, font caching strategies, and the complete removal of ttf-parser dependencies.