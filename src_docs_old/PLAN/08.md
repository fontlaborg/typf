# Part 08: Testing & Quality Assurance

## Overview

This document outlines TypF's comprehensive testing strategy, encompassing unit tests, integration tests, fuzz testing, property-based testing, cross-platform validation, and continuous integration pipelines to ensure extreme reliability and correctness.

## 8.1 Unit Testing Architecture

### Test Organization

```rust
// tests/lib.rs (workspace root)

#[cfg(test)]
mod tests {
    mod unit {
        mod input;
        mod unicode;
        mod font;
        mod shaping;
        mod rendering;
        mod export;
        mod cache;
        mod simd;
    }

    mod integration {
        mod pipeline;
        mod backends;
        mod compatibility;
        mod performance;
    }

    mod regression {
        mod issues;
        mod edge_cases;
    }
}
```

### Core Unit Tests

```rust
// typf-core/src/tests.rs

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;

    #[test]
    fn test_pipeline_minimal() {
        let pipeline = Pipeline::builder()
            .shaping_backend(ShapingBackend::None)
            .render_backend(RenderBackend::Orge)
            .build()
            .expect("Failed to build pipeline");

        let result = pipeline.execute(InputSpec {
            text: "Hello".into(),
            font_spec: FontSpec::System("sans-serif".into()),
            size: 16.0,
            output_format: OutputFormat::Pnm,
            ..Default::default()
        });

        assert!(result.is_ok());
        let output = result.unwrap();
        assert!(matches!(output, RenderOutput::Bitmap(_)));
    }

    #[test]
    fn test_error_handling() {
        let pipeline = Pipeline::default();

        // Test missing font
        let result = pipeline.execute(InputSpec {
            text: "Test".into(),
            font_spec: FontSpec::Path("/nonexistent/font.ttf".into()),
            ..Default::default()
        });

        assert!(matches!(
            result,
            Err(TypfError::FontLoad(FontLoadError::FileNotFound(_)))
        ));

        // Test invalid backend combination
        let result = Pipeline::builder()
            .shaping_backend(ShapingBackend::Mac)
            .render_backend(RenderBackend::Win)
            .build();

        assert!(matches!(
            result,
            Err(TypfError::UnsupportedBackendCombination(_, _))
        ));
    }

    #[test]
    fn test_cache_key_equality() {
        let key1 = GlyphCacheKey::new(42, &font, 16.0, (0.0, 0.0), HintingMode::Slight, &[]);
        let key2 = GlyphCacheKey::new(42, &font, 16.0, (0.0, 0.0), HintingMode::Slight, &[]);
        let key3 = GlyphCacheKey::new(43, &font, 16.0, (0.0, 0.0), HintingMode::Slight, &[]);

        assert_eq!(key1, key2);
        assert_ne!(key1, key3);

        // Test hash consistency
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        let mut hasher1 = DefaultHasher::new();
        let mut hasher2 = DefaultHasher::new();
        key1.hash(&mut hasher1);
        key2.hash(&mut hasher2);

        assert_eq!(hasher1.finish(), hasher2.finish());
    }

    #[test]
    #[should_panic(expected = "NotImplemented")]
    fn test_not_implemented_feature() {
        let pipeline = Pipeline::default();

        pipeline.execute(InputSpec {
            text: "Test".into(),
            font_spec: FontSpec::System("Arial".into()),
            // Request a feature that's not implemented
            output_format: OutputFormat::Custom("unknown".into()),
            ..Default::default()
        }).expect("Should panic with NotImplemented");
    }
}
```

### Unicode Processing Tests

```rust
// typf-unicode/src/tests.rs

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_normalization() {
        let processor = UnicodeProcessor::new();

        // Test NFC normalization
        let input = "Ã©"; // e + combining acute
        let normalized = processor.normalize(input);
        assert_eq!(normalized, "Ã©"); // precomposed

        // Test NFD normalization
        let processor_nfd = UnicodeProcessor::with_form(NormalizationForm::NFD);
        let normalized_nfd = processor_nfd.normalize("Ã©");
        assert_eq!(normalized_nfd.chars().count(), 2); // base + combining
    }

    #[test]
    fn test_script_detection() {
        let processor = UnicodeProcessor::new();

        let runs = processor.detect_script_runs("Hello Ù…Ø±Ø­Ø¨Ø§ ä½ å¥½");
        assert_eq!(runs.len(), 5); // Latin, space, Arabic, space, Han

        assert_eq!(runs[0].script, Script::Latin);
        assert_eq!(runs[1].script, Script::Common); // space
        assert_eq!(runs[2].script, Script::Arabic);
        assert_eq!(runs[3].script, Script::Common); // space
        assert_eq!(runs[4].script, Script::Han);
    }

    #[test]
    fn test_bidi_resolution() {
        let processor = UnicodeProcessor::new();

        // RTL text with embedded LTR
        let text = "Ù…Ø±Ø­Ø¨Ø§ ABC Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…";
        let runs = processor.process(text).unwrap();

        // Verify correct directionality
        assert!(runs.iter().any(|r| r.direction == Direction::RTL));
        assert!(runs.iter().any(|r| r.direction == Direction::LTR));
    }

    #[test]
    fn test_grapheme_clusters() {
        let processor = UnicodeProcessor::new();

        // Test emoji with modifiers
        let text = "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦"; // Family emoji (ZWJ sequence)
        let clusters = processor.grapheme_clusters(text);
        assert_eq!(clusters.len(), 1); // Single grapheme cluster

        // Test combining marks
        let text = "e\u{0301}"; // e + combining acute
        let clusters = processor.grapheme_clusters(text);
        assert_eq!(clusters.len(), 1); // Single grapheme cluster
    }
}
```

### Shaping Backend Tests

```rust
// backends/typf-shape-hb/src/tests.rs

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_harfbuzz_basic_shaping() {
        let shaper = HarfBuzzShaper::new();
        let font = load_test_font("NotoSans-Regular.ttf");

        let result = shaper.shape(
            &TextRun {
                text: "Hello".into(),
                script: Script::Latin,
                direction: Direction::LTR,
                language: Some("en".into()),
                range: 0..5,
            },
            &font,
            &ShapingOptions::default()
        ).unwrap();

        assert_eq!(result.glyphs.len(), 5);
        assert!(result.advance_width > 0.0);

        // Verify glyph IDs are non-zero (not .notdef)
        for glyph in &result.glyphs {
            assert_ne!(glyph.glyph_id, 0);
        }
    }

    #[test]
    fn test_ligature_shaping() {
        let shaper = HarfBuzzShaper::new();
        let font = load_test_font("fonts/with-ligatures.otf");

        let mut options = ShapingOptions::default();
        options.features.insert(tag!(b"liga"), 1);

        let result = shaper.shape(
            &TextRun {
                text: "office".into(),
                script: Script::Latin,
                direction: Direction::LTR,
                language: Some("en".into()),
                range: 0..6,
            },
            &font,
            &options
        ).unwrap();

        // "ffi" should form a ligature
        assert!(result.glyphs.len() < 6);
    }

    #[test]
    fn test_arabic_shaping() {
        let shaper = HarfBuzzShaper::new();
        let font = load_test_font("NotoSansArabic-Regular.ttf");

        let result = shaper.shape(
            &TextRun {
                text: "Ù…Ø±Ø­Ø¨Ø§".into(),
                script: Script::Arabic,
                direction: Direction::RTL,
                language: Some("ar".into()),
                range: 0..10, // UTF-8 byte length
            },
            &font,
            &ShapingOptions::default()
        ).unwrap();

        // Verify RTL ordering
        let first_glyph = &result.glyphs[0];
        let last_glyph = result.glyphs.last().unwrap();
        assert!(first_glyph.x_offset > last_glyph.x_offset);
    }
}
```

## 8.2 Integration Testing

### End-to-End Pipeline Tests

```rust
// tests/integration/pipeline.rs

use typf::prelude::*;
use std::path::PathBuf;

#[test]
fn test_complete_pipeline() {
    let test_cases = vec![
        ("Latin simple", "Hello, World!", "en", Script::Latin),
        ("Arabic", "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…", "ar", Script::Arabic),
        ("Chinese", "ä½ å¥½ä¸–ç•Œ", "zh", Script::Han),
        ("Japanese", "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ", "ja", Script::Hiragana),
        ("Emoji", "Hello ðŸ‘‹ ðŸŒ", "en", Script::Common),
        ("Mixed", "Test ØªØ³Øª ãƒ†ã‚¹ãƒˆ", "und", Script::Common),
    ];

    for (name, text, lang, expected_script) in test_cases {
        println!("Testing: {}", name);

        let typf = Typf::new().expect("Failed to create TYPF");

        // Test shaping
        let shaped = typf.shape_with_options(
            text,
            ShapingOptions::builder()
                .font("NotoSans-Regular.ttf")
                .size(16.0)
                .language(lang)
                .build()
        ).expect(&format!("Failed to shape {}", name));

        assert!(!shaped.glyphs.is_empty(), "{} produced no glyphs", name);

        // Test rendering
        let rendered = typf.render_with_options(
            text,
            RenderOptions::builder()
                .font("NotoSans-Regular.ttf")
                .size(16.0)
                .language(lang)
                .format(OutputFormat::Png)
                .build()
        ).expect(&format!("Failed to render {}", name));

        match rendered {
            RenderOutput::Bitmap(data) => {
                assert!(!data.is_empty(), "{} produced empty bitmap", name);
            }
            _ => panic!("Expected bitmap output for {}", name),
        }
    }
}

#[test]
fn test_backend_combinations() {
    let combinations = vec![
        (ShapingBackend::HarfBuzz, RenderBackend::Orge),
        (ShapingBackend::HarfBuzz, RenderBackend::Skia),
        #[cfg(target_os = "macos")]
        (ShapingBackend::Mac, RenderBackend::Mac),
        #[cfg(target_os = "windows")]
        (ShapingBackend::Win, RenderBackend::Win),
    ];

    for (shaping, render) in combinations {
        let typf = Typf::builder()
            .shaping_backend(shaping)
            .render_backend(render)
            .build()
            .expect(&format!("Failed to build with {:?}/{:?}", shaping, render));

        let result = typf.render("Test").expect("Failed to render");
        assert!(!result.is_empty());
    }
}
```

### Compatibility Tests

```rust
// tests/integration/compatibility.rs

#[test]
fn test_harfbuzz_compatibility() {
    // Compare our output with HarfBuzz reference
    let text = "Hello";
    let font_path = "tests/fonts/NotoSans-Regular.ttf";

    // Get reference from hb-shape command
    let hb_output = std::process::Command::new("hb-shape")
        .args(&[font_path, text, "--output-format=json"])
        .output()
        .expect("Failed to run hb-shape");

    let hb_json: serde_json::Value = serde_json::from_slice(&hb_output.stdout)
        .expect("Failed to parse hb-shape output");

    // Get our output
    let typf = Typf::builder()
        .shaping_backend(ShapingBackend::HarfBuzz)
        .render_backend(RenderBackend::Json)
        .build()
        .unwrap();

    let our_result = typf.render_with_options(
        text,
        RenderOptions::builder()
            .font(font_path)
            .format(OutputFormat::Json)
            .build()
    ).unwrap();

    let our_json: serde_json::Value = match our_result {
        RenderOutput::Json(data) => serde_json::from_str(data.as_str()).unwrap(),
        _ => panic!("Expected JSON output"),
    };

    // Compare glyph IDs and advances
    assert_eq!(
        hb_json["glyphs"].as_array().unwrap().len(),
        our_json["glyphs"].as_array().unwrap().len()
    );

    for (hb_glyph, our_glyph) in hb_json["glyphs"]
        .as_array()
        .unwrap()
        .iter()
        .zip(our_json["glyphs"].as_array().unwrap().iter())
    {
        assert_eq!(hb_glyph["g"], our_glyph["g"], "Glyph ID mismatch");
        // Allow small differences in positioning due to rounding
        let hb_ax = hb_glyph["ax"].as_f64().unwrap();
        let our_ax = our_glyph["ax"].as_f64().unwrap();
        assert!((hb_ax - our_ax).abs() < 1.0, "Advance mismatch");
    }
}
```

## 8.3 Property-Based Testing

### Using Proptest

```rust
// tests/property/mod.rs

use proptest::prelude::*;
use typf::prelude::*;

proptest! {
    #[test]
    fn test_shaping_never_panics(
        text in "[a-zA-Z0-9 ]{1,100}",
        size in 1.0f32..200.0,
        letter_spacing in -10.0f32..10.0,
    ) {
        let typf = Typf::new().unwrap();

        let result = typf.shape_with_options(
            &text,
            ShapingOptions::builder()
                .size(size)
                .letter_spacing(Some(letter_spacing))
                .build()
        );

        // Should either succeed or return a known error
        match result {
            Ok(shaped) => {
                // Basic invariants
                prop_assert!(shaped.advance_width >= 0.0);
                prop_assert!(shaped.glyphs.len() <= text.len() * 2); // Max 2 glyphs per char
            }
            Err(e) => {
                // Should be a known error type
                prop_assert!(
                    matches!(e, TypfError::ShapingFailed(_)) ||
                    matches!(e, TypfError::FontLoad(_))
                );
            }
        }
    }

    #[test]
    fn test_cache_consistency(
        glyph_ids in prop::collection::vec(0u32..1000, 1..100),
        sizes in prop::collection::vec(1.0f32..100.0, 1..10),
    ) {
        let cache = CacheSystem::new(CacheConfig::default());
        let font = load_test_font("NotoSans-Regular.ttf");

        // Insert items
        for (glyph_id, size) in glyph_ids.iter().zip(sizes.iter().cycle()) {
            let key = GlyphCacheKey::new(
                *glyph_id,
                &font,
                *size,
                (0.0, 0.0),
                HintingMode::Slight,
                &[]
            );
            let glyph = create_test_glyph(*glyph_id);
            cache.put_glyph(key.clone(), Arc::new(glyph));
        }

        // Verify retrieval
        for (glyph_id, size) in glyph_ids.iter().zip(sizes.iter().cycle()).take(10) {
            let key = GlyphCacheKey::new(
                *glyph_id,
                &font,
                *size,
                (0.0, 0.0),
                HintingMode::Slight,
                &[]
            );

            if let Some(cached) = cache.get_glyph(&key) {
                prop_assert_eq!(cached.glyph_id, *glyph_id);
            }
        }
    }

    #[test]
    fn test_color_parsing_roundtrip(
        r in 0u8..=255,
        g in 0u8..=255,
        b in 0u8..=255,
        a in 0u8..=255,
    ) {
        let color = Color::rgba(r, g, b, a);
        let hex = color.to_hex();
        let parsed = Color::from_hex(&hex).unwrap();

        prop_assert_eq!(color, parsed);
    }
}
```

### Quickcheck Properties

```rust
// tests/property/quickcheck.rs

use quickcheck::{quickcheck, Arbitrary, Gen};

#[derive(Clone, Debug)]
struct ValidFontSize(f32);

impl Arbitrary for ValidFontSize {
    fn arbitrary(g: &mut Gen) -> Self {
        ValidFontSize(f32::arbitrary(g).abs().max(0.1).min(1000.0))
    }
}

quickcheck! {
    fn prop_render_dimensions_match_measure(
        text: String,
        size: ValidFontSize
    ) -> bool {
        let typf = Typf::new().unwrap();

        let metrics = typf.measure(&text, size.0).unwrap_or_default();

        let rendered = typf.render_with_options(
            &text,
            RenderOptions::builder()
                .size(size.0)
                .format(OutputFormat::Png)
                .build()
        );

        match rendered {
            Ok(RenderOutput::Bitmap(data)) => {
                // Dimensions should match within tolerance
                (data.width as f32 - metrics.width).abs() < 2.0 &&
                (data.height as f32 - metrics.height).abs() < 2.0
            }
            _ => true // Skip if rendering failed
        }
    }

    fn prop_shaping_is_deterministic(text: String) -> bool {
        let typf = Typf::new().unwrap();

        let result1 = typf.shape(&text);
        let result2 = typf.shape(&text);

        match (result1, result2) {
            (Ok(r1), Ok(r2)) => {
                r1.glyphs == r2.glyphs &&
                r1.advance_width == r2.advance_width
            }
            (Err(_), Err(_)) => true,
            _ => false,
        }
    }
}
```

## 8.4 Fuzz Testing

### Fuzzing Infrastructure

```rust
// fuzz/fuzz_targets/shape.rs

#![no_main]
use libfuzzer_sys::fuzz_target;
use typf::prelude::*;

fuzz_target!(|data: &[u8]| {
    // Try to interpret data as UTF-8
    if let Ok(text) = std::str::from_utf8(data) {
        let typf = Typf::new().unwrap();

        // Fuzz shaping
        let _ = typf.shape(text);

        // Fuzz with random parameters if we have enough data
        if data.len() > 16 {
            let size = (data[0] as f32) / 255.0 * 100.0 + 1.0;
            let letter_spacing = (data[1] as i8) as f32 / 10.0;

            let _ = typf.shape_with_options(
                text,
                ShapingOptions::builder()
                    .size(size)
                    .letter_spacing(Some(letter_spacing))
                    .build()
            );
        }
    }

    // Also fuzz with raw bytes (invalid UTF-8)
    let _ = typf_internal::process_raw_bytes(data);
});
```

### AFL Fuzzing

```rust
// fuzz/afl_target.rs

use afl::fuzz;
use typf::prelude::*;

fn main() {
    fuzz!(|data: &[u8]| {
        let typf = Typf::new().unwrap();

        // Fuzz font loading
        if data.len() > 1024 {
            let _ = typf.load_font_from_bytes(data);
        }

        // Fuzz text processing
        if let Ok(text) = String::from_utf8(data.to_vec()) {
            let _ = typf.shape(&text);
        }

        // Fuzz color parsing
        if data.len() >= 6 {
            let hex = format!("#{:02x}{:02x}{:02x}", data[0], data[1], data[2]);
            let _ = Color::from_hex(&hex);
        }
    });
}
```

## 8.5 Performance Testing

### Benchmark Suite

```rust
// benches/performance.rs

use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};

fn benchmark_text_lengths(c: &mut Criterion) {
    let mut group = c.benchmark_group("text_length");
    let typf = Typf::new().unwrap();

    for length in [10, 100, 1000, 10000] {
        let text = "a".repeat(length);

        group.bench_with_input(
            BenchmarkId::from_parameter(length),
            &text,
            |b, text| {
                b.iter(|| {
                    typf.shape(black_box(text))
                })
            }
        );
    }

    group.finish();
}

fn benchmark_font_sizes(c: &mut Criterion) {
    let mut group = c.benchmark_group("font_size");
    let typf = Typf::new().unwrap();
    let text = "Hello, World!";

    for size in [8.0, 12.0, 16.0, 24.0, 48.0, 96.0] {
        group.bench_with_input(
            BenchmarkId::from_parameter(size),
            &size,
            |b, &size| {
                b.iter(|| {
                    typf.render_with_options(
                        black_box(text),
                        RenderOptions::builder().size(size).build()
                    )
                })
            }
        );
    }

    group.finish();
}

fn benchmark_cache_effectiveness(c: &mut Criterion) {
    let mut group = c.benchmark_group("cache");

    // Cold cache
    group.bench_function("cold", |b| {
        b.iter_with_setup(
            || Typf::new().unwrap(),
            |typf| {
                for i in 0..100 {
                    typf.shape(&format!("Text {}", i)).unwrap();
                }
            }
        );
    });

    // Warm cache
    group.bench_function("warm", |b| {
        let typf = Typf::new().unwrap();
        // Pre-warm cache
        for i in 0..100 {
            typf.shape(&format!("Text {}", i)).unwrap();
        }

        b.iter(|| {
            for i in 0..100 {
                typf.shape(&format!("Text {}", i)).unwrap();
            }
        });
    });

    group.finish();
}

criterion_group!(
    benches,
    benchmark_text_lengths,
    benchmark_font_sizes,
    benchmark_cache_effectiveness
);
criterion_main!(benches);
```

### Memory Usage Testing

```rust
// tests/memory.rs

use dhat::{Dhat, DhatAlloc};

#[global_allocator]
static ALLOCATOR: DhatAlloc = DhatAlloc;

#[test]
fn test_memory_usage() {
    let _dhat = Dhat::start_heap_profiling();

    let typf = Typf::new().unwrap();

    // Process large amount of text
    for i in 0..1000 {
        let text = format!("Test string number {}", i);
        let _ = typf.shape(&text);
    }

    // Check memory stats
    let stats = dhat::HeapStats::get();
    println!("Total allocated: {} bytes", stats.total_bytes);
    println!("Peak allocated: {} bytes", stats.peak_bytes);
    println!("Current allocated: {} bytes", stats.curr_bytes);

    // Assert reasonable memory usage
    assert!(stats.peak_bytes < 100_000_000, "Peak memory too high");
    assert!(stats.curr_bytes < 10_000_000, "Memory leak detected");
}
```

## 8.6 Cross-Platform Testing

### Platform-Specific Tests

```rust
// tests/platform/mod.rs

#[cfg(target_os = "macos")]
#[test]
fn test_coretext_backend() {
    let typf = Typf::builder()
        .shaping_backend(ShapingBackend::Mac)
        .render_backend(RenderBackend::Mac)
        .build()
        .unwrap();

    let result = typf.render("macOS native test").unwrap();
    assert!(!result.is_empty());

    // Test system font access
    let system_result = typf.render_with_options(
        "System font test",
        RenderOptions::builder()
            .font("San Francisco")
            .build()
    );
    assert!(system_result.is_ok());
}

#[cfg(target_os = "windows")]
#[test]
fn test_directwrite_backend() {
    let typf = Typf::builder()
        .shaping_backend(ShapingBackend::Win)
        .render_backend(RenderBackend::Win)
        .build()
        .unwrap();

    let result = typf.render("Windows native test").unwrap();
    assert!(!result.is_empty());

    // Test system font access
    let system_result = typf.render_with_options(
        "System font test",
        RenderOptions::builder()
            .font("Segoe UI")
            .build()
    );
    assert!(system_result.is_ok());
}

#[cfg(target_arch = "wasm32")]
#[wasm_bindgen_test]
fn test_wasm_backend() {
    let typf = Typf::builder()
        .shaping_backend(ShapingBackend::HarfBuzz)
        .render_backend(RenderBackend::Orge)
        .build()
        .unwrap();

    let result = typf.render("WASM test").unwrap();
    assert!(!result.is_empty());
}
```

## 8.7 CI/CD Testing Pipeline

### Comprehensive CI Configuration

```yaml
# .github/workflows/test.yml

name: Tests

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  RUST_BACKTRACE: 1
  CARGO_TERM_COLOR: always

jobs:
  unit-tests:
    name: Unit Tests
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        rust: [stable, beta]
        features: [minimal, default, full]

    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{ matrix.rust }}
          components: rustfmt, clippy

      - name: Cache
        uses: Swatinem/rust-cache@v2

      - name: Run tests
        run: cargo test --no-default-features --features ${{ matrix.features }}

      - name: Run doctests
        run: cargo test --doc --no-default-features --features ${{ matrix.features }}

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libharfbuzz-dev libicu-dev

      - name: Run integration tests
        run: cargo test --test integration --features full

  property-tests:
    name: Property Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Run proptest
        run: cargo test --test property --features full
        env:
          PROPTEST_CASES: 1000

      - name: Run quickcheck
        run: cargo test --test quickcheck --features full
        env:
          QUICKCHECK_TESTS: 1000

  fuzz-tests:
    name: Fuzz Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install cargo-fuzz
        run: cargo install cargo-fuzz

      - name: Run fuzz tests
        run: |
          cd fuzz
          cargo fuzz run shape -- -max_total_time=60
          cargo fuzz run render -- -max_total_time=60

  memory-tests:
    name: Memory Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install valgrind
        run: sudo apt-get install -y valgrind

      - name: Run with valgrind
        run: |
          cargo build --release --examples
          valgrind --leak-check=full --show-leak-kinds=all \
            ./target/release/examples/basic_render

      - name: Run DHAT tests
        run: cargo test --test memory --features dhat

  benchmark-tests:
    name: Benchmark Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Run benchmarks
        run: cargo bench --features full

      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: benchmarks
          path: target/criterion

  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install tarpaulin
        run: cargo install cargo-tarpaulin

      - name: Generate coverage
        run: cargo tarpaulin --features full --out Xml

      - name: Upload to codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./cobertura.xml
          fail_ci_if_error: true

  clippy:
    name: Clippy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Run clippy
        run: cargo clippy --all-targets --all-features -- -D warnings

  format:
    name: Format
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check format
        run: cargo fmt --all -- --check

  security:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Run cargo-audit
        run: |
          cargo install cargo-audit
          cargo audit

      - name: Run cargo-deny
        run: |
          cargo install cargo-deny
          cargo deny check
```

## 8.8 Test Data and Fixtures

### Test Font Collection

```rust
// tests/fixtures/mod.rs

use once_cell::sync::Lazy;
use std::collections::HashMap;

pub static TEST_FONTS: Lazy<HashMap<&'static str, Vec<u8>>> = Lazy::new(|| {
    let mut fonts = HashMap::new();

    // Basic Latin font
    fonts.insert(
        "latin",
        include_bytes!("../assets/fonts/NotoSans-Regular.ttf").to_vec()
    );

    // Arabic font
    fonts.insert(
        "arabic",
        include_bytes!("../assets/fonts/NotoSansArabic-Regular.ttf").to_vec()
    );

    // CJK font
    fonts.insert(
        "cjk",
        include_bytes!("../assets/fonts/NotoSansCJK-Regular.ttc").to_vec()
    );

    // Emoji font
    fonts.insert(
        "emoji",
        include_bytes!("../assets/fonts/NotoColorEmoji.ttf").to_vec()
    );

    // Variable font
    fonts.insert(
        "variable",
        include_bytes!("../assets/fonts/Inter-Variable.ttf").to_vec()
    );

    fonts
});

pub fn load_test_font(name: &str) -> FontRef {
    let data = TEST_FONTS.get(name).expect(&format!("Test font {} not found", name));
    FontRef::new(data).expect("Failed to load test font")
}
```

### Golden Test Files

```rust
// tests/golden/mod.rs

use std::path::{Path, PathBuf};

pub fn golden_path(name: &str) -> PathBuf {
    Path::new("tests/golden").join(name)
}

#[test]
fn test_against_golden() {
    let typf = Typf::new().unwrap();

    for entry in std::fs::read_dir("tests/golden/inputs").unwrap() {
        let entry = entry.unwrap();
        let input_path = entry.path();

        if input_path.extension() == Some("txt".as_ref()) {
            let text = std::fs::read_to_string(&input_path).unwrap();
            let expected_path = input_path
                .with_extension("expected.json");

            let result = typf.shape(&text).unwrap();
            let actual_json = serde_json::to_string_pretty(&result).unwrap();

            if expected_path.exists() {
                let expected = std::fs::read_to_string(&expected_path).unwrap();
                assert_eq!(actual_json, expected, "Golden test failed for {:?}", input_path);
            } else {
                // Generate golden file (first run)
                std::fs::write(&expected_path, actual_json).unwrap();
                println!("Generated golden file: {:?}", expected_path);
            }
        }
    }
}
```

## 8.9 Test Coverage Requirements

### Coverage Targets

| Component | Line Coverage | Branch Coverage | Notes |
|-----------|--------------|-----------------|-------|
| Core Pipeline | 90% | 85% | Critical path |
| Unicode Processing | 95% | 90% | Security critical |
| Shaping Backends | 85% | 80% | Platform specific |
| Rendering Backends | 85% | 80% | Platform specific |
| Cache System | 90% | 85% | Performance critical |
| SIMD Code | 80% | 75% | Hardware dependent |
| Error Handling | 100% | 100% | All errors tested |

### Coverage Enforcement

```toml
# .tarpaulin.toml

[default]
features = "full"
exclude-files = ["*/tests/*", "*/benches/*", "*/examples/*"]
ignore-panics = true
ignored-lines = ["#\\[derive", "^\\}$", "^\\s*$"]
force-clean = true
verbose = true
fail-under = 80
```

## Next Steps

With comprehensive testing strategies defined, Part 09 will detail the implementation roadmap and release strategy.
